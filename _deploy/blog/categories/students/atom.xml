<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Students | SciRuby]]></title>
  <link href="http://sciruby.com/blog/categories/students/atom.xml" rel="self"/>
  <link href="http://sciruby.com/"/>
  <updated>2017-10-17T20:33:21+09:00</updated>
  <id>http://sciruby.com/</id>
  <author>
    <name><![CDATA[SciRuby]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[GSoC 2016 : A Look at SpiceRub::Body]]></title>
    <link href="http://sciruby.com/blog/2016/11/25/gsoc-2016-a-look-at-spicerub-body/"/>
    <updated>2016-11-25T02:23:00+09:00</updated>
    <id>http://sciruby.com/blog/2016/11/25/gsoc-2016-a-look-at-spicerub-body</id>
    <content type="html"><![CDATA[<p>One of the main goals of this project was to make the ephemerides
functions easily available to an end user. Ephemerides basically
refers to an object in space whose motion is being tracked and
observed. SPICE required you to provide the following parameters to
observe a body in space.</p>

<ul>
<li><code>Target</code>: The body of interest</li>
<li><code>Frame</code>: A rotational frame of reference (Default is J2000 [Not to be confused with the J2000 epoch])</li>
<li><code>Observer</code>: An observing body whose viewpoint is used to chart the vector</li>
<li><code>Epoch</code> : An epoch in Ephemeris Time</li>
</ul>


<p>SPICE has an integer-key convention for the kind of bodies that it
has support for. Each body can be referenced via a string or an
integer id. While there isn't an actual strict range for integer ID
classification, it is mentioned <a href="https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/req/naif_ids.html">here</a> and can be summed up
in the following <code>if</code> and <code>elsif</code> clauses. (In Ruby constant strings
are better off as symbols, so the constructor takes either an integer
ID of a string symbol)</p>

<p>```ruby
  if body_id > 2000000</p>

<pre><code>:asteroid
</code></pre>

<p>  elsif body_id > 1000000</p>

<pre><code>:comet
</code></pre>

<p>  elsif body_id > 1000</p>

<pre><code>:body
</code></pre>

<p>  elsif body_id > 10</p>

<pre><code>body_id % 100 == 99 ?
  :planet : :satellite
</code></pre>

<p>  elsif body_id == 10</p>

<pre><code>:star
</code></pre>

<p>  elsif body_id > 0</p>

<pre><code>:barycenter
</code></pre>

<p>  elsif body_id > -1000</p>

<pre><code>:spacecraft
</code></pre>

<p>  elsif body_id > -100000</p>

<pre><code>:instrument
</code></pre>

<p>  else</p>

<pre><code>:spacecraft
</code></pre>

<p>```</p>

<p>It was very tempting to involve inheritance and extend a base Body
class onto these potential classes, but I simply did not see the need
for it at this point. The way it is at the moment, the <code>Body</code> object
has a reader attribute type that stores some metadata about the body
for the user's convenience. Perhaps as coverage of SPICE improves,
this minor thing can be changed later on.</p>

<p>To create a Body object, you instantiate with either a body name or a
body id. Certain bodies such as instruments will require additional
kernels to be loaded. To proceed seamlessly, load a leap seconds
kernel, a planetary constants kernel, and an ephemeris kernel. (All
avaialable in <code>spec/data/kernels</code>)</p>

<p>```ruby
SpiceRub::Body.new(399)
=> #&lt;SpiceRub::Body:0x00000002769da8</p>

<pre><code> @code=399,
 @frame=:J2000,
 @name=:earth,
 @type=:planet&gt;
</code></pre>

<p>SpiceRub::Body.new(:earth)
=> #&lt;SpiceRub::Body:0x000000026c73c8
   @code=399,
   @frame=:J2000,
   @name=:earth,
   @type=:planet></p>

<p>SpiceRub::Body.new(:moon)
=> #&lt;SpiceRub::Body:0x0000000214ac88
   @code=301,
   @frame=:J2000,
   @name=:moon,
   @type=:satellite>
```</p>

<p><code>399</code> and <code>:earth</code> map to the same body in SPICE data. The frame of
reference can also be specified as a named parameter during
instantiation to set a custom default frame for that particular
object.</p>

<p>```ruby
SpiceRub::Body.new(399, frame: IAU_EARTH)
=> #&lt;SpiceRub::Body:0x000000020b1df8</p>

<pre><code> @code=399,
 @frame=:IAU_EARTH,
 @name=:earth,
 @type=:planet&gt;
</code></pre>

<p>```</p>

<p>In SPICE, a <code>state</code> is a 6 length column vector that stores position
and velocity in 3D cartesian co-ordinates</p>

<p>As a base case, let's find out the the position of the Earth with
respect to itself.</p>

<p>```ruby</p>

<p>earth.position_at(SpiceRub::Time.now, observer: earth)
=>
[
  [0.0]   [0.0]   [0.0]
]
```</p>

<p>The origin as seen from itself is still the origin, so this makes
sense. The methods <code>#velocity_at</code> and <code>#state_at</code> take an identical
set of parameters. While there is a bit of redundancy going on,
splitting them makes the API more elegant, but the basic relationship
between these three vectors is the following :-</p>

<p>```ruby</p>

<p>state = [</p>

<pre><code>      position[0],position[1],position[2],  
      velocity[0],velocity[1],velocity[2]
    ]
</code></pre>

<p>```</p>

<p>One thing to note is that state/velocity/position vectors will always
be returned as an <code>NMatrix</code> object, SciRuby's numerical matrix core,
to allow for calculations via the NMatrix API.</p>

<p>As an example that is used in the code, one line can turn a position
vector into distance from origin (here using Euclidean distance):</p>

<p><code>ruby
  position = earth.position_at(SpiceRub::Time.now, observer: observer)
  Math.sqrt( (position ** 2).sum[0] )      
</code></p>

<p>As a simple imprecise experiment, let's find out how the speed of
light can be "estimated" up with this data.</p>

<p>```ruby
distance = moon.distance_from(earth, now)
=> 367441.0260814745</p>

<p>time = moon.light_time_from(earth, now)
=> 1.2256513340354764</p>

<p>distance / time
=> 299792.458
```</p>

<p>The unit of distance here is kilometers, so the speed of light by this
measurement is about pretty close to the textbook figure of 3e+8 m/s.</p>

<p>There is also a function to check if a list of bodies are within a
radial proximity from an observing body. We already calculated the
distance of the moon to be about 367,000 km. The function
<code>within_proximity</code> returns a list of all bodies that are within the
specified radial distance from the calling body object.</p>

<p>```ruby</p>

<h1>assuming venus and mercury are instantiated</h1>

<p>earth.within_proximity([moon, venus, mercury], 400000, now)
=> [#&lt;SpiceRub::Body:0x0000000191c4f8
  @code=301,
  @frame=:J2000,
  @name=:moon,
  @type=:satellite>]
```</p>

<p>Now that we've come to the end of the functionality, I would like to
mention that there is another named argument <code>aberration_correction</code>
which is basically an error reduction method to provide a more
accurate result than the default observation. The default <code>:none</code>
option for aberration correction basically provides the geometric
observations without any corrections for reception or transmission of
photons. For a list of various aberration correction methods
available, have a look at the documentation for <a href="ftp://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkpos_c.html">spkpos_c</a> to
find out if you need an aberration correction on SPICE data.</p>

<p>```ruby
d1 = moon.distance_from(earth, SpiceRub::Time.now, aberration_correction: :none)
=> 369111.0550333138
d2 = moon.distance_from(earth, SpiceRub::Time.now, aberration_correction: :LT)
=> 369146.60640691273</p>

<p>d2 - d1
=> 35.55137359892251
```</p>

<p>If you want to look at it another way, no aberration correction would
give you the textbook response of rigid geometry, while introducing an
aberration correction would give you a somewhat more realistic output
accounting for the errors that do happen when these observations are
made.</p>

<p>Finally, if you need to generate a continuous time series for a body,
then <code>SpiceRub::Time</code> has two functions to aid in that:</p>

<p>```ruby
SpiceRub::Time.linear_time_series(now, now + 86400, 4)
=> [</p>

<pre><code>#&lt;SpiceRub::Time:0x00000001fe8b60 @et=525180780.18277323&gt;,
#&lt;SpiceRub::Time:0x00000001fe8a20 @et=525209580.18277323&gt;,
#&lt;SpiceRub::Time:0x00000001fe88b8 @et=525238380.18277323&gt;,
#&lt;SpiceRub::Time:0x00000001fe8750 @et=525267180.18277323&gt;
</code></pre>

<p>   ]
```</p>

<p>In this case, I took a start time and an end time that was one day
after and requested 4 linearly spaced epochs. This is basically an
interface to <code>NMatrix.linspace</code>.</p>

<p>The other function requires you to input a start time and an end time
and a step size that keeps getting added to the start time till the
end time is reached. As a contrived example, we'll take two epochs,
five days apart and ask for a step size of a day, expecting six
elements.</p>

<p>```ruby</p>

<p>SpiceRub::Time.time_series(now, now + 5 * 86400, step: 86400)
=> [</p>

<pre><code>#&lt;SpiceRub::Time:0x00000001646580 @et=525180780.18277323&gt;,
#&lt;SpiceRub::Time:0x00000002f315b8 @et=525267180.18277323&gt;,
#&lt;SpiceRub::Time:0x00000002f31590 @et=525353580.18277323&gt;,
#&lt;SpiceRub::Time:0x00000002f31568 @et=525439980.18277323&gt;,
#&lt;SpiceRub::Time:0x00000002f31540 @et=525526380.18277323&gt;,
#&lt;SpiceRub::Time:0x00000002f31518 @et=525612780.18277323&gt;
</code></pre>

<p>   ]</p>

<p>```</p>

<p>And that's it for this blog post. I would appreciate any feedback
regarding this as I've been juggling the design back and forth very
frequently. There is large potential of expansion of the <code>Body</code> class,
particularly creating new classes as when different Bobdy objects
would have a corresponding function. (For example, the function
<code>getfov_c</code> which returns the field of view of an instrument could be
an instance function attached to the <code>Instrument</code> subclass of <code>Body</code>,
but this is just potential expansions in the future.)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GSoC 2016 : A Look at SpiceRub::Time]]></title>
    <link href="http://sciruby.com/blog/2016/11/25/gsoc-2016-a-look-at-spicerub-time/"/>
    <updated>2016-11-25T02:22:00+09:00</updated>
    <id>http://sciruby.com/blog/2016/11/25/gsoc-2016-a-look-at-spicerub-time</id>
    <content type="html"><![CDATA[<p>Many popular programming languages these days ship with powerful Time
classes/interfaces to make the inevitable task of dealing with
time-related computations a more DRY experience. Humans like their
time representations to be stringy concatenations of various numbers
and alphabets that enable a large variety of date and time formats to
mean the same thing and still make instant sense to the human eye. It
was the creation of time zones that made our convenient 24-hour clocks
stay the way they are without experiencing day and night at the same
"time" across the globe. So now <code>00:00 A.M. UTC</code> is <code>5:30 A.M. IST</code>
for me, and the world remains sane.</p>

<p>But what happens when you accept the fact that you're just a speck of
micro-dust adjusting time relatively for an only slightly bigger speck
of dust floating in the universe? Twenty-four hours in a day and thus we reset
after 2300, but consider: how would a resident of Venus know
when tea-time is on Venus if he had an Earth wristwatch that reset
after twenty-four hours? Barely a tenth of Venus' day is complete in that time!
(If you know anybody intent on relocating to Mars, do not gift them a
clock or watch.)</p>

<p>So a decimal floating point representation must be the answer for
uniformity. Time zones can be dealt with; we'll just pick a convenient
point in time and count the seconds from there onwards so that the
location on Earth doesn't matter henceforth. It'll drive humans insane
with the arithmetic but machines will work just fine with this. This
sort of a time system is called epoch time.</p>

<p>And so the internal time of most UNIX machines is the number of
seconds after midnight on <code>Thursday, 1 January 1970 UTC</code>. (And this
very convention is going to open a can of worms by
<a href="https://en.wikipedia.org/wiki/Year_2038_problem">2038</a> if there is even a small set of critical machines
that haven't moved on from 32-bit architectures.)</p>

<p>But we're still not okay universally. Try going on an infinite journey
to space and you'll find that counting seconds leads to some
inconsistencies with your local time when you try to synchronize with
Earth. How can the number of seconds after January 1970 be different
in any case? Well, your MacBook Pro has not been adjusted for
... relativity! Gravity bends light and thus the perception of
time. There's a lot more mass, and thus a lot more gravitatonal fields
in neighborhoods away from Earth. The exact details of how this works
is beyond the scope of this blog post.</p>

<p>If the past few paragraphs were incessant and seemingly irrelevant,
they were there to drive home the point that Earth time simply will
not do when we step out of the ghetto to see what's happening. But
astronomy's been around for way longer, and astrophysicists came
forth with a time system adjusted for the relativity effects of the
solar system, called Barycentric Dynamical Time, or <em>TDB</em>. Like our
machines, it counts the seconds after a certain known reference time
point, except that it adjusts for relativity and can become a standard
for astronomical time.</p>

<p>There are many similar time scales like this, but SPICE has chosen to
use TDB as the standard for most of their design. Within the SPICE
API, TDB is the same as <em>Ephemeris Time</em> which is the main system used
to specify time points of astronomical bodies. Even though spacecrafts
have their clocks coordinated with UTC on Earth, you would require
that time in Ephemeris Time to be able to calculate their positions and
velocities using SPICE. <code>SpiceRub::Time</code> is built for this very purpose,
to revolve around a main attribute <code>@et</code> for Ephemeris Time and
provide many methods to convert to and from.</p>

<p>If you'd like to proceed with the examples, you'll need a Leap Second
Kernel file to use <code>SpiceRub::Time</code>. This is a generic kernel, so you
can easily use <code>naif0011.tls</code> in <code>spec/data/kernels</code> of the repository
folder.</p>

<p>So Ephemeris Time is the number of seconds elapsed after <code>Noon, January 1, 2000, TDB</code>. This point in time is also known as the <code>J2000</code>
epoch. We find that out in an instant by using the <code>Time.parse</code>
function which is a wrapper function for SPICE's <code>str2et_c</code> that
converts many formats of strings to <code>Ephemeris Time</code>. You can have a
look at the various string formats supported in its documentation
<a href="https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/str2et_c.html">here</a></p>

<p><code>ruby
 SpiceRub::Time.parse("12:00 Jan 1 2000 TDB")
=&gt; #&lt;SpiceRub::Time:0x0000000325b1f8 @et=0.0&gt;
</code></p>

<p>So as a base case, using the reference epoch gives us 0 seconds as we would expect. Now would also be a good time to find out the discrepancy in <code>UTC</code> as well.</p>

<p><code>ruby
SpiceRub::Time.parse("12:00 Jan 1 2000 UTC")
=&gt; #&lt;SpiceRub::Time:0x000000031c28e0 @et=64.18392728473108&gt;
</code></p>

<p>So right away we know that UTC was 64-ish seconds off from TDB / ET at the time of the reference J2000 epoch. What would the difference be around right now?</p>

<p>```ruby
now = SpiceRub::Time.now
=> #&lt;SpiceRub::Time:0x000000030bf8f8 @et=525173312.1827749></p>

<p>(now - now.to_utc).to_f
=> 68.18277490139008</p>

<p>```</p>

<p>Well, here's a surprise, it's 68.18 now. Before I explain why that is,
here is a brief overview of what the above code does:</p>

<p><code>Time.now</code> is a convenient way to specify your current UTC
timezone. It uses Ruby's core <code>Time.now</code> method so this method is only
good if you're working in UTC or Earth like Timezones. For a similar
purpose, the function <code>Time.from_time</code> let's you create a SpiceRub
Time object from a Ruby Time object.</p>

<p>The <code>+/-</code> operators return a new Time object where the right operand
is added/subtracted to the left operand's <code>@et</code> when it is a float or
integer. If a Time object is supplied , then it does the same with the
right operand's ephemeris time instead. (Note that there really isn't
a significant meaning to having a Time object whose @et is the
difference/sum of two other epochs, however you can increase a certain
epoch or decrease it by a constant offset of seconds)</p>

<p>In our case we used <code>#to_utc</code> to convert from ephemeris time to UTC,
and then the minus operator gave us a Time object that wasn't really
an epoch, but a difference of two epochs, so using <code>#to_f</code> got us
exactly that.</p>

<p>It appears that UTC has changed by 4 seconds since 2000 with respect
to ephemeris time. This is actually the adjustment of "leap seconds"
that gets added to UTC to prevent it from falling too far behind other
time systems. (Humans really like to hack everything, don't they?)</p>

<p>To verify this yourself, if you open up the kernel <code>naif0011.tls</code> in your
text editor and search for <code>DELTET/DELTA_AT</code>, you'll find a list like
representation of the following sort :-</p>

<p>```
DELTET/DELTA_AT        = ( 10,   @1972-JAN-1</p>

<pre><code>                       ..,   ...........
                       32,   @1999-JAN-1
                       33,   @2006-JAN-1
                       34,   @2009-JAN-1
                       35,   @2012-JUL-1
                       36,   @2015-JUL-1 )
</code></pre>

<p>```</p>

<p>Here you can see that just before the year 2000, there were 32 leap
seconds added to UTC, and in 2015 when the last leap second was added,
there were 36. It's an ongoing and indefinite process and so there
really is no way to account for leap second errors far in the future
for leap seconds that are yet to be added. As of now, the next
scheduled addition is in December, 2016.</p>

<p>Coming back to our Time object, let's look at its basic
construction. One tricky task in the API was the option to specify
different epochs of reference in different time scales, like
International Atomic Time. As of now, <code>Time.new</code> requires that you
have kept your word of using the J2000 epoch and allows you to use a
named parameter <code>seconds:</code> for specifying the time scale. The use of
<code>scale</code> as a key was avoided as it sometimes is also used to refer to the
reference epoch used.</p>

<p>```ruby</p>

<p>epochs = [:utc, :tdb, :tai].map
  { |scale| SpiceRub::Time.new(0, seconds: scale) }</p>

<p>=> [#&lt;SpiceRub::Time:0x00000002756fc8 @et=64.18392728466942>,</p>

<pre><code>#&lt;SpiceRub::Time:0x00000002756eb0 @et=0&gt;,
#&lt;SpiceRub::Time:0x00000002756cf8 @et=32.18392727400827&gt;]
</code></pre>

<p>```</p>

<p><code>:tai</code> here refers to International Atomic Time. For a list of more
parameters and their keyword abbreviations, have a look at
<a href="https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/unitim_c.html">this</a> SPICE documentation for the function that the
conversion is wrapped on top of.</p>

<p>But there is also a way to reference other epochs without doing the
manual conversions yourself, you can call the class method <code>Time.at</code>
to perform the same function as the constructor, with the option of a
different reference epoch. The resultant Time object will however have
its internal time referring to J2000.</p>

<p>A more readable way would involve step by step calculations, but that
would consume runtime resources everytime <code>Time.at</code> is called, so I've
basically pre-calculated the ephemeris times of the reference epochs
and subtracted them from the epoch.</p>

<p>```ruby
  case reference.downcase
  when :j2100</p>

<pre><code>new(offset + 3155760000.0, seconds: seconds)
</code></pre>

<p>  when :j2000, :et</p>

<pre><code>new(offset, seconds: seconds)      
</code></pre>

<p>  when :j1950</p>

<pre><code>new(offset - 1577880000.0, seconds: seconds)
</code></pre>

<p>  when :j1900</p>

<pre><code>new(offset - 3155760000.0, seconds: seconds)
</code></pre>

<p>  when :gps</p>

<pre><code>new(offset - 630763148.8159368, seconds: seconds)
</code></pre>

<p>  when :unix</p>

<pre><code>new(offset - 946727958.8160644, seconds: seconds)
</code></pre>

<p>  end
```</p>

<p>To quickly verify the last one with the <code>#to_s</code> method:</p>

<p><code>ruby
SpiceRub::Time.new(-946727958.8160644).to_s
=&gt; "Thu Jan 01 00:00:00 UTC 1970"
</code></p>

<p>It's exactly the UNIX epoch! Let's try out 1 day (86400 seconds) after
this epoch:</p>

<p><code>ruby
SpiceRub::Time.at(86400, :unix).to_s
=&gt; "Thu Jan 01 23:59:59 UTC 1970"
</code></p>

<p>Just a second short of heading into the next day, because we've added
86400 TDB seconds and converted the time into a UTC string.</p>

<p>There are some more functions provided to work in tandem with the
<code>Body</code> class that I'll explain more about in the next blog post, but
this more or less covers the core of <code>SpiceRub:Time</code>. Till then,
thanks for reading.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GSoC 2015: New NMatrix gems for advanced linear algebra features]]></title>
    <link href="http://sciruby.com/blog/2015/08/19/gsoc-2015-nmatrix/"/>
    <updated>2015-08-19T09:57:00+09:00</updated>
    <id>http://sciruby.com/blog/2015/08/19/gsoc-2015-nmatrix</id>
    <content type="html"><![CDATA[<p>My Google Summer of Code project was working on the <a href="https://github.com/SciRuby/nmatrix">NMatrix project</a>, moving
functionality that depends on external libraries from the core <code>nmatrix</code>
gem to optional plugin gems. NMatrix is a Ruby library for linear algebra,
used by many other projects.
In addition to the code that was part of
NMatrix proper, NMatrix previously required the <a href="http://math-atlas.sourceforge.net/">ATLAS library</a>, which
implemented fast versions of common matrix operations like multiplication
and inversion, as well as more advanced operations like eigenvalue
decomposition and Cholesky decomposition.</p>

<p>There were two separate but related motivations for my project. The
first was to simplify the NMatrix installation
process. ATLAS can be difficult to install, so the installation
process for NMatrix was complicated, especially on
OS X, and may have discouraged people from using NMatrix.
The second motivation was that by separating out the ATLAS code from the
main NMatrix code, it would be easier to add new linear algebra backends
which provide similar features. Indeed, I implemented a second backend this
summer.</p>

<p>The end result of my summer's work:</p>

<ul>
<li>The core <code>nmatrix</code> gem does not depend on any external linear matrix
libraries. It provides non-optimized implementations of common matrix
operations.</li>
<li>All code that requires ATLAS has been moved into the new <code>nmatrix-atlas</code>
gem, so that
those who are only interested in the core functionality are not required to
install ATLAS. <code>nmatrix-atlas</code> provides optimized implementations of common matrix
operations, as well as advanced functions not available in <code>nmatrix</code>.
I wrote a blog post describing the setup for <a href="http://wlevine.github.io/2015/06/15/releasing-multiple-gems-with-c-extensions-from-the-same-repository.html">releasing multiple gems from the same repository</a>, which this required.</li>
<li>A new gem <code>nmatrix-lapacke</code>, which provides the same features as
<code>nmatrix-atlas</code>, but instead of depending specifically on the ATLAS
library, requires any generic <a href="https://en.wikipedia.org/wiki/LAPACK">LAPACK</a> and
<a href="https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms">BLAS</a>
implementation. This should be easier to use for many users as they may
already have LAPACK installed (it comes pre-installed with OS X and is
commonly used in Linux systems), but not ATLAS.</li>
<li>The installation procedure is simplified, especially for those installing
just the <code>nmatrix</code> gem. Compare the <a href="https://github.com/SciRuby/nmatrix/wiki/Installation">new installation instructions</a>
to the <a href="https://github.com/SciRuby/nmatrix/wiki/Installation/2ac41c62d35c79468d3d8169be0ccba238c3c921">old ones</a>.</li>
</ul>


<p>The one deviation from my original proposal was that I originally intended to remove
all the ATLAS code and release only the <code>nmatrix-lapacke</code> plugin, so that we
would only have one interface to the advanced linear algebra functions, but I
decided to keep the ATLAS code, since the <code>nmatrix-lapacke</code> code is new and
has not had a chance to be thoroughly tested.</p>

<h3>Usage</h3>

<p>```ruby
require 'nmatrix'</p>

<h1>create a 3-by-3 matrix</h1>

<p>a = NMatrix.new([3,3], [1,2,3, 4,5,6, 7,8,9], dtype: :float64)</p>

<h1>invert it using non-optimized NMatrix-internal implementation</h1>

<p>a.invert!
```</p>

<p>```ruby
require 'nmatrix'
require 'nmatrix/atlas' #or require 'nmatrix/lapacke'</p>

<h1>create a 3-by-3 matrix</h1>

<p>a = NMatrix.new([3,3], [1,2,3, 4,5,6, 7,8,9], dtype: :float64)</p>

<h1>invert it using optimized implementation provided by ATLAS</h1>

<p>a.invert!
```</p>

<p>For advanced functions not provided by the core <code>nmatrix</code> gem, for example
<a href="http://sciruby.com/nmatrix/docs/NMatrix.html#method-i-gesvd"><code>gesvd</code></a>, <code>nmatrix-atlas</code> and <code>nmatrix-lapacke</code>
provide a common interface:</p>

<p><code>ruby
require 'nmatrix'
require 'nmatrix/atlas'
a = NMatrix.new([4,5],[1,0,0,0,2, 0,0,3,0,0, 0,0,0,0,0, 0,4,0,0,0],
dtype: dtype)
u, s, vt = a.gesvd
</code></p>

<p>```ruby</p>

<h1>Identical to the above, except for the require</h1>

<p>require 'nmatrix'
require 'nmatrix/lapacke'
a = NMatrix.new([4,5],[1,0,0,0,2, 0,0,3,0,0, 0,0,0,0,0, 0,4,0,0,0],
dtype: dtype)
u, s, vt = a.gesvd
```</p>

<p>If the developer wants to use an advanced feature, but does not care
whether the user is using <code>nmatrix-atlas</code>
or <code>nmatrix-lapacke</code>, they can <code>require nmatrix/lapack_plugin</code>, which will
require whichever of the two is available, instead of being forced to
choose between the two.</p>

<p>As a fun test of the new gems, I did a very simple benchmark, just
testing how long it took to invert a
1500-by-1500 matrix in place using <code>NMatix#invert!</code>:</p>

<ul>
<li><code>nmatrix</code> (no external libraries): 3.67s</li>
<li><code>nmatrix-atlas</code>: 0.96s</li>
<li><code>nmatrix-lapacke</code> with ATLAS: 0.99s</li>
<li><code>nmatrix-lapacke</code> with OpenBLAS (multithreading enabled): 0.39s</li>
<li><code>nmatrix-lapacke</code> with reference implementations of LAPACK and BLAS: 3.72s</li>
</ul>


<p>This is not supposed to be a thorough or realistic benchmark (performance will
depend on your system, on how you built the libraries, and on the exact
functions that you use), but there
are still a few interesting conclusions we can draw from it:</p>

<ul>
<li>Performance is much better using the two highly optimized libraries
(ATLAS and OpenBLAS) than using either the NMatrix
internal implementation or the reference implementation.</li>
<li>When using ATLAS, performance is similar whether using <code>nmatrix-atlas</code>
and <code>nmatrix-lapacke</code> (this means we could consider deprecating
the <code>nmatix-atlas</code> gem).</li>
</ul>


<p>Overall, my summer has been productive. I implemented everything that I
proposed and feedback from testers so far has been positive.
I plan to stay involved with NMatrix, especially to follow up on any issues
related to my changes.
Although I won't be a student next summer, I would certainly consider
participating in Google Summer of Code in the future as a mentor.
I'd like to
thank my mentor John Woods and the rest of the SciRuby community for support
and feedback throughout the summer.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GnuplotRB and GSoC 2015]]></title>
    <link href="http://sciruby.com/blog/2015/08/18/gnuplotrb-project/"/>
    <updated>2015-08-18T23:26:00+09:00</updated>
    <id>http://sciruby.com/blog/2015/08/18/gnuplotrb-project</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>This summer I've been participating in Google Summer of Code
 with <a href="https://github.com/dilcom/gnuplotrb">GnuplotRB project</a> (plotting tool for Ruby users based on <a href="http://www.gnuplot.info/">Gnuplot</a>)
 for <a href="http://sciruby.com/">SciRuby</a>. GSoC is almost over and I'm releasing v0.3.1 of GnuplotRB as a <a href="https://rubygems.org/gems/gnuplotrb/">gem</a>.
 In this blog post I want to introduce the gem and highlight some of its capabilities.</p>

<h2>Features</h2>

<p>There are several existing plotting tools for Ruby such as Nyaplot, Plotrb, Rubyvis
 and Gnuplot gem. However they are not designed for large datasets and have fewer
 plotting styles and options than Gnuplot. Gnuplot gem was developed long ago and nowadays consists
 mostly of hacks and does not support modern Gnuplot features such as multiplot.</p>

<p>Therefore my goal was to develop new gem for Gnuplot which would allow full use of its
 features in Ruby. I was inspired to build an easy-to-use interface for the most commonly
 used features of Gnuplot and allow users to customize their plots with
 Gnuplot options as easily as possible in Rubyesque way.</p>

<!--more-->


<h3>2D and 3D plots</h3>

<p>The main feature of every plotting tool is its ability to plot graphs. GnuplotRB allows you
 to plot both mathematical formula  and (huge) sets of data. GnuplotRB supports plotting
 2D graphs (<code>GnuplotRB::Plot</code> class)  in Cartesian/parametric/polar coordinates and 3D
 graphs (<code>GnuplotRB::Splot</code> class) &mdash; in Cartesian/cylindrical/spherical coordinates.</p>

<p>There are vast of plotting styles supported by GnuplotRB:</p>

<ul>
<li><code>points</code></li>
<li><code>lines</code></li>
<li><code>histograms</code></li>
<li><code>boxerrorbars</code></li>
<li><code>circles</code></li>
<li><code>boxes</code></li>
<li><code>filledcurves</code></li>
<li><code>vectors</code></li>
<li><code>heatmap</code></li>
<li>etc (full list in <a href="http://www.gnuplot.info/docs_5.0/gnuplot.pdf">gnuplot doc</a> p. 47)</li>
</ul>


<p>Plot examples:</p>

<p><img src="{{ site.url }}/images/gnuplotrb-gsoc2015/plots.jpg" alt="Plot example" style="width: 100%;"/></p>

<p>For code examples please see
 <a href="https://github.com/dilcom/gnuplotrb/blob/master/README.rdoc">the repository README</a>,
 <a href="https://github.com/dilcom/gnuplotrb/blob/master/notebooks/README.rdoc">notebooks</a>
 and <a href="https://github.com/dilcom/gnuplotrb/tree/master/examples">the examples folder</a>.</p>

<h3>Multiplot</h3>

<p><code>GnuplotRB::Multiplot</code> allows users to place several plots on a single layout and output
 them at once (e.g., to a PNG file).
 <a href="http://nbviewer.ipython.org/github/dilcom/gnuplotrb/blob/master/notebooks/multiplot_layout.ipynb">Multiplot notebook</a>.</p>

<p>Here is a multiplot example
 (taken from <a href="http://nbviewer.ipython.org/github/SciRuby/sciruby-notebooks/blob/master/Data%20Analysis/Analyzing%20baby%20names/Use%20Case%20-%20Daru%20for%20analyzing%20baby%20names%20data.ipynb">Sameer's notebook</a>):</p>

<p><img src="{{ site.url }}/images/gnuplotrb-gsoc2015/multiplot.jpg" alt="Multiplot example" style="width: 80%; align: middle;"/></p>

<h3>Animated plots</h3>

<p>GnuplotRB may output any plot to gif file but <code>GnuplotRB::Animation</code> allows
 to make this gif animated. It takes several <code>Plot</code> or <code>Splot</code> objects just as
 multiplot does and outputs them one-by-one as frames of gif animation.
 <a href="http://nbviewer.ipython.org/github/dilcom/gnuplotrb/blob/master/notebooks/animated_plots.ipynb">Animation notebook</a>.</p>

<p><img src="{{ site.url }}/images/gnuplotrb-gsoc2015/trajectory.gif" alt="Trajectory example" style="width: 80%; align: middle;"/></p>

<h3>Fit</h3>

<p>Although the main GnuplotRB's purpose is to provide you with swift, robust and
 easy-to-use plotting tool, it also offers a <code>Fit</code> module that contains several
 methods for fitting given data with a function. See examples in <a href="http://nbviewer.ipython.org/github/dilcom/gnuplotrb/blob/master/notebooks/fitting_data.ipynb">Fit notebook</a>.</p>

<h3>Integration with other SciRuby tools</h3>

<h4>Embedding plots into iRuby notebooks</h4>

<p>GnuplotRB plots may be embedded into iRuby notebooks as JPEG/PNG/SVG
 images, as ASCII art or GIF animations (<code>Animation</code> class). This functionality
 explained in a special <a href="http://nbviewer.ipython.org/github/dilcom/gnuplotrb/blob/master/notebooks/basic_usage.ipynb">iRuby notebook</a>.</p>

<h4>Using data from Daru containers</h4>

<p>To link GnuplotRB with other SciRuby tools I implemented plot
 creation from data given in Daru containers (<code>Daru::Dataframe</code> and <code>Daru::Vector</code>).
 One can use <code>daru</code> gem in order to work with statistical SciRuby gems
 and plotting with GnuplotRB. Notebooks with examples: <a href="http://nbviewer.ipython.org/github/dilcom/gnuplotrb/blob/master/notebooks/plotting_from_daru.ipynb">1</a>, <a href="http://nbviewer.ipython.org/github/dilcom/gnuplotrb/blob/master/notebooks/time_series_from_daru.ipynb">2</a>.</p>

<h3>Possible datasources for plots</h3>

<p>You can pass to Plot (or Splot or Dataset) constructor data in the following forms:</p>

<ul>
<li>String containing mathematical formula (e.g., <code>'sin(x)'</code>)</li>
<li>String containing name of file with data (e.g., <code>'points.data'</code>)</li>
<li>Some Ruby object responding to <code>#to_gnuplot_points</code>

<ul>
<li><code>Array</code></li>
<li><code>Daru::Dataframe</code></li>
<li><code>Daru::Vector</code></li>
</ul>
</li>
</ul>


<p>See examples in <a href="https://github.com/dilcom/gnuplotrb/blob/master/notebooks/README.rdoc#possible-datasources">notebooks</a>.</p>

<h2>Links</h2>

<ul>
<li><a href="https://github.com/dilcom/gnuplotrb/">Project repository</a></li>
<li><a href="https://rubygems.org/gems/gnuplotrb/">Gem page on Rubygems</a></li>
<li><a href="http://www.rubydoc.info/gems/gnuplotrb/0.3.1">Gem documentation on Rubydoc</a></li>
<li><a href="http://dilcom.github.io/gnuplotrb/">Blog of the project</a></li>
<li><a href="https://github.com/dilcom/gnuplotrb/tree/master/examples">Examples</a></li>
<li><a href="https://github.com/dilcom/gnuplotrb/blob/master/notebooks/README.rdoc">iRuby notebooks</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Wrappers for SymEngine, a C++ symbolic manipulation library]]></title>
    <link href="http://sciruby.com/blog/2015/08/17/ruby-wrappers-for-symengine/"/>
    <updated>2015-08-17T14:30:00+09:00</updated>
    <id>http://sciruby.com/blog/2015/08/17/ruby-wrappers-for-symengine</id>
    <content type="html"><![CDATA[<p>I am sure you have heard about <a href="http://www.wolframalpha.com/">Wolfram Alpha</a>. Some of you would have used its <a href="http://www.wolframalpha.com/examples/Math.html">Mathematics section</a> at some point of time to cross check your solution to a maths problem. If you haven't, please do. A computer algebra system (CAS) does the same thing. Algebraic computation or symbolic computation are all used interchangeably. A CAS solves problems the same way a human does, but way more quickly and precisely. There is very less chance for an error, that we humans often make.</p>

<h2>Introduction</h2>

<p>My project was to write the Ruby extensions for the library <a href="https://github.com/sympy/symengine">SymEngine</a> and come up with a Ruby-ish interface, after which we can use the features of SymEngine from Ruby.</p>

<p><a href="https://github.com/sympy/symengine">SymEngine</a> is a library for symbolic computation in C++. You may ask, why SymEngine? There are other CASs that I know of. This question was indeed asked. At the beginning, the idea was to use ruby wrappers for <a href="http://www.sagemath.org/">sage</a> (a mathematics software system) which uses <a href="http://pynac.org/">Pynac</a>, an interface to <a href="http://www.ginac.de/">GiNaC</a> (another CAS). As it turns out from the benchmarks, SymEngine is much faster than Pynac. What about directly wrapping GiNaC? SymEngine is also a bit faster than GiNaC.</p>

<p>The motivation for <a href="https://github.com/sympy/symengine">SymEngine</a> itself is to develop it once in C++ and then use it from other languages rather than doing the same thing all over again for each language that it is required in. In particular, a long term goal is to make Sage as well as SymPy use it by default, thus unifying the Python CAS communities. The goal of implementing the Ruby wrappers is to provide a CAS for the Ruby community.</p>

<h3>How will this be useful?</h3>

<p>There are times when we might need a symbolic computation library. Here is an incomplete list of some of the situations:</p>

<ul>
<li>We need to do some algebra to get systems of equations in suitable form for numerical computation.</li>
<li>We need to make substitutions for some variables and donâ€™t want to risk a math error by hand. There might be times when we want to partially simplify an expression by substituting only a few of its variables.</li>
<li>We have a situation where we need to find the optimum number of something to maximise our profits, and the mathematical model devised is just too complicated to solve by hand.</li>
<li>We need to perform non-trivial derivatives or integrals.</li>
<li>We are trying to understand the domain of a new function.</li>
<li>Most root finding algorithms search for a single root, whereas often there are more than one.</li>
<li>We need to solve a linear system or manipulate a symbolic matrix exactly.</li>
<li>We need to manipulate exact expressions and solutions, as opposed to approximate ones using a numerical method.</li>
</ul>


<p>With that said, a symbolic manipulation library is indispensable for scientists and students. Ruby has gained a great deal of popularity over the years, and a symbolic manipulation library gem  like this project in Ruby might prove to be the foundation for a computer algebra system in Ruby. With many efforts like these, Ruby might become the first choice for academicians given how easy it is to code your logic in Ruby.</p>

<h2>How to install the gem?</h2>

<p>To install, please follow the <a href="https://github.com/sympy/symengine/blob/master/symengine/ruby/README.md">compile instructions given in the README</a>. After you are done, I would suggest to test the extensions. To run the test suite execute <code>rspec spec</code> on the command line, from the <code>symengine/ruby</code> dir.</p>

<p>The gem is still in alpha release. Please help us out by reporting any issues in <a href="https://github.com/sympy/symengine/issues">the repo issue tracker</a>.</p>

<h2>What can I do with the gem?</h2>

<p>Currently, the following features are available in the gem:
- Construct expressions out of variables (mathematical).
- Simplify the expressions.
- Carry out arithmetic operations like <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>**</code> with the variables and expressions.
- Extract arguments or variables from an expression.
- Differentiate an expression with respect to another.
- Substitute variables with other expressions.</p>

<p>Features that will soon be ported to the SymEngine gem
- Functions, including trigonometric, hyperbolic and some special functions.
- Matrices, and their operations.
- Basic number-theoretic functions.</p>

<p>I have developed a <a href="https://github.com/sympy/symengine/tree/master/symengine/ruby/notebooks">few IRuby notebooks</a> that demonstrate the use of the new SymEngine module in ruby.</p>

<p>Below is an example taken from the notebooks.</p>

<hr />

<h2>Using the SymEngine Gem</h2>

<p>SymEngine is a module in the extensions, and the classes are a part of it. So first you fire up the interpreter or an IRuby notebook and load the file:
<code>ruby
require 'symengine'
=&gt; true
</code>
Go ahead and try a function:
```ruby
SymEngine.ascii_art
=>   <strong><strong><em>           </em></strong></strong>         _</p>

<pre><code>|   __|_ _ _____|   __|___ ___|_|___ ___
|__   | | |     |   __|   | . | |   | -_|
|_____|_  |_|_|_|_____|_|_|_  |_|_|_|___|
      |___|               |___|          
</code></pre>

<p><code>
or create a variable:
</code>ruby
basic = SymEngine::Basic.new
=> #&lt;SymEngine::Basic:0x00000001e95290>
```
This shows that we have successfully loaded the module.</p>

<h3>SymEngine::Symbol</h3>

<p>Just like there are variables like x, y, and z in a mathematical expression or equation, we have <code>SymEngine::Symbol</code> in SymEngine to represent them. To use a variable, first we need to make a <code>SymEngine::Symbol</code> object with the string we are going to represent the variable with.:
```ruby
puts x = SymEngine::Symbol.new("x")
puts y = SymEngine::Symbol.new("y")
puts z = SymEngine::Symbol.new("z")</p>

<p>x
y
z
<code>
Then we can construct expressions out of them:
</code>ruby
e = (x-y)<em>(x<strong>y/z)
e.to_s
=> "x</strong>y</em>(x - y)/z"
<code>
In SymEngine, every object is an instance of Basic or its subclasses. So, even an instance of `SymEngine::Symbol` is a Basic object.:
</code>ruby
x.class
=> SymEngine::Symbol</p>

<p>x.is_a? SymEngine::Basic
=> true
<code>
Now that we have an expression, we would like to see it's expanded form using `#expand`:
</code>ruby
f = e.expand()
f.to_s
=> "x<strong>(1 + y)/z - x</strong>y<em>y/z"
<code>
Or check if two expressions are same:
</code>ruby
f == - (x**y</em>y/z) + (x<strong>y*x/z)
=> true
<code>
But `e` and `f` are not equal since they are only mathematically equal, not structurally:
</code>ruby
e == f
=> false
<code>
Let us suppose you want to know **what variables/symbols your expression has**. You can do that with the `#free_symbols` method, which returns a set of the symbols that are in the expression.:
</code>ruby
f.free_symbols
=> #&lt;Set: {#&lt;SymEngine::Basic:0x00000001f0ca70>, #&lt;SymEngine::Basic:0x00000001f0ca48>, #&lt;SymEngine::Basic:0x00000001f0ca20>}>
<code>
Let us use `#map` method to see the elements of the `Set`.:
</code>ruby
f.free_symbols.map { |x| x.to_s }
=> ["x", "y", "z"]
<code>
`#args` returns the terms of the expression,:
</code>ruby
f.args.map { |x| x.to_s }
["-x</strong>y*y/z", "x<strong>(1 + y)/z"]
<code>
or if it is a single term it breaks down the elements:
</code>ruby
f.args[0].args.map { |k| k.to_s }
=> ["-1", "x</strong>y", "y", "z**(-1)"]
```</p>

<h3>SymEngine::Integer</h3>

<p>You can make objects of class <code>SymEngine::Integer</code>. It's like regular <code>Integer</code> in ruby kernel, except it can do all the operations a <code>Basic</code> object can &mdash; such as arithmetic operations, etc.:
```ruby
a = SymEngine::Integer.new(12)
b = SymEngine::Integer.new(64)
a**b</p>

<p>=> 1168422057627266461843148138873451659428421700563161428957815831003136
<code>
Additionally, it can support numbers of arbitrarily large length.
</code>ruby
(a<strong>x).to_s
=> "12</strong>x"
```</p>

<h3>SymEngine::Rational</h3>

<p>You can also make objects of class <code>SymEngine::Rational</code> which is the SymEngine counterpart for <code>Rationals</code> in Ruby.:
```ruby
c = Rational('2/3')
d = SymEngine::Rational.new(c)</p>

<p>=> 2/3
<code>
Like any other `Basic` object arithmetic operations can be done on this rational type too.:
</code>ruby
(a-d).to_s
=> "34/3"</p>

<h2>```</h2>

<p>You <strong>need not create</strong> an instance of <code>SymEngine::Integer</code> or <code>SymEngine::Rational</code>, every time you want to use them in an expression that uses many <code>Integer</code>s. Let us say you already have <code>Integer</code>/<code>Rational</code> object. Even then you can use them without having to create a new <code>SymEngine</code> object.:
<code>ruby
k = (1 / (x * y) - x * y + 2) * (c + x * y) # c is a Rational object, not SymEngine::Rational
k.to_s
=&gt; "(2/3 + x*y)*(2 + 1/(x*y) - x*y)"
</code>
As you can see, ruby kernel <code>Integer</code>s and <code>Rational</code>s interoperate seamlessly with the <code>SymEngine</code> objects.
```ruby
k.expand.to_s
=> "7/3 + (2/3)<em>1/(x</em>y) + (4/3)<em>x</em>y - x<strong>2*y</strong>2"</p>

<h2>```</h2>

<h2>What I learned</h2>

<p>In the rest of the post, I would like to summarise my work and what I learned as a participant of <a href="https://www.google-melange.com/gsoc/homepage/google/gsoc2015">Google Summer of Code 2015</a>.</p>

<h2>Pre-midterm Evaluations</h2>

<p>I am a newbie when it comes to Ruby, and it took me a while to setup the gem and configure files for the building of extensions.</p>

<h3>The struggle between shared, static and dynamic libraries</h3>

<p>I faced a lot of problem in the early stages, when I was trying to build the extensions. <a href="https://github.com/certik">Ondrej</a>, my mentor, and <a href="https://github.com/isuruf">Isuru</a>, a fellow GSoC student, helped me a lot. There were many C flags that were being reported as missing. Some flags <code>cmake</code> added by default but <code>extconf.rb</code> didn't, the same one that was required to be added to build it as a shared library. I am still confused about the details, some of which are <a href="http://abinashmeher999.github.io/2015/05/29/Building-the-wrappers/">explored in greater detail in my personal blog</a>. Finally, the library had to be built as a dynamic one. The problem of missing C flags was resolved later by hooking the process to <code>cmake</code> rather than <code>mkmf</code>.</p>

<h3>Load Errors and problems in linking</h3>

<p>Many <a href="http://abinashmeher999.github.io/2015/06/12/The-Load-Error/"><code>LoadError</code>s</a> popped up, but were eventually solved. <a href="https://github.com/dilcom/">Ivan</a> helped a lot in debugging the errors. In the end, it turned out to be a simple file missing in the gemspec, that was not being installed.</p>

<h3>Reconfiguring building</h3>

<p>One of our aims during developing this was to get rid of unessential dependencies. The ones we already had the tools for. Like later the file <code>extconf.rb</code>, that is used to generate Makefile for the extension was removed, because that could also be done by <code>cmake</code>. Flags were added to <code>cmake</code> for building the Ruby extensions, like the flag <code>-DWITH_RUBY=yes</code>. The <code>Makefile</code> then generates the library <code>symengine.so</code> in the directory <code>lib/symengine</code>.Along with <code>extconf.rb</code>, the file <code>extconf.h</code> was also gone. Along these lines, the dependency on <code>rake</code> was also removed, and with that the <code>Rakefile</code>. Any task automation will most probably be done in python. So, the <code>Rake::ExtensionTask</code> was done by <code>cmake</code> and the <code>Rake::GemPackageTask</code> was replaced by the manual method of <code>gem build symengine.gemspec</code> and <code>gem install symengine-0.0.0.gem</code></p>

<h3>Travis setup</h3>

<p>Not many projects have travis-ci setup for multiple languages. Not even the tutorials had clearly mentioned about setting up for multiple languages. But I did know about one of them, which is Shogun, the machine-learning toolbox. I referred to their <code>.travis.yml</code> and setup it up. If something like this wouldn't have worked the plan was to manually install the required version of ruby and then execute the shell commands.</p>

<h3>Making a basic object</h3>

<p>Finally, I was able to successfully build the extensions, link the extensions with the SymEngine library, load the ruby-extension library in the interpreter and successfully instantiate an object of type <code>Basic</code>.</p>

<h3>Inheritance and Symbols</h3>

<p>At this time, the way inheritance works(like the sequence of formation and destruction of objects of a class that had a superclass) with the Ruby C API, was confusing for all of us. I designed an <a href="http://abinashmeher999.github.io/2015/06/26/the-symbol-class/#inheritance-in-ruby-c-api">experiment</a>
to check what was actually happening. That cleared things out, and made the it easier to wrap things from now on. I also wrapped the <code>Symbol</code> class during the course.</p>

<h2>Post-midterm Evaluations</h2>

<h3>Redesign of the C interface</h3>

<p>We had to design an ugly function to wrap vector in C. That led us to redesign the C interface. This approach had no reinterpret casting that was being done earlier. Each data structure had a type that was determined at compile time. For C, it was an opaque structure, while for C++ the opaque structure declared in the shared header file was implemented in the source file that had C++ data types. This <a href="http://abinashmeher999.github.io/2015/07/03/improving-the-c-interface/">blog post</a> explains it further.</p>

<h3>Integer and Rational</h3>

<p>While trying to port the SymEngine classes, <code>Integer</code> and <code>Rational</code>, I had to port many methods in <code>Basic</code> before that. I also replicated the <code>rake</code> tasks in NMatrix, for detection of memory leaks, in form of bash scripts.</p>

<h3>Common enumeration</h3>

<p>Since all objects in the Ruby C API are of the type <code>CBasic</code>, we needed a function that would give us the typename during the runtime for the corresponding objects to be wrapped in ruby, as an object of the correct <code>Class</code> in ruby. Since, this was achieved with <code>enum</code> in C++, the same thing could be done in C too, with all the classes written manually again. But there was no guarantee for this to be consistent, if ever the features required to be wrapped for a new language, and also manually adding the class in all the enum list everytime a new class is added was prone to errors. So, to make this DRY, we automated this by sharing the list of enums. More details for the implementation can be found <a href="http://abinashmeher999.github.io/2015/07/17/common-enumeration-in-c-and-c++/">here</a>.</p>

<h3>Class coercion and interoperability</h3>

<p>To support interoperability with the builtin ruby types, I had to overload the methods in builtin classes earlier(this was not continued). Overriding all the existing binary operations for a ruby class to support SymEngine types, violated the open/closed principle. There was indeed another way, which is <em>'Class Coercion'</em>. It was suggested by <a href="https://github.com/isuruf/">Isuru</a>. After that, SymEngine types could seamlessly interoperate between the ruby types.</p>

<h3>Arithmetic operations</h3>

<p>After this, all the arithmetic operations had been successfully ported. Each <code>Basic</code> object can now perform arithmetic operations with other <code>Basic</code> object(sometimes even ruby objects like <code>Integer</code>). The test file in python, that had all the corresponding test cases was ported to its RSpec counterpart.</p>

<h3>Substitutions</h3>

<p>Recently I completed porting the substitutions module to the extensions(<code>#subs</code>). This feature has added a lot of convenience as now you can substitute a <code>SymEngine::Symbol</code> with some other value in an expression and then <code>#expand</code> to get the result.</p>

<h3>Trigonometric functions</h3>

<p>Currently, I am working on porting the trigonometric functions in SymEngine to the extensions. This would first require to wrap the <code>Function</code> class and then the <code>TrigFunction</code> class in SymEngine.</p>

<h3>Integration of other Ruby gems</h3>

<p>I also have plans to integrate the ruby bindings for <code>gmp</code>, <code>mpfr</code> and <code>mpc</code> libraries, that are already available as gems, with ruby bindings for our library. I have created an issue <a href="https://github.com/sympy/symengine/issues/490">here</a>. Feel free to drop any suggestions.</p>

<hr />

<p>There is much scope for improvement in both the projects. For SymEngine, to support more features like polynomials and series-expansion in the near future, and improving the user interface and the exception handling for the extensions. In short, making the extensions more ruby-ish.</p>

<p>I am grateful to my mentor, <a href="https://github.com/certik">Mr. OndÅ™ej ÄŒertÃ­k</a>, the <a href="http://sciruby.com/">Ruby Science Foundation</a> and the <a href="http://www.sympy.org/en/index.html">SymPy Organisation</a> for the opportunity that they gave me and guiding me through the project, and my team-mates for helping me with the issues. I hope more people will contribute to the project and together we will give a nice symbolic manipulation gem to the Ruby community.</p>
]]></content>
  </entry>
  
</feed>
