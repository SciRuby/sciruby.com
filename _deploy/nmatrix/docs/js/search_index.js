var search_data = {"index":{"searchIndex":["array","autoloadpatch","datatypeerror","n","n","atlas","blas","lapack","blas","factorizelumethods","io","fortranformat","reader","harwellboeing","reader","market","matlab","pointcloud","internal","lapack","lapacke","blas","lapack","yalefunctions","notinvertibleerror","object","shapeerror","storagetypeerror","string","unknown","==()","==()","[]()","[]()","[]()","[]()","[]=()","[]=()","__dense_unary_round__()","__dense_unary_round__()","__list_unary_round__()","__list_unary_round__()","__yale_unary_round__()","__yale_unary_round__()","abs()","abs()","abs_dtype()","abs_dtype()","absolute_sum()","absolute_sum()","alloc_svd_result()","angle_vector()","angle_vector()","asum()","asum()","asum()","binned_sorted_indices()","binned_sorted_indices()","block_diag()","block_diag()","block_diagonal()","block_diagonal()","capacity()","capacity()","cast()","cast()","cast_full()","cast_full()","cblas_asum()","cblas_asum()","cblas_gemm()","cblas_gemm()","cblas_gemv()","cblas_gemv()","cblas_herk()","cblas_herk()","cblas_herk()","cblas_imax()","cblas_imax()","cblas_nrm2()","cblas_nrm2()","cblas_rot()","cblas_rot()","cblas_rotg()","cblas_rotg()","cblas_scal()","cblas_scal()","cblas_syrk()","cblas_syrk()","cblas_syrk()","cblas_trmm()","cblas_trmm()","cblas_trmm()","cblas_trsm()","cblas_trsm()","clapack_getrf()","clapack_getri()","clapack_getri()","clapack_getrs()","clapack_laswp()","clapack_potrf()","clapack_potrf()","clapack_potri()","clapack_potri()","clapack_potrs()","clapack_potrs()","clone_structure()","clone_structure()","col()","col()","cols()","cols()","column()","column()","complex_conjugate()","complex_conjugate()","complex_conjugate!()","complex_conjugate!()","complex_dtype?()","complex_dtype?()","complex_merge()","concat()","concat()","conjugate_transpose()","conjugate_transpose()","const_missing()","corr()","corr()","cov()","cov()","data_pointer()","data_pointer()","dconcat()","dconcat()","default_value()","default_value()","dense?()","dense?()","det()","det()","det_exact()","det_exact()","diag()","diag()","diagonal()","diagonal()","diagonal()","diagonal()","diagonals()","diagonals()","dim()","dim()","dimensions()","dimensions()","dot()","dot()","dtype()","dtype()","dtype_for_floor_or_ceil()","dtype_for_floor_or_ceil()","each()","each()","each_along_dim()","each_along_dim()","each_column()","each_column()","each_layer()","each_layer()","each_ordered_stored_with_indices()","each_ordered_stored_with_indices()","each_rank()","each_rank()","each_row()","each_row()","each_stored_with_index()","each_stored_with_index()","each_stored_with_indices()","each_stored_with_indices()","each_with_indices()","each_with_indices()","effective_dim()","effective_dim()","effective_dimensions()","effective_dimensions()","eye()","eye()","factorize_cholesky()","factorize_cholesky()","factorize_lu()","factorize_lu()","flat_map()","flat_map()","float_dtype?()","float_dtype?()","geev()","gemm()","gemv()","gesdd()","gesdd()","gesdd()","gesdd!()","gesdd!()","gesvd()","gesvd()","gesvd()","gesvd!()","gesvd!()","getrf!()","getrf!()","gplusplus_version()","guess_dtype()","guess_dtype()","hconcat()","hconcat()","header()","hermitian?()","hermitian?()","hessenberg()","hessenberg()","hessenberg!()","hessenberg!()","identity()","identity()","index()","index()","initialize_copy()","initialize_copy()","inject()","inject()","inject_along_dim()","inject_along_dim()","inject_rank()","inject_rank()","integer_dtype?()","integer_dtype?()","internal_dot()","internal_dot()","inverse()","inverse()","invert()","invert()","invert!()","invert!()","is_ref?()","is_ref?()","kron_prod()","kron_prod()","lapack_geev()","lapack_geev()","lapack_gesdd()","lapack_gesdd()","lapack_gesvd()","lapack_gesvd()","lapacke_geev()","lapacke_gesdd()","lapacke_gesvd()","lapacke_getrf()","lapacke_getri()","lapacke_getrs()","lapacke_potrf()","lapacke_potri()","lapacke_potrs()","laswp()","laswp()","laswp()","laswp!()","laswp!()","layer()","layer()","list?()","list?()","load()","load()","load()","load()","load_array()","load_coordinate()","load_mat()","load_matlab_file()","load_matlab_file()","load_pcd_file()","load_pcd_file()","log()","log()","lower_triangle()","lower_triangle()","lower_triangle!()","lower_triangle!()","map()","map()","map!()","map!()","map_stored()","map_stored()","max()","max()","mean()","mean()","meshgrid()","meshgrid()","min()","min()","min_dtype()","min_dtype()","new()","new()","new()","new()","norm2()","norm2()","nrm2()","nrm2()","nrm2()","nvector?()","nvector?()","object_dtype?()","object_dtype?()","offset()","offset()","ones()","ones()","ones_like()","ones_like()","parse()","permutation_array_for()","permutation_matrix_from()","permute_columns()","permute_columns()","permute_columns!()","permute_columns!()","posv()","potrf!()","potrf!()","potrf_lower!()","potrf_lower!()","potrf_upper!()","potrf_upper!()","pow()","pow()","quaternion()","quaternion()","rand()","rand()","random()","random()","rank()","rank()","read()","read()","reduce_along_dim()","reduce_along_dim()","register_lapack_extension()","register_lapack_extension()","repack()","repeat()","repeat()","reshape()","reshape()","reshape!()","reshape!()","rot()","rot!()","rotg()","round()","round()","row()","row()","rows()","rows()","save()","save_array()","save_coordinate()","seq()","seq()","shape()","shape()","shuffle()","shuffle()","shuffle!()","shuffle!()","size()","size()","size()","size()","slice()","slice()","solve()","solve()","sorted_indices()","sorted_indices()","std()","std()","stype()","stype()","sum()","sum()","supershape()","supershape()","symmetric?()","symmetric?()","to_a()","to_a()","to_f()","to_f()","to_flat_a()","to_flat_a()","to_flat_array()","to_flat_array()","to_h()","to_h()","to_hash()","to_hash()","to_nm()","trace()","trace()","translation()","translation()","transpose()","transpose()","tril()","tril()","tril!()","tril!()","triu()","triu()","triu!()","triu!()","underscore()","upcast()","upcast()","upper_triangle()","upper_triangle()","upper_triangle!()","upper_triangle!()","values()","variance()","variance()","vconcat()","vconcat()","vector?()","vector?()","write()","write()","x_rotation()","x_rotation()","y_rotation()","y_rotation()","yale?()","yale?()","yale_a()","yale_d()","yale_ia()","yale_ija()","yale_ja()","yale_ja_at()","yale_ja_d_keys_at()","yale_ja_d_keys_set_at()","yale_ja_d_keys_sorted_set_at()","yale_ja_set_at()","yale_ja_sorted_set_at()","yale_lu()","yale_nd_row()","yale_nd_row_as_array()","yale_nd_row_as_hash()","yale_nd_row_as_set()","yale_nd_row_as_sorted_set()","yale_nd_row_size()","yale_row_as_array()","yale_row_as_hash()","yale_row_as_set()","yale_row_as_sorted_set()","yale_row_keys_intersection()","yale_size()","z_rotation()","z_rotation()","zeroes()","zeroes()","zeros()","zeros()","zeros_like()","zeros_like()","contributing","history","license","readme","binary_format"],"longSearchIndex":["array","autoloadpatch","datatypeerror","n","nmatrix","nmatrix::atlas","nmatrix::atlas::blas","nmatrix::atlas::lapack","nmatrix::blas","nmatrix::factorizelumethods","nmatrix::io","nmatrix::io::fortranformat","nmatrix::io::fortranformat::reader","nmatrix::io::harwellboeing","nmatrix::io::harwellboeing::reader","nmatrix::io::market","nmatrix::io::matlab","nmatrix::io::pointcloud","nmatrix::internal","nmatrix::lapack","nmatrix::lapacke","nmatrix::lapacke::blas","nmatrix::lapacke::lapack","nmatrix::yalefunctions","notinvertibleerror","object","shapeerror","storagetypeerror","string","unknown","nmatrix#==()","nmatrix#==()","nmatrix::[]()","nmatrix#[]()","nmatrix#[]()","nmatrix::[]()","nmatrix#[]=()","nmatrix#[]=()","nmatrix#__dense_unary_round__()","nmatrix#__dense_unary_round__()","nmatrix#__list_unary_round__()","nmatrix#__list_unary_round__()","nmatrix#__yale_unary_round__()","nmatrix#__yale_unary_round__()","nmatrix#abs()","nmatrix#abs()","nmatrix#abs_dtype()","nmatrix#abs_dtype()","nmatrix#absolute_sum()","nmatrix#absolute_sum()","nmatrix::lapack::alloc_svd_result()","nmatrix#angle_vector()","nmatrix#angle_vector()","nmatrix#asum()","nmatrix#asum()","nmatrix::blas::asum()","nmatrix#binned_sorted_indices()","nmatrix#binned_sorted_indices()","nmatrix::block_diag()","nmatrix::block_diag()","nmatrix::block_diagonal()","nmatrix::block_diagonal()","nmatrix#capacity()","nmatrix#capacity()","nmatrix#cast()","nmatrix#cast()","nmatrix#cast_full()","nmatrix#cast_full()","nmatrix::atlas::blas::cblas_asum()","nmatrix::lapacke::blas::cblas_asum()","nmatrix::atlas::blas::cblas_gemm()","nmatrix::lapacke::blas::cblas_gemm()","nmatrix::atlas::blas::cblas_gemv()","nmatrix::lapacke::blas::cblas_gemv()","nmatrix::atlas::blas::cblas_herk()","nmatrix::blas::cblas_herk()","nmatrix::lapacke::blas::cblas_herk()","nmatrix::atlas::blas::cblas_imax()","nmatrix::lapacke::blas::cblas_imax()","nmatrix::atlas::blas::cblas_nrm2()","nmatrix::lapacke::blas::cblas_nrm2()","nmatrix::atlas::blas::cblas_rot()","nmatrix::lapacke::blas::cblas_rot()","nmatrix::atlas::blas::cblas_rotg()","nmatrix::lapacke::blas::cblas_rotg()","nmatrix::atlas::blas::cblas_scal()","nmatrix::lapacke::blas::cblas_scal()","nmatrix::atlas::blas::cblas_syrk()","nmatrix::blas::cblas_syrk()","nmatrix::lapacke::blas::cblas_syrk()","nmatrix::atlas::blas::cblas_trmm()","nmatrix::blas::cblas_trmm()","nmatrix::lapacke::blas::cblas_trmm()","nmatrix::atlas::blas::cblas_trsm()","nmatrix::lapacke::blas::cblas_trsm()","nmatrix::atlas::lapack::clapack_getrf()","nmatrix::atlas::lapack::clapack_getri()","nmatrix::lapack::clapack_getri()","nmatrix::atlas::lapack::clapack_getrs()","nmatrix::atlas::lapack::clapack_laswp()","nmatrix::atlas::lapack::clapack_potrf()","nmatrix::lapack::clapack_potrf()","nmatrix::atlas::lapack::clapack_potri()","nmatrix::lapack::clapack_potri()","nmatrix::atlas::lapack::clapack_potrs()","nmatrix::lapack::clapack_potrs()","nmatrix#clone_structure()","nmatrix#clone_structure()","nmatrix#col()","nmatrix#col()","nmatrix#cols()","nmatrix#cols()","nmatrix#column()","nmatrix#column()","nmatrix#complex_conjugate()","nmatrix#complex_conjugate()","nmatrix#complex_conjugate!()","nmatrix#complex_conjugate!()","nmatrix#complex_dtype?()","nmatrix#complex_dtype?()","nmatrix::io::matlab::complex_merge()","nmatrix#concat()","nmatrix#concat()","nmatrix#conjugate_transpose()","nmatrix#conjugate_transpose()","autoloadpatch#const_missing()","nmatrix#corr()","nmatrix#corr()","nmatrix#cov()","nmatrix#cov()","nmatrix#data_pointer()","nmatrix#data_pointer()","nmatrix#dconcat()","nmatrix#dconcat()","nmatrix#default_value()","nmatrix#default_value()","nmatrix#dense?()","nmatrix#dense?()","nmatrix#det()","nmatrix#det()","nmatrix#det_exact()","nmatrix#det_exact()","nmatrix::diag()","nmatrix::diag()","nmatrix::diagonal()","nmatrix#diagonal()","nmatrix::diagonal()","nmatrix#diagonal()","nmatrix::diagonals()","nmatrix::diagonals()","nmatrix#dim()","nmatrix#dim()","nmatrix#dimensions()","nmatrix#dimensions()","nmatrix#dot()","nmatrix#dot()","nmatrix#dtype()","nmatrix#dtype()","nmatrix#dtype_for_floor_or_ceil()","nmatrix#dtype_for_floor_or_ceil()","nmatrix#each()","nmatrix#each()","nmatrix#each_along_dim()","nmatrix#each_along_dim()","nmatrix#each_column()","nmatrix#each_column()","nmatrix#each_layer()","nmatrix#each_layer()","nmatrix#each_ordered_stored_with_indices()","nmatrix#each_ordered_stored_with_indices()","nmatrix#each_rank()","nmatrix#each_rank()","nmatrix#each_row()","nmatrix#each_row()","nmatrix#each_stored_with_index()","nmatrix#each_stored_with_index()","nmatrix#each_stored_with_indices()","nmatrix#each_stored_with_indices()","nmatrix#each_with_indices()","nmatrix#each_with_indices()","nmatrix#effective_dim()","nmatrix#effective_dim()","nmatrix#effective_dimensions()","nmatrix#effective_dimensions()","nmatrix::eye()","nmatrix::eye()","nmatrix#factorize_cholesky()","nmatrix#factorize_cholesky()","nmatrix#factorize_lu()","nmatrix#factorize_lu()","nmatrix#flat_map()","nmatrix#flat_map()","nmatrix#float_dtype?()","nmatrix#float_dtype?()","nmatrix::lapack::geev()","nmatrix::blas::gemm()","nmatrix::blas::gemv()","nmatrix#gesdd()","nmatrix#gesdd()","nmatrix::lapack::gesdd()","nmatrix#gesdd!()","nmatrix#gesdd!()","nmatrix#gesvd()","nmatrix#gesvd()","nmatrix::lapack::gesvd()","nmatrix#gesvd!()","nmatrix#gesvd!()","nmatrix#getrf!()","nmatrix#getrf!()","object#gplusplus_version()","nmatrix::guess_dtype()","nmatrix::guess_dtype()","nmatrix#hconcat()","nmatrix#hconcat()","nmatrix::io::harwellboeing::reader#header()","nmatrix#hermitian?()","nmatrix#hermitian?()","nmatrix#hessenberg()","nmatrix#hessenberg()","nmatrix#hessenberg!()","nmatrix#hessenberg!()","nmatrix::identity()","nmatrix::identity()","nmatrix#index()","nmatrix#index()","nmatrix#initialize_copy()","nmatrix#initialize_copy()","nmatrix#inject()","nmatrix#inject()","nmatrix#inject_along_dim()","nmatrix#inject_along_dim()","nmatrix#inject_rank()","nmatrix#inject_rank()","nmatrix#integer_dtype?()","nmatrix#integer_dtype?()","nmatrix#internal_dot()","nmatrix#internal_dot()","nmatrix#inverse()","nmatrix#inverse()","nmatrix#invert()","nmatrix#invert()","nmatrix#invert!()","nmatrix#invert!()","nmatrix#is_ref?()","nmatrix#is_ref?()","nmatrix#kron_prod()","nmatrix#kron_prod()","nmatrix::atlas::lapack::lapack_geev()","nmatrix::lapack::lapack_geev()","nmatrix::atlas::lapack::lapack_gesdd()","nmatrix::lapack::lapack_gesdd()","nmatrix::atlas::lapack::lapack_gesvd()","nmatrix::lapack::lapack_gesvd()","nmatrix::lapacke::lapack::lapacke_geev()","nmatrix::lapacke::lapack::lapacke_gesdd()","nmatrix::lapacke::lapack::lapacke_gesvd()","nmatrix::lapacke::lapack::lapacke_getrf()","nmatrix::lapacke::lapack::lapacke_getri()","nmatrix::lapacke::lapack::lapacke_getrs()","nmatrix::lapacke::lapack::lapacke_potrf()","nmatrix::lapacke::lapack::lapacke_potri()","nmatrix::lapacke::lapack::lapacke_potrs()","nmatrix#laswp()","nmatrix#laswp()","nmatrix::lapack::laswp()","nmatrix#laswp!()","nmatrix#laswp!()","nmatrix#layer()","nmatrix#layer()","nmatrix#list?()","nmatrix#list?()","nmatrix::io::harwellboeing::load()","nmatrix::io::market::load()","nmatrix::io::matlab::load()","nmatrix::io::pointcloud::load()","nmatrix::io::market::load_array()","nmatrix::io::market::load_coordinate()","nmatrix::io::matlab::load_mat()","nmatrix::load_matlab_file()","nmatrix::load_matlab_file()","nmatrix::load_pcd_file()","nmatrix::load_pcd_file()","nmatrix#log()","nmatrix#log()","nmatrix#lower_triangle()","nmatrix#lower_triangle()","nmatrix#lower_triangle!()","nmatrix#lower_triangle!()","nmatrix#map()","nmatrix#map()","nmatrix#map!()","nmatrix#map!()","nmatrix#map_stored()","nmatrix#map_stored()","nmatrix#max()","nmatrix#max()","nmatrix#mean()","nmatrix#mean()","nmatrix::meshgrid()","nmatrix::meshgrid()","nmatrix#min()","nmatrix#min()","nmatrix::min_dtype()","nmatrix::min_dtype()","nmatrix::new()","nmatrix::new()","nmatrix::io::fortranformat::reader::new()","nmatrix::io::harwellboeing::reader::new()","nmatrix#norm2()","nmatrix#norm2()","nmatrix#nrm2()","nmatrix#nrm2()","nmatrix::blas::nrm2()","nmatrix#nvector?()","nmatrix#nvector?()","nmatrix#object_dtype?()","nmatrix#object_dtype?()","nmatrix#offset()","nmatrix#offset()","nmatrix::ones()","nmatrix::ones()","nmatrix::ones_like()","nmatrix::ones_like()","nmatrix::io::fortranformat::reader#parse()","nmatrix::factorizelumethods::permutation_array_for()","nmatrix::factorizelumethods::permutation_matrix_from()","nmatrix#permute_columns()","nmatrix#permute_columns()","nmatrix#permute_columns!()","nmatrix#permute_columns!()","nmatrix::lapack::posv()","nmatrix#potrf!()","nmatrix#potrf!()","nmatrix#potrf_lower!()","nmatrix#potrf_lower!()","nmatrix#potrf_upper!()","nmatrix#potrf_upper!()","nmatrix#pow()","nmatrix#pow()","nmatrix#quaternion()","nmatrix#quaternion()","nmatrix::rand()","nmatrix::rand()","nmatrix::random()","nmatrix::random()","nmatrix#rank()","nmatrix#rank()","nmatrix::read()","nmatrix::read()","nmatrix#reduce_along_dim()","nmatrix#reduce_along_dim()","nmatrix::register_lapack_extension()","nmatrix::register_lapack_extension()","nmatrix::io::matlab::repack()","nmatrix#repeat()","nmatrix#repeat()","nmatrix#reshape()","nmatrix#reshape()","nmatrix#reshape!()","nmatrix#reshape!()","nmatrix::blas::rot()","nmatrix::blas::rot!()","nmatrix::blas::rotg()","nmatrix#round()","nmatrix#round()","nmatrix#row()","nmatrix#row()","nmatrix#rows()","nmatrix#rows()","nmatrix::io::market::save()","nmatrix::io::market::save_array()","nmatrix::io::market::save_coordinate()","nmatrix::seq()","nmatrix::seq()","nmatrix#shape()","nmatrix#shape()","nmatrix#shuffle()","nmatrix#shuffle()","nmatrix#shuffle!()","nmatrix#shuffle!()","nmatrix::size()","nmatrix#size()","nmatrix::size()","nmatrix#size()","nmatrix#slice()","nmatrix#slice()","nmatrix#solve()","nmatrix#solve()","nmatrix#sorted_indices()","nmatrix#sorted_indices()","nmatrix#std()","nmatrix#std()","nmatrix#stype()","nmatrix#stype()","nmatrix#sum()","nmatrix#sum()","nmatrix#supershape()","nmatrix#supershape()","nmatrix#symmetric?()","nmatrix#symmetric?()","nmatrix#to_a()","nmatrix#to_a()","nmatrix#to_f()","nmatrix#to_f()","nmatrix#to_flat_a()","nmatrix#to_flat_a()","nmatrix#to_flat_array()","nmatrix#to_flat_array()","nmatrix#to_h()","nmatrix#to_h()","nmatrix#to_hash()","nmatrix#to_hash()","array#to_nm()","nmatrix#trace()","nmatrix#trace()","nmatrix::translation()","nmatrix::translation()","nmatrix#transpose()","nmatrix#transpose()","nmatrix#tril()","nmatrix#tril()","nmatrix#tril!()","nmatrix#tril!()","nmatrix#triu()","nmatrix#triu()","nmatrix#triu!()","nmatrix#triu!()","string#underscore()","nmatrix::upcast()","nmatrix::upcast()","nmatrix#upper_triangle()","nmatrix#upper_triangle()","nmatrix#upper_triangle!()","nmatrix#upper_triangle!()","nmatrix::io::harwellboeing::reader#values()","nmatrix#variance()","nmatrix#variance()","nmatrix#vconcat()","nmatrix#vconcat()","nmatrix#vector?()","nmatrix#vector?()","nmatrix#write()","nmatrix#write()","nmatrix::x_rotation()","nmatrix::x_rotation()","nmatrix::y_rotation()","nmatrix::y_rotation()","nmatrix#yale?()","nmatrix#yale?()","nmatrix::yalefunctions#yale_a()","nmatrix::yalefunctions#yale_d()","nmatrix::yalefunctions#yale_ia()","nmatrix::yalefunctions#yale_ija()","nmatrix::yalefunctions#yale_ja()","nmatrix::yalefunctions#yale_ja_at()","nmatrix::yalefunctions#yale_ja_d_keys_at()","nmatrix::yalefunctions#yale_ja_d_keys_set_at()","nmatrix::yalefunctions#yale_ja_d_keys_sorted_set_at()","nmatrix::yalefunctions#yale_ja_set_at()","nmatrix::yalefunctions#yale_ja_sorted_set_at()","nmatrix::yalefunctions#yale_lu()","nmatrix::yalefunctions#yale_nd_row()","nmatrix::yalefunctions#yale_nd_row_as_array()","nmatrix::yalefunctions#yale_nd_row_as_hash()","nmatrix::yalefunctions#yale_nd_row_as_set()","nmatrix::yalefunctions#yale_nd_row_as_sorted_set()","nmatrix::yalefunctions#yale_nd_row_size()","nmatrix::yalefunctions#yale_row_as_array()","nmatrix::yalefunctions#yale_row_as_hash()","nmatrix::yalefunctions#yale_row_as_set()","nmatrix::yalefunctions#yale_row_as_sorted_set()","nmatrix::yalefunctions#yale_row_keys_intersection()","nmatrix::yalefunctions#yale_size()","nmatrix::z_rotation()","nmatrix::z_rotation()","nmatrix::zeroes()","nmatrix::zeroes()","nmatrix::zeros()","nmatrix::zeros()","nmatrix::zeros_like()","nmatrix::zeros_like()","","","","",""],"info":[["Array","","Array.html","","<p>Classes and Modules #\n"],["AutoloadPatch","","AutoloadPatch.html","","<p>Since `autoload` will most likely be deprecated (due to multi-threading\nconcerns), we&#39;ll use `const_missing`. …\n"],["DataTypeError","","DataTypeError.html","","<p>Exception raised when there&#39;s a problem with data.\n"],["N","","N.html","","<p>NMatrix is a matrix class that supports both multidimensional arrays\n(`:dense` stype) and sparse storage …\n"],["NMatrix","","NMatrix.html","","<p>NMatrix is a matrix class that supports both multidimensional arrays\n(`:dense` stype) and sparse storage …\n"],["NMatrix::ATLAS","","NMatrix/ATLAS.html","",""],["NMatrix::ATLAS::BLAS","","NMatrix/ATLAS/BLAS.html","",""],["NMatrix::ATLAS::LAPACK","","NMatrix/ATLAS/LAPACK.html","",""],["NMatrix::BLAS","","NMatrix/BLAS.html","",""],["NMatrix::FactorizeLUMethods","","NMatrix/FactorizeLUMethods.html","","<p>Methods for generating permutation matrix from LU factorization results.\n"],["NMatrix::IO","","NMatrix/IO.html","","<p>Read and write extensions for NMatrix.\n"],["NMatrix::IO::FortranFormat","","NMatrix/IO/FortranFormat.html","",""],["NMatrix::IO::FortranFormat::Reader","","NMatrix/IO/FortranFormat/Reader.html","","<p>Class for reading strings in FORTRAN format for specifying attributes of\nnumerical data in a file. Supports …\n"],["NMatrix::IO::HarwellBoeing","","NMatrix/IO/HarwellBoeing.html","",""],["NMatrix::IO::HarwellBoeing::Reader","","NMatrix/IO/HarwellBoeing/Reader.html","",""],["NMatrix::IO::Market","","NMatrix/IO/Market.html","","<p>Matrix Market is a repository of test data for use in studies of algorithms\nfor numerical linear algebra. …\n"],["NMatrix::IO::Matlab","","NMatrix/IO/Matlab.html","","<p>Reader (and eventually writer) of Matlab .mat files.\n<p>The .mat file format is documented in the following …\n"],["NMatrix::IO::PointCloud","","NMatrix/IO/PointCloud.html","","<p>Reader for Point Cloud Data (PCD) file format.\n<p>The documentation of this format can be found in:\n<p>pointclouds.org/documentation/tutorials/pcd_file_format.php …\n"],["NMatrix::Internal","","NMatrix/Internal.html","",""],["NMatrix::LAPACK","","NMatrix/LAPACK.html","",""],["NMatrix::LAPACKE","","NMatrix/LAPACKE.html","",""],["NMatrix::LAPACKE::BLAS","","NMatrix/LAPACKE/BLAS.html","",""],["NMatrix::LAPACKE::LAPACK","","NMatrix/LAPACKE/LAPACK.html","",""],["NMatrix::YaleFunctions","","NMatrix/YaleFunctions.html","","<p>This module stores methods that are useful for debugging Yale matrices,\ni.e. the ones with <code>:yale</code> stype. …\n"],["NotInvertibleError","","NotInvertibleError.html","","<p>Exception raise when an inverse is requested but the matrix is not\ninvertible.\n"],["Object","","Object.html","",""],["ShapeError","","ShapeError.html","","<p>Exception raise when the matrix shape is not appropriate for a given\noperation.\n"],["StorageTypeError","","StorageTypeError.html","","<p>Exception raised when something goes wrong with the storage of a matrix.\n"],["String","","String.html","",""],["unknown","","unknown.html","",""],["==","NMatrix","NMatrix.html#method-i-3D-3D","(p1)","<p>Equality operator. Returns a single true or false value indicating whether\nthe matrices are equivalent. …\n"],["==","NMatrix","NMatrix.html#method-i-3D-3D","(p1)","<p>Equality operator. Returns a single true or false value indicating whether\nthe matrices are equivalent. …\n"],["[]","NMatrix","NMatrix.html#method-c-5B-5D","(*params)","<p>The default value for <code>dtype</code> is guessed from the first\nparameter. For example:\n\n<pre>NMatrix[1.0, 2.0].dtype ...</pre>\n"],["[]","NMatrix","NMatrix.html#method-i-5B-5D","(*args)","<p>Access the contents of an NMatrix at given coordinates by reference.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">n</span>[<span class=\"ruby-value\">3</span>,<span class=\"ruby-value\">3</span>]  <span class=\"ruby-comment\"># =&gt; 5.0</span>\n<span class=\"ruby-identifier\">n</span>[<span class=\"ruby-value\">0</span><span class=\"ruby-operator\">..</span><span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">0</span><span class=\"ruby-operator\">..</span><span class=\"ruby-value\">1</span>] <span class=\"ruby-comment\">#=&gt; ...</span>\n</pre>\n"],["[]","NMatrix","NMatrix.html#method-i-5B-5D","(*args)","<p>Access the contents of an NMatrix at given coordinates by reference.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">n</span>[<span class=\"ruby-value\">3</span>,<span class=\"ruby-value\">3</span>]  <span class=\"ruby-comment\"># =&gt; 5.0</span>\n<span class=\"ruby-identifier\">n</span>[<span class=\"ruby-value\">0</span><span class=\"ruby-operator\">..</span><span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">0</span><span class=\"ruby-operator\">..</span><span class=\"ruby-value\">1</span>] <span class=\"ruby-comment\">#=&gt; ...</span>\n</pre>\n"],["[]","NMatrix","NMatrix.html#method-c-5B-5D","(*params)","<p>The default value for <code>dtype</code> is guessed from the first\nparameter. For example:\n\n<pre>NMatrix[1.0, 2.0].dtype ...</pre>\n"],["[]=","NMatrix","NMatrix.html#method-i-5B-5D-3D","(*args)","<p>Modify the contents of an NMatrix in the given cell\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">n</span>[<span class=\"ruby-value\">3</span>,<span class=\"ruby-value\">3</span>] = <span class=\"ruby-value\">5.0</span>\n</pre>\n<p>Also returns the new contents, so you …\n"],["[]=","NMatrix","NMatrix.html#method-i-5B-5D-3D","(*args)","<p>Modify the contents of an NMatrix in the given cell\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">n</span>[<span class=\"ruby-value\">3</span>,<span class=\"ruby-value\">3</span>] = <span class=\"ruby-value\">5.0</span>\n</pre>\n<p>Also returns the new contents, so you …\n"],["__dense_unary_round__","NMatrix","NMatrix.html#method-i-__dense_unary_round__","(precision)",""],["__dense_unary_round__","NMatrix","NMatrix.html#method-i-__dense_unary_round__","(precision)",""],["__list_unary_round__","NMatrix","NMatrix.html#method-i-__list_unary_round__","(precision)","<p>These are for rounding each value of a matrix. Takes an optional argument\n"],["__list_unary_round__","NMatrix","NMatrix.html#method-i-__list_unary_round__","(precision)","<p>These are for rounding each value of a matrix. Takes an optional argument\n"],["__yale_unary_round__","NMatrix","NMatrix.html#method-i-__yale_unary_round__","(precision)",""],["__yale_unary_round__","NMatrix","NMatrix.html#method-i-__yale_unary_round__","(precision)",""],["abs","NMatrix","NMatrix.html#method-i-abs","()","<p>Maps all values in a matrix to their absolute values.\n"],["abs","NMatrix","NMatrix.html#method-i-abs","()","<p>Maps all values in a matrix to their absolute values.\n"],["abs_dtype","NMatrix","NMatrix.html#method-i-abs_dtype","()","<p>Returns the dtype of the result of a call to #abs. In most cases, this is\nthe same as dtype; it should …\n"],["abs_dtype","NMatrix","NMatrix.html#method-i-abs_dtype","()","<p>Returns the dtype of the result of a call to #abs. In most cases, this is\nthe same as dtype; it should …\n"],["absolute_sum","NMatrix","NMatrix.html#method-i-absolute_sum","(incx=1, n=nil)",""],["absolute_sum","NMatrix","NMatrix.html#method-i-absolute_sum","(incx=1, n=nil)",""],["alloc_svd_result","NMatrix::LAPACK","NMatrix/LAPACK.html#method-c-alloc_svd_result","(matrix)",""],["angle_vector","NMatrix","NMatrix.html#method-i-angle_vector","()","<p>Find the angle vector for a quaternion. Assumes the quaternion has unit\nlength.\n<p>Source:\nwww.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle\n…\n"],["angle_vector","NMatrix","NMatrix.html#method-i-angle_vector","()","<p>Find the angle vector for a quaternion. Assumes the quaternion has unit\nlength.\n<p>Source:\nwww.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle\n…\n"],["asum","NMatrix","NMatrix.html#method-i-asum","(incx=1, n=nil)","<p>Arguments\n\n<pre>- +incx+ -&gt; the skip size (defaults to 1, no skip)\n- +n+ -&gt; the number of elements to include</pre>\n"],["asum","NMatrix","NMatrix.html#method-i-asum","(incx=1, n=nil)","<p>Arguments\n\n<pre>- +incx+ -&gt; the skip size (defaults to 1, no skip)\n- +n+ -&gt; the number of elements to include</pre>\n"],["asum","NMatrix::BLAS","NMatrix/BLAS.html#method-c-asum","(x, incx = 1, n = nil)","<p>Calculate the sum of absolute values of the entries of a vector\n<code>x</code> of size <code>n</code>\n<p><strong>Arguments</strong> :\n<p><code>x</code> -&gt; an NMatrix …\n"],["binned_sorted_indices","NMatrix","NMatrix.html#method-i-binned_sorted_indices","()","<p>Returns an array of arrays of indices ordered by value sorted. Functions\nbasically like <code>sorted_indices</code> …\n"],["binned_sorted_indices","NMatrix","NMatrix.html#method-i-binned_sorted_indices","()","<p>Returns an array of arrays of indices ordered by value sorted. Functions\nbasically like <code>sorted_indices</code> …\n"],["block_diag","NMatrix","NMatrix.html#method-c-block_diag","(*params)",""],["block_diag","NMatrix","NMatrix.html#method-c-block_diag","(*params)",""],["block_diagonal","NMatrix","NMatrix.html#method-c-block_diagonal","(*params)","<p>Generate a block-diagonal NMatrix from the supplied 2D square matrices.\n<p><strong>Arguments</strong>\n<p>+*params+ -&gt; An array …\n"],["block_diagonal","NMatrix","NMatrix.html#method-c-block_diagonal","(*params)","<p>Generate a block-diagonal NMatrix from the supplied 2D square matrices.\n<p><strong>Arguments</strong>\n<p>+*params+ -&gt; An array …\n"],["capacity","NMatrix","NMatrix.html#method-i-capacity","()","<p>Find the capacity of an NMatrix. The capacity only differs from the size\nfor Yale matrices, which occasionally …\n"],["capacity","NMatrix","NMatrix.html#method-i-capacity","()","<p>Find the capacity of an NMatrix. The capacity only differs from the size\nfor Yale matrices, which occasionally …\n"],["cast","NMatrix","NMatrix.html#method-i-cast","(*params)","<p>This is a user-friendly helper for calling #cast_full. The easiest way to\ncall this function is using …\n"],["cast","NMatrix","NMatrix.html#method-i-cast","(*params)","<p>This is a user-friendly helper for calling #cast_full. The easiest way to\ncall this function is using …\n"],["cast_full","NMatrix","NMatrix.html#method-i-cast_full","(p1, p2, p3)","<p>Copy constructor for changing dtypes and stypes.\n"],["cast_full","NMatrix","NMatrix.html#method-i-cast_full","(p1, p2, p3)","<p>Copy constructor for changing dtypes and stypes.\n"],["cblas_asum","NMatrix::ATLAS::BLAS","NMatrix/ATLAS/BLAS.html#method-c-cblas_asum","(p1, p2, p3)","<p>Call any of the cblas_xasum functions as directly as possible.\n<p>xASUM is a BLAS level 1 routine which calculates …\n"],["cblas_asum","NMatrix::LAPACKE::BLAS","NMatrix/LAPACKE/BLAS.html#method-c-cblas_asum","(p1, p2, p3)","<p>Call any of the cblas_xasum functions as directly as possible.\n<p>xASUM is a BLAS level 1 routine which calculates …\n"],["cblas_gemm","NMatrix::ATLAS::BLAS","NMatrix/ATLAS/BLAS.html#method-c-cblas_gemm","(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14)","<p>Call any of the cblas_xgemm functions as directly as possible.\n<p>The cblas_xgemm functions (dgemm, sgemm, …\n"],["cblas_gemm","NMatrix::LAPACKE::BLAS","NMatrix/LAPACKE/BLAS.html#method-c-cblas_gemm","(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14)","<p>Call any of the cblas_xgemm functions as directly as possible.\n<p>The cblas_xgemm functions (dgemm, sgemm, …\n"],["cblas_gemv","NMatrix::ATLAS::BLAS","NMatrix/ATLAS/BLAS.html#method-c-cblas_gemv","(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11)","<p>Call any of the cblas_xgemv functions as directly as possible.\n<p>The cblas_xgemv functions (dgemv, sgemv, …\n"],["cblas_gemv","NMatrix::LAPACKE::BLAS","NMatrix/LAPACKE/BLAS.html#method-c-cblas_gemv","(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11)","<p>Call any of the cblas_xgemv functions as directly as possible.\n<p>The cblas_xgemv functions (dgemv, sgemv, …\n"],["cblas_herk","NMatrix::ATLAS::BLAS","NMatrix/ATLAS/BLAS.html#method-c-cblas_herk","(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11)",""],["cblas_herk","NMatrix::BLAS","NMatrix/BLAS.html#method-c-cblas_herk","(order, uplo, trans, n, k, alpha, a, lda, beta, c, ldc)",""],["cblas_herk","NMatrix::LAPACKE::BLAS","NMatrix/LAPACKE/BLAS.html#method-c-cblas_herk","(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11)",""],["cblas_imax","NMatrix::ATLAS::BLAS","NMatrix/ATLAS/BLAS.html#method-c-cblas_imax","(p1, p2, p3)","<p>BLAS level 1 routine.\n<p>Return the index of the largest element of <code>vector</code>.\n<p><code>n</code> -&gt; Vector&#39;s size. Generally …\n"],["cblas_imax","NMatrix::LAPACKE::BLAS","NMatrix/LAPACKE/BLAS.html#method-c-cblas_imax","(p1, p2, p3)","<p>BLAS level 1 routine.\n<p>Return the index of the largest element of <code>vector</code>.\n<p><code>n</code> -&gt; Vector&#39;s size. Generally …\n"],["cblas_nrm2","NMatrix::ATLAS::BLAS","NMatrix/ATLAS/BLAS.html#method-c-cblas_nrm2","(p1, p2, p3)","<p>Call any of the cblas_xnrm2 functions as directly as possible.\n<p>xNRM2 is a BLAS level 1 routine which calculates …\n"],["cblas_nrm2","NMatrix::LAPACKE::BLAS","NMatrix/LAPACKE/BLAS.html#method-c-cblas_nrm2","(p1, p2, p3)","<p>Call any of the cblas_xnrm2 functions as directly as possible.\n<p>xNRM2 is a BLAS level 1 routine which calculates …\n"],["cblas_rot","NMatrix::ATLAS::BLAS","NMatrix/ATLAS/BLAS.html#method-c-cblas_rot","(p1, p2, p3, p4, p5, p6, p7)","<p>Call any of the cblas_xrot functions as directly as possible.\n<p>xROT is a BLAS level 1 routine (taking two …\n"],["cblas_rot","NMatrix::LAPACKE::BLAS","NMatrix/LAPACKE/BLAS.html#method-c-cblas_rot","(p1, p2, p3, p4, p5, p6, p7)","<p>Call any of the cblas_xrot functions as directly as possible.\n<p>xROT is a BLAS level 1 routine (taking two …\n"],["cblas_rotg","NMatrix::ATLAS::BLAS","NMatrix/ATLAS/BLAS.html#method-c-cblas_rotg","(p1)","<p>Call any of the cblas_xrotg functions as directly as possible.\n<p>xROTG computes the elements of a Givens …\n"],["cblas_rotg","NMatrix::LAPACKE::BLAS","NMatrix/LAPACKE/BLAS.html#method-c-cblas_rotg","(p1)","<p>Call any of the cblas_xrotg functions as directly as possible.\n<p>xROTG computes the elements of a Givens …\n"],["cblas_scal","NMatrix::ATLAS::BLAS","NMatrix/ATLAS/BLAS.html#method-c-cblas_scal","(p1, p2, p3, p4)","<p>BLAS level 1 function <code>scal</code>. Works with all dtypes.\n<p>Scale <code>vector</code> in-place by <code>alpha</code> and also return\nit. …\n"],["cblas_scal","NMatrix::LAPACKE::BLAS","NMatrix/LAPACKE/BLAS.html#method-c-cblas_scal","(p1, p2, p3, p4)","<p>BLAS level 1 function <code>scal</code>. Works with all dtypes.\n<p>Scale <code>vector</code> in-place by <code>alpha</code> and also return\nit. …\n"],["cblas_syrk","NMatrix::ATLAS::BLAS","NMatrix/ATLAS/BLAS.html#method-c-cblas_syrk","(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11)",""],["cblas_syrk","NMatrix::BLAS","NMatrix/BLAS.html#method-c-cblas_syrk","(order, uplo, trans, n, k, alpha, a, lda, beta, c, ldc)",""],["cblas_syrk","NMatrix::LAPACKE::BLAS","NMatrix/LAPACKE/BLAS.html#method-c-cblas_syrk","(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11)",""],["cblas_trmm","NMatrix::ATLAS::BLAS","NMatrix/ATLAS/BLAS.html#method-c-cblas_trmm","(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12)",""],["cblas_trmm","NMatrix::BLAS","NMatrix/BLAS.html#method-c-cblas_trmm","(order, side, uplo, trans_a, diag, m, n, alpha, a, lda, b, ldb)","<p>The following are functions that used to be implemented in C, but now\nrequire nmatrix-atlas or nmatrix-lapcke …\n"],["cblas_trmm","NMatrix::LAPACKE::BLAS","NMatrix/LAPACKE/BLAS.html#method-c-cblas_trmm","(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12)",""],["cblas_trsm","NMatrix::ATLAS::BLAS","NMatrix/ATLAS/BLAS.html#method-c-cblas_trsm","(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12)",""],["cblas_trsm","NMatrix::LAPACKE::BLAS","NMatrix/LAPACKE/BLAS.html#method-c-cblas_trsm","(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12)",""],["clapack_getrf","NMatrix::ATLAS::LAPACK","NMatrix/ATLAS/LAPACK.html#method-c-clapack_getrf","(p1, p2, p3, p4, p5)","<p>Call any of the clapack_xgetrf functions as directly as possible.\n<p>The clapack_getrf functions (dgetrf, …\n"],["clapack_getri","NMatrix::ATLAS::LAPACK","NMatrix/ATLAS/LAPACK.html#method-c-clapack_getri","(p1, p2, p3, p4, p5)","<p>Call any of the clapack_xgetri functions as directly as possible.\n<p>You probably don&#39;t want to call …\n"],["clapack_getri","NMatrix::LAPACK","NMatrix/LAPACK.html#method-c-clapack_getri","(order, n, a, lda, ipiv)",""],["clapack_getrs","NMatrix::ATLAS::LAPACK","NMatrix/ATLAS/LAPACK.html#method-c-clapack_getrs","(p1, p2, p3, p4, p5, p6, p7, p8, p9)","<p>Call any of the clapack_xgetrs functions as directly as possible.\n"],["clapack_laswp","NMatrix::ATLAS::LAPACK","NMatrix/ATLAS/LAPACK.html#method-c-clapack_laswp","(p1, p2, p3, p4, p5, p6, p7)","<p>Call any of the clapack_xlaswp functions as directly as possible.\n<p>Note that LAPACK&#39;s xlaswp functions …\n"],["clapack_potrf","NMatrix::ATLAS::LAPACK","NMatrix/ATLAS/LAPACK.html#method-c-clapack_potrf","(p1, p2, p3, p4, p5)","<p>Call any of the clapack_xpotrf functions as directly as possible.\n<p>You probably don&#39;t want to call …\n"],["clapack_potrf","NMatrix::LAPACK","NMatrix/LAPACK.html#method-c-clapack_potrf","(order, uplo, n, a, lda)",""],["clapack_potri","NMatrix::ATLAS::LAPACK","NMatrix/ATLAS/LAPACK.html#method-c-clapack_potri","(p1, p2, p3, p4, p5)","<p>Call any of the clapack_xpotri functions as directly as possible.\n<p>You probably don&#39;t want to call …\n"],["clapack_potri","NMatrix::LAPACK","NMatrix/LAPACK.html#method-c-clapack_potri","(order, uplo, n, a, lda)",""],["clapack_potrs","NMatrix::ATLAS::LAPACK","NMatrix/ATLAS/LAPACK.html#method-c-clapack_potrs","(p1, p2, p3, p4, p5, p6, p7, p8)","<p>Call any of the clapack_xpotrs functions as directly as possible.\n"],["clapack_potrs","NMatrix::LAPACK","NMatrix/LAPACK.html#method-c-clapack_potrs","(order, uplo, n, nrhs, a, lda, b, ldb)",""],["clone_structure","NMatrix","NMatrix.html#method-i-clone_structure","(capacity = nil)","<p>This function is like clone, but it only copies the structure and the\ndefault value. None of the other …\n"],["clone_structure","NMatrix","NMatrix.html#method-i-clone_structure","(capacity = nil)","<p>This function is like clone, but it only copies the structure and the\ndefault value. None of the other …\n"],["col","NMatrix","NMatrix.html#method-i-col","(column_number, get_by = :copy)",""],["col","NMatrix","NMatrix.html#method-i-col","(column_number, get_by = :copy)",""],["cols","NMatrix","NMatrix.html#method-i-cols","()","<p>This shortcut use #shape to return the number of columns (the second\ndimension) of the matrix.\n"],["cols","NMatrix","NMatrix.html#method-i-cols","()","<p>This shortcut use #shape to return the number of columns (the second\ndimension) of the matrix.\n"],["column","NMatrix","NMatrix.html#method-i-column","(column_number, get_by = :copy)","<p>Returns the column specified. Uses slicing by copy as default.\n<p><strong>Arguments</strong> :\n<p><code>column_number</code> -&gt; Integer …\n"],["column","NMatrix","NMatrix.html#method-i-column","(column_number, get_by = :copy)","<p>Returns the column specified. Uses slicing by copy as default.\n<p><strong>Arguments</strong> :\n<p><code>column_number</code> -&gt; Integer …\n"],["complex_conjugate","NMatrix","NMatrix.html#method-i-complex_conjugate","()","<p>Transform the matrix (non-in-place) to its complex conjugate. Only works on\ncomplex matrices.\n"],["complex_conjugate","NMatrix","NMatrix.html#method-i-complex_conjugate","()","<p>Transform the matrix (non-in-place) to its complex conjugate. Only works on\ncomplex matrices.\n"],["complex_conjugate!","NMatrix","NMatrix.html#method-i-complex_conjugate-21","()","<p>Transform the matrix (in-place) to its complex conjugate. Only works on\ncomplex matrices.\n<p>Bang should …\n"],["complex_conjugate!","NMatrix","NMatrix.html#method-i-complex_conjugate-21","()","<p>Transform the matrix (in-place) to its complex conjugate. Only works on\ncomplex matrices.\n<p>Bang should …\n"],["complex_dtype?","NMatrix","NMatrix.html#method-i-complex_dtype-3F","()","<p>Checks if dtype is a complex type\n"],["complex_dtype?","NMatrix","NMatrix.html#method-i-complex_dtype-3F","()","<p>Checks if dtype is a complex type\n"],["complex_merge","NMatrix::IO::Matlab","NMatrix/IO/Matlab.html#method-c-complex_merge","(p1, p2, p3)","<p>Take two byte-strings (real and imaginary) and treat them as if they\ncontain a sequence of data of type …\n"],["concat","NMatrix","NMatrix.html#method-i-concat","(*matrices)","<p>Joins two matrices together into a new larger matrix. Attempts to determine\nwhich direction to concatenate …\n"],["concat","NMatrix","NMatrix.html#method-i-concat","(*matrices)","<p>Joins two matrices together into a new larger matrix. Attempts to determine\nwhich direction to concatenate …\n"],["conjugate_transpose","NMatrix","NMatrix.html#method-i-conjugate_transpose","()","<p>Calculate the conjugate transpose of a matrix. If your dtype is already\ncomplex, this should only require …\n"],["conjugate_transpose","NMatrix","NMatrix.html#method-i-conjugate_transpose","()","<p>Calculate the conjugate transpose of a matrix. If your dtype is already\ncomplex, this should only require …\n"],["const_missing","AutoloadPatch","AutoloadPatch.html#method-i-const_missing","(name)",""],["corr","NMatrix","NMatrix.html#method-i-corr","()","<p>Calculate the correlation matrix.\n"],["corr","NMatrix","NMatrix.html#method-i-corr","()","<p>Calculate the correlation matrix.\n"],["cov","NMatrix","NMatrix.html#method-i-cov","(opts={})","<p>Calculate the variance co-variance matrix\n<p>Options\n<p><code>:for_sample_data</code> - Default true. If set to false will …\n"],["cov","NMatrix","NMatrix.html#method-i-cov","(opts={})","<p>Calculate the variance co-variance matrix\n<p>Options\n<p><code>:for_sample_data</code> - Default true. If set to false will …\n"],["data_pointer","NMatrix","NMatrix.html#method-i-data_pointer","()","<p>Returns the pointer to the matrix storage&#39;s data. This is useful\nprimarily when you are using FFI …\n"],["data_pointer","NMatrix","NMatrix.html#method-i-data_pointer","()","<p>Returns the pointer to the matrix storage&#39;s data. This is useful\nprimarily when you are using FFI …\n"],["dconcat","NMatrix","NMatrix.html#method-i-dconcat","(*matrices)","<p>Depth concatenation with <code>matrices</code>.\n"],["dconcat","NMatrix","NMatrix.html#method-i-dconcat","(*matrices)","<p>Depth concatenation with <code>matrices</code>.\n"],["default_value","NMatrix","NMatrix.html#method-i-default_value","()","<p>Get the default value for the matrix. For dense, this is undefined and will\nreturn Qnil. For list, it …\n"],["default_value","NMatrix","NMatrix.html#method-i-default_value","()","<p>Get the default value for the matrix. For dense, this is undefined and will\nreturn Qnil. For list, it …\n"],["dense?","NMatrix","NMatrix.html#method-i-dense-3F","()","<p>Determine if <code>m</code> is a dense matrix.\n"],["dense?","NMatrix","NMatrix.html#method-i-dense-3F","()","<p>Determine if <code>m</code> is a dense matrix.\n"],["det","NMatrix","NMatrix.html#method-i-det","()","<p>Calculate the determinant by way of LU decomposition. This is accomplished\nusing clapack_getrf, and then …\n"],["det","NMatrix","NMatrix.html#method-i-det","()","<p>Calculate the determinant by way of LU decomposition. This is accomplished\nusing clapack_getrf, and then …\n"],["det_exact","NMatrix","NMatrix.html#method-i-det_exact","()","<p>Calculate the exact determinant of a dense matrix.\n<p>Returns nil for dense matrices which are not square …\n"],["det_exact","NMatrix","NMatrix.html#method-i-det_exact","()","<p>Calculate the exact determinant of a dense matrix.\n<p>Returns nil for dense matrices which are not square …\n"],["diag","NMatrix","NMatrix.html#method-c-diag","(entries, opts={})",""],["diag","NMatrix","NMatrix.html#method-c-diag","(entries, opts={})",""],["diagonal","NMatrix","NMatrix.html#method-c-diagonal","(entries, opts={})","<p>Creates a matrix filled with specified diagonals.\n<p><strong>Arguments</strong> :\n<p><code>entries</code> -&gt; Array containing input values …\n"],["diagonal","NMatrix","NMatrix.html#method-i-diagonal","(main_diagonal=true)","<p>Return the main diagonal or antidiagonal a matrix. Only works with 2D\nmatrices.\n<p>Arguments\n<p><code>main_diagonal</code> …\n"],["diagonal","NMatrix","NMatrix.html#method-c-diagonal","(entries, opts={})","<p>Creates a matrix filled with specified diagonals.\n<p><strong>Arguments</strong> :\n<p><code>entries</code> -&gt; Array containing input values …\n"],["diagonal","NMatrix","NMatrix.html#method-i-diagonal","(main_diagonal=true)","<p>Return the main diagonal or antidiagonal a matrix. Only works with 2D\nmatrices.\n<p>Arguments\n<p><code>main_diagonal</code> …\n"],["diagonals","NMatrix","NMatrix.html#method-c-diagonals","(entries, opts={})",""],["diagonals","NMatrix","NMatrix.html#method-c-diagonals","(entries, opts={})",""],["dim","NMatrix","NMatrix.html#method-i-dim","()",""],["dim","NMatrix","NMatrix.html#method-i-dim","()",""],["dimensions","NMatrix","NMatrix.html#method-i-dimensions","()","<p>Get the number of dimensions of a matrix.\n<p>In other words, if you set your matrix to be 3x4, the dim is …\n"],["dimensions","NMatrix","NMatrix.html#method-i-dimensions","()","<p>Get the number of dimensions of a matrix.\n<p>In other words, if you set your matrix to be 3x4, the dim is …\n"],["dot","NMatrix","NMatrix.html#method-i-dot","(p1)","<p>Matrix multiply (dot product): against another matrix or a vector.\n<p>For elementwise, use * instead.\n<p>The …\n"],["dot","NMatrix","NMatrix.html#method-i-dot","(p1)","<p>Matrix multiply (dot product): against another matrix or a vector.\n<p>For elementwise, use * instead.\n<p>The …\n"],["dtype","NMatrix","NMatrix.html#method-i-dtype","()","<p>Get the data type (dtype) of a matrix, e.g., :byte, :int8, :int16, :int32,\n:int64, :float32, :float64, …\n"],["dtype","NMatrix","NMatrix.html#method-i-dtype","()","<p>Get the data type (dtype) of a matrix, e.g., :byte, :int8, :int16, :int32,\n:int64, :float32, :float64, …\n"],["dtype_for_floor_or_ceil","NMatrix","NMatrix.html#method-i-dtype_for_floor_or_ceil","()","<p>These are for calculating the floor or ceil of matrix\n"],["dtype_for_floor_or_ceil","NMatrix","NMatrix.html#method-i-dtype_for_floor_or_ceil","()","<p>These are for calculating the floor or ceil of matrix\n"],["each","NMatrix","NMatrix.html#method-i-each","(&bl)","<p>Enumerate through the matrix. @see Enumerable#each\n<p>For dense, this actually calls a specialized each iterator …\n"],["each","NMatrix","NMatrix.html#method-i-each","(&bl)","<p>Enumerate through the matrix. @see Enumerable#each\n<p>For dense, this actually calls a specialized each iterator …\n"],["each_along_dim","NMatrix","NMatrix.html#method-i-each_along_dim","(dimen=0, get_by=:reference)",""],["each_along_dim","NMatrix","NMatrix.html#method-i-each_along_dim","(dimen=0, get_by=:reference)",""],["each_column","NMatrix","NMatrix.html#method-i-each_column","(get_by=:reference)","<p>Iterate through each column, referencing it as an NMatrix slice.\n"],["each_column","NMatrix","NMatrix.html#method-i-each_column","(get_by=:reference)","<p>Iterate through each column, referencing it as an NMatrix slice.\n"],["each_layer","NMatrix","NMatrix.html#method-i-each_layer","(get_by=:reference)","<p>Iterate through each layer, referencing it as an NMatrix slice.\n<p>Note: If you have a 3-dimensional matrix, …\n"],["each_layer","NMatrix","NMatrix.html#method-i-each_layer","(get_by=:reference)","<p>Iterate through each layer, referencing it as an NMatrix slice.\n<p>Note: If you have a 3-dimensional matrix, …\n"],["each_ordered_stored_with_indices","NMatrix","NMatrix.html#method-i-each_ordered_stored_with_indices","()","<p>Very similar to #each_stored_with_indices. The key difference is that it\nenforces matrix ordering rather …\n"],["each_ordered_stored_with_indices","NMatrix","NMatrix.html#method-i-each_ordered_stored_with_indices","()","<p>Very similar to #each_stored_with_indices. The key difference is that it\nenforces matrix ordering rather …\n"],["each_rank","NMatrix","NMatrix.html#method-i-each_rank","(dimen=0, get_by=:reference)","<p>Generic for @each_row, @each_col\n<p>Iterate through each rank by reference.\n<p>@param [Fixnum] dimen the rank …\n"],["each_rank","NMatrix","NMatrix.html#method-i-each_rank","(dimen=0, get_by=:reference)","<p>Generic for @each_row, @each_col\n<p>Iterate through each rank by reference.\n<p>@param [Fixnum] dimen the rank …\n"],["each_row","NMatrix","NMatrix.html#method-i-each_row","(get_by=:reference)","<p>Iterate through each row, referencing it as an NMatrix slice.\n"],["each_row","NMatrix","NMatrix.html#method-i-each_row","(get_by=:reference)","<p>Iterate through each row, referencing it as an NMatrix slice.\n"],["each_stored_with_index","NMatrix","NMatrix.html#method-i-each_stored_with_index","(&block)","<p>Allow iteration across a vector NMatrix&#39;s stored values. See also\n@each_stored_with_indices\n"],["each_stored_with_index","NMatrix","NMatrix.html#method-i-each_stored_with_index","(&block)","<p>Allow iteration across a vector NMatrix&#39;s stored values. See also\n@each_stored_with_indices\n"],["each_stored_with_indices","NMatrix","NMatrix.html#method-i-each_stored_with_indices","()","<p>Iterate over the stored entries of any matrix. For dense and yale, this\niterates over non-zero entries; …\n"],["each_stored_with_indices","NMatrix","NMatrix.html#method-i-each_stored_with_indices","()","<p>Iterate over the stored entries of any matrix. For dense and yale, this\niterates over non-zero entries; …\n"],["each_with_indices","NMatrix","NMatrix.html#method-i-each_with_indices","()","<p>Iterate over all entries of any matrix in standard storage order (as with\n#each), and include the indices. …\n"],["each_with_indices","NMatrix","NMatrix.html#method-i-each_with_indices","()","<p>Iterate over all entries of any matrix in standard storage order (as with\n#each), and include the indices. …\n"],["effective_dim","NMatrix","NMatrix.html#method-i-effective_dim","()",""],["effective_dim","NMatrix","NMatrix.html#method-i-effective_dim","()",""],["effective_dimensions","NMatrix","NMatrix.html#method-i-effective_dimensions","()","<p>Returns the number of dimensions that don&#39;t have length 1. Guaranteed\nto be less than or equal to …\n"],["effective_dimensions","NMatrix","NMatrix.html#method-i-effective_dimensions","()","<p>Returns the number of dimensions that don&#39;t have length 1. Guaranteed\nto be less than or equal to …\n"],["eye","NMatrix","NMatrix.html#method-c-eye","(shape, opts={})","<p>Creates an identity matrix (square matrix rank 2).\n<p><strong>Arguments</strong> :\n<p><code>size</code> -&gt; Array (or integer for square …\n"],["eye","NMatrix","NMatrix.html#method-c-eye","(shape, opts={})","<p>Creates an identity matrix (square matrix rank 2).\n<p><strong>Arguments</strong> :\n<p><code>size</code> -&gt; Array (or integer for square …\n"],["factorize_cholesky","NMatrix","NMatrix.html#method-i-factorize_cholesky","()","<p>Calculates the Cholesky factorization of a matrix and returns the upper and\nlower matrices such that …\n"],["factorize_cholesky","NMatrix","NMatrix.html#method-i-factorize_cholesky","()","<p>Calculates the Cholesky factorization of a matrix and returns the upper and\nlower matrices such that …\n"],["factorize_lu","NMatrix","NMatrix.html#method-i-factorize_lu","(with_permutation_matrix=nil)","<p>LU factorization of a matrix. Optionally return the permutation matrix.\n\n<pre>Note that computing the permutation ...</pre>\n"],["factorize_lu","NMatrix","NMatrix.html#method-i-factorize_lu","(with_permutation_matrix=nil)","<p>LU factorization of a matrix. Optionally return the permutation matrix.\n\n<pre>Note that computing the permutation ...</pre>\n"],["flat_map","NMatrix","NMatrix.html#method-i-flat_map","(&bl)","<p>call-seq:\n\n<pre>flat_map -&gt; Enumerator\nflat_map { |elem| block } -&gt; Array</pre>\n<p>Maps using Enumerator (returns an  …\n"],["flat_map","NMatrix","NMatrix.html#method-i-flat_map","(&bl)","<p>call-seq:\n\n<pre>flat_map -&gt; Enumerator\nflat_map { |elem| block } -&gt; Array</pre>\n<p>Maps using Enumerator (returns an  …\n"],["float_dtype?","NMatrix","NMatrix.html#method-i-float_dtype-3F","()","<p>Checks if dtype is a floating point type\n"],["float_dtype?","NMatrix","NMatrix.html#method-i-float_dtype-3F","()","<p>Checks if dtype is a floating point type\n"],["geev","NMatrix::LAPACK","NMatrix/LAPACK.html#method-c-geev","(matrix, which=:both)",""],["gemm","NMatrix::BLAS","NMatrix/BLAS.html#method-c-gemm","(a, b, c = nil, alpha = 1.0, beta = 0.0, transpose_a = false, transpose_b = false, m = nil, n = nil, k = nil, lda = nil, ldb = nil, ldc = nil)","<p>Updates the value of C via the matrix multiplication\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">C</span> = (<span class=\"ruby-identifier\">alpha</span> <span class=\"ruby-operator\">*</span> <span class=\"ruby-constant\">A</span> <span class=\"ruby-operator\">*</span> <span class=\"ruby-constant\">B</span>) <span class=\"ruby-operator\">+</span> (<span class=\"ruby-identifier\">beta</span> <span class=\"ruby-operator\">*</span> <span class=\"ruby-constant\">C</span>)\n</pre>\n<p>where <code>alpha</code> and  …\n"],["gemv","NMatrix::BLAS","NMatrix/BLAS.html#method-c-gemv","(a, x, y = nil, alpha = 1.0, beta = 0.0, transpose_a = false, m = nil, n = nil, lda = nil, incx = nil, incy = nil)","<p>Implements matrix-vector product via\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">y</span> = (<span class=\"ruby-identifier\">alpha</span> <span class=\"ruby-operator\">*</span> <span class=\"ruby-constant\">A</span> <span class=\"ruby-operator\">*</span> <span class=\"ruby-identifier\">x</span>) <span class=\"ruby-operator\">+</span> (<span class=\"ruby-identifier\">beta</span> <span class=\"ruby-operator\">*</span> <span class=\"ruby-identifier\">y</span>)\n</pre>\n<p>where <code>alpha</code> and <code>beta</code> are scalar values. …\n"],["gesdd","NMatrix","NMatrix.html#method-i-gesdd","(workspace_size=nil)","<p>Compute the singular value decomposition of a matrix using LAPACK&#39;s\nGESDD function. This uses a divide-and-conquer …\n"],["gesdd","NMatrix","NMatrix.html#method-i-gesdd","(workspace_size=nil)","<p>Compute the singular value decomposition of a matrix using LAPACK&#39;s\nGESDD function. This uses a divide-and-conquer …\n"],["gesdd","NMatrix::LAPACK","NMatrix/LAPACK.html#method-c-gesdd","(matrix, workspace_size=nil)",""],["gesdd!","NMatrix","NMatrix.html#method-i-gesdd-21","(workspace_size=nil)","<p>Compute the singular value decomposition of a matrix using LAPACK&#39;s\nGESDD function. This uses a divide-and-conquer …\n"],["gesdd!","NMatrix","NMatrix.html#method-i-gesdd-21","(workspace_size=nil)","<p>Compute the singular value decomposition of a matrix using LAPACK&#39;s\nGESDD function. This uses a divide-and-conquer …\n"],["gesvd","NMatrix","NMatrix.html#method-i-gesvd","(workspace_size=1)","<p>Compute the singular value decomposition of a matrix using LAPACK&#39;s\nGESVD function.\n<p>Optionally accepts …\n"],["gesvd","NMatrix","NMatrix.html#method-i-gesvd","(workspace_size=1)","<p>Compute the singular value decomposition of a matrix using LAPACK&#39;s\nGESVD function.\n<p>Optionally accepts …\n"],["gesvd","NMatrix::LAPACK","NMatrix/LAPACK.html#method-c-gesvd","(matrix, workspace_size=1)",""],["gesvd!","NMatrix","NMatrix.html#method-i-gesvd-21","(workspace_size=1)","<p>Compute the singular value decomposition of a matrix using LAPACK&#39;s\nGESVD function. This is destructive, …\n"],["gesvd!","NMatrix","NMatrix.html#method-i-gesvd-21","(workspace_size=1)","<p>Compute the singular value decomposition of a matrix using LAPACK&#39;s\nGESVD function. This is destructive, …\n"],["getrf!","NMatrix","NMatrix.html#method-i-getrf-21","()",""],["getrf!","NMatrix","NMatrix.html#method-i-getrf-21","()",""],["gplusplus_version","Object","Object.html#method-i-gplusplus_version","()",""],["guess_dtype","NMatrix","NMatrix.html#method-c-guess_dtype","(p1)","<p>Guess the dtype given a Ruby VALUE and return it as a symbol.\n<p>Not to be confused with nm_dtype_guess, …\n"],["guess_dtype","NMatrix","NMatrix.html#method-c-guess_dtype","(p1)","<p>Guess the dtype given a Ruby VALUE and return it as a symbol.\n<p>Not to be confused with nm_dtype_guess, …\n"],["hconcat","NMatrix","NMatrix.html#method-i-hconcat","(*matrices)","<p>Horizontal concatenation with <code>matrices</code>.\n"],["hconcat","NMatrix","NMatrix.html#method-i-hconcat","(*matrices)","<p>Horizontal concatenation with <code>matrices</code>.\n"],["header","NMatrix::IO::HarwellBoeing::Reader","NMatrix/IO/HarwellBoeing/Reader.html#method-i-header","()",""],["hermitian?","NMatrix","NMatrix.html#method-i-hermitian-3F","()","<p>Is this matrix hermitian?\n<p>Definition: en.wikipedia.org/wiki/Hermitian_matrix\n<p>For non-complex matrices, …\n"],["hermitian?","NMatrix","NMatrix.html#method-i-hermitian-3F","()","<p>Is this matrix hermitian?\n<p>Definition: en.wikipedia.org/wiki/Hermitian_matrix\n<p>For non-complex matrices, …\n"],["hessenberg","NMatrix","NMatrix.html#method-i-hessenberg","()","<p>Reduce self to upper hessenberg form using householder transforms.\n<p>References\n<p>en.wikipedia.org/wiki/Hessenberg_matrix …\n"],["hessenberg","NMatrix","NMatrix.html#method-i-hessenberg","()","<p>Reduce self to upper hessenberg form using householder transforms.\n<p>References\n<p>en.wikipedia.org/wiki/Hessenberg_matrix …\n"],["hessenberg!","NMatrix","NMatrix.html#method-i-hessenberg-21","()","<p>Destructive version of #hessenberg\n"],["hessenberg!","NMatrix","NMatrix.html#method-i-hessenberg-21","()","<p>Destructive version of #hessenberg\n"],["identity","NMatrix","NMatrix.html#method-c-identity","(shape, opts={})",""],["identity","NMatrix","NMatrix.html#method-c-identity","(shape, opts={})",""],["index","NMatrix","NMatrix.html#method-i-index","(value)","<p>Returns the index of the first occurence of the specified value. Returns \nan array containing the position …\n"],["index","NMatrix","NMatrix.html#method-i-index","(value)","<p>Returns the index of the first occurence of the specified value. Returns \nan array containing the position …\n"],["initialize_copy","NMatrix","NMatrix.html#method-i-initialize_copy","(p1)","<p>Copy constructor for no change of dtype or stype (used for #initialize_copy\nhook).\n"],["initialize_copy","NMatrix","NMatrix.html#method-i-initialize_copy","(p1)","<p>Copy constructor for no change of dtype or stype (used for #initialize_copy\nhook).\n"],["inject","NMatrix","NMatrix.html#method-i-inject","(sym)","<p>This overrides the inject function to use map_stored for yale matrices\n"],["inject","NMatrix","NMatrix.html#method-i-inject","(sym)","<p>This overrides the inject function to use map_stored for yale matrices\n"],["inject_along_dim","NMatrix","NMatrix.html#method-i-inject_along_dim","(dimen=0, initial=nil, dtype=nil)",""],["inject_along_dim","NMatrix","NMatrix.html#method-i-inject_along_dim","(dimen=0, initial=nil, dtype=nil)",""],["inject_rank","NMatrix","NMatrix.html#method-i-inject_rank","(dimen=0, initial=nil, dtype=nil)","<p>Reduces an NMatrix using a supplied block over a specified dimension. The\nblock should behave the same …\n"],["inject_rank","NMatrix","NMatrix.html#method-i-inject_rank","(dimen=0, initial=nil, dtype=nil)","<p>Reduces an NMatrix using a supplied block over a specified dimension. The\nblock should behave the same …\n"],["integer_dtype?","NMatrix","NMatrix.html#method-i-integer_dtype-3F","()","<p>Checks if dtype is an integer type\n"],["integer_dtype?","NMatrix","NMatrix.html#method-i-integer_dtype-3F","()","<p>Checks if dtype is an integer type\n"],["internal_dot","NMatrix","NMatrix.html#method-i-internal_dot","(p1)",""],["internal_dot","NMatrix","NMatrix.html#method-i-internal_dot","(p1)",""],["inverse","NMatrix","NMatrix.html#method-i-inverse","()",""],["inverse","NMatrix","NMatrix.html#method-i-inverse","()",""],["invert","NMatrix","NMatrix.html#method-i-invert","()","<p>Make a copy of the matrix, then invert using Gauss-Jordan elimination.\nWorks without LAPACK.\n<p><strong>Returns</strong> : …\n"],["invert","NMatrix","NMatrix.html#method-i-invert","()","<p>Make a copy of the matrix, then invert using Gauss-Jordan elimination.\nWorks without LAPACK.\n<p><strong>Returns</strong> : …\n"],["invert!","NMatrix","NMatrix.html#method-i-invert-21","()",""],["invert!","NMatrix","NMatrix.html#method-i-invert-21","()",""],["is_ref?","NMatrix","NMatrix.html#method-i-is_ref-3F","()","<p>Check to determine whether matrix is a reference to another matrix.\n"],["is_ref?","NMatrix","NMatrix.html#method-i-is_ref-3F","()","<p>Check to determine whether matrix is a reference to another matrix.\n"],["kron_prod","NMatrix","NMatrix.html#method-i-kron_prod","(mat)","<p>Compute the Kronecker product of <code>self</code> and other NMatrix\n<p>Arguments\n\n<pre>* +mat+ - A 2D NMatrix object</pre>\n"],["kron_prod","NMatrix","NMatrix.html#method-i-kron_prod","(mat)","<p>Compute the Kronecker product of <code>self</code> and other NMatrix\n<p>Arguments\n\n<pre>* +mat+ - A 2D NMatrix object</pre>\n"],["lapack_geev","NMatrix::ATLAS::LAPACK","NMatrix/ATLAS/LAPACK.html#method-c-lapack_geev","(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12)","<p>Function signature conversion for calling CBLAS&#39; geev functions as\ndirectly as possible.\n<p>GEEV computes …\n"],["lapack_geev","NMatrix::LAPACK","NMatrix/LAPACK.html#method-c-lapack_geev","(jobvl, jobvr, n, a, lda, w, wi, vl, ldvl, vr, ldvr, lwork)",""],["lapack_gesdd","NMatrix::ATLAS::LAPACK","NMatrix/ATLAS/LAPACK.html#method-c-lapack_gesdd","(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11)","<p>Function signature conversion for calling CBLAS&#39; gesdd functions as\ndirectly as possible.\n<p>xGESDD uses …\n"],["lapack_gesdd","NMatrix::LAPACK","NMatrix/LAPACK.html#method-c-lapack_gesdd","(jobz, m, n, a, lda, s, u, ldu, vt, ldvt, lwork)",""],["lapack_gesvd","NMatrix::ATLAS::LAPACK","NMatrix/ATLAS/LAPACK.html#method-c-lapack_gesvd","(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12)","<p>Function signature conversion for calling CBLAS&#39; gesvd functions as\ndirectly as possible.\n<p>xGESVD computes …\n"],["lapack_gesvd","NMatrix::LAPACK","NMatrix/LAPACK.html#method-c-lapack_gesvd","(jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, lwork)","<p>The following are functions that used to be implemented in C, but now\nrequire nmatrix-atlas to run properly, …\n"],["lapacke_geev","NMatrix::LAPACKE::LAPACK","NMatrix/LAPACKE/LAPACK.html#method-c-lapacke_geev","(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12)",""],["lapacke_gesdd","NMatrix::LAPACKE::LAPACK","NMatrix/LAPACKE/LAPACK.html#method-c-lapacke_gesdd","(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11)",""],["lapacke_gesvd","NMatrix::LAPACKE::LAPACK","NMatrix/LAPACKE/LAPACK.html#method-c-lapacke_gesvd","(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13)","<p>xGESVD computes the singular value decomposition (SVD) of a real M-by-N\nmatrix A, optionally computing …\n"],["lapacke_getrf","NMatrix::LAPACKE::LAPACK","NMatrix/LAPACKE/LAPACK.html#method-c-lapacke_getrf","(p1, p2, p3, p4, p5)","<p>Call any of the lapacke_xgetrf functions as directly as possible.\n<p>The lapacke_getrf functions (dgetrf, …\n"],["lapacke_getri","NMatrix::LAPACKE::LAPACK","NMatrix/LAPACKE/LAPACK.html#method-c-lapacke_getri","(p1, p2, p3, p4, p5)","<p>Call any of the lapacke_xgetri functions as directly as possible.\n<p>This version (the LAPACKE version) differs …\n"],["lapacke_getrs","NMatrix::LAPACKE::LAPACK","NMatrix/LAPACKE/LAPACK.html#method-c-lapacke_getrs","(p1, p2, p3, p4, p5, p6, p7, p8, p9)","<p>Call any of the lapacke_xgetrs functions as directly as possible.\n"],["lapacke_potrf","NMatrix::LAPACKE::LAPACK","NMatrix/LAPACKE/LAPACK.html#method-c-lapacke_potrf","(p1, p2, p3, p4, p5)","<p>Call any of the LAPACKE_xpotrf functions as directly as possible.\n<p>This function does almost no type checking. …\n"],["lapacke_potri","NMatrix::LAPACKE::LAPACK","NMatrix/LAPACKE/LAPACK.html#method-c-lapacke_potri","(p1, p2, p3, p4, p5)","<p>Call any of the lapacke_xpotri functions as directly as possible.\n<p>This function does almost no type checking. …\n"],["lapacke_potrs","NMatrix::LAPACKE::LAPACK","NMatrix/LAPACKE/LAPACK.html#method-c-lapacke_potrs","(p1, p2, p3, p4, p5, p6, p7, p8)","<p>Call any of the LAPACKE_xpotrs functions as directly as possible.\n"],["laswp","NMatrix","NMatrix.html#method-i-laswp","(ary, opts={})","<p>Permute the columns of a dense matrix using LASWP according to the order\ngiven in an array <code>ary</code>.\n<p>If <code>:convention</code> …\n"],["laswp","NMatrix","NMatrix.html#method-i-laswp","(ary, opts={})","<p>Permute the columns of a dense matrix using LASWP according to the order\ngiven in an array <code>ary</code>.\n<p>If <code>:convention</code> …\n"],["laswp","NMatrix::LAPACK","NMatrix/LAPACK.html#method-c-laswp","(matrix, ipiv)","\n<pre>laswp(matrix, ipiv) -&gt; NMatrix</pre>\n<p>Permute the columns of a matrix (in-place) according to the Array\n<code>ipiv</code> …\n"],["laswp!","NMatrix","NMatrix.html#method-i-laswp-21","(ary, opts={})","<p>In-place permute the columns of a dense matrix using LASWP according to the\norder given as an array  …\n"],["laswp!","NMatrix","NMatrix.html#method-i-laswp-21","(ary, opts={})","<p>In-place permute the columns of a dense matrix using LASWP according to the\norder given as an array  …\n"],["layer","NMatrix","NMatrix.html#method-i-layer","(layer_number, get_by = :copy)","<p><strong>Arguments</strong> :\n<p><code>layer_number</code> -&gt; Integer.\n<p><code>get_by</code> -&gt; Type of slicing to use, <code>:copy</code> or\n<code>:reference</code>.\n"],["layer","NMatrix","NMatrix.html#method-i-layer","(layer_number, get_by = :copy)","<p><strong>Arguments</strong> :\n<p><code>layer_number</code> -&gt; Integer.\n<p><code>get_by</code> -&gt; Type of slicing to use, <code>:copy</code> or\n<code>:reference</code>.\n"],["list?","NMatrix","NMatrix.html#method-i-list-3F","()","<p>Determine if <code>m</code> is a list-of-lists matrix.\n"],["list?","NMatrix","NMatrix.html#method-i-list-3F","()","<p>Determine if <code>m</code> is a list-of-lists matrix.\n"],["load","NMatrix::IO::HarwellBoeing","NMatrix/IO/HarwellBoeing.html#method-c-load","(file_path, opts={})","<p>Loads the contents of a valid Harwell Boeing format file and  returns an\nNMatrix object with the values …\n"],["load","NMatrix::IO::Market","NMatrix/IO/Market.html#method-c-load","(filename)","<p>Load a MatrixMarket file. Requires a <code>filename</code> as an argument.\n<p><strong>Arguments</strong> :\n<p><code>filename</code> -&gt; String with the …\n"],["load","NMatrix::IO::Matlab","NMatrix/IO/Matlab.html#method-c-load","(file_path)",""],["load","NMatrix::IO::PointCloud","NMatrix/IO/PointCloud.html#method-c-load","(filename)","<p><strong>Arguments</strong> :\n<p><code>filename</code> -&gt; String giving the name of the file to be\nloaded.\n\n\n<p>Load a Point Cloud Library …\n"],["load_array","NMatrix::IO::Market","NMatrix/IO/Market.html#method-c-load_array","(file, converter, dtype, entry_type, symmetry)",""],["load_coordinate","NMatrix::IO::Market","NMatrix/IO/Market.html#method-c-load_coordinate","(file, converter, dtype, entry_type, symmetry)","<p>Creates a :list NMatrix from a coordinate-list MatrixMarket file.\n"],["load_mat","NMatrix::IO::Matlab","NMatrix/IO/Matlab.html#method-c-load_mat","(file_path)","<p>Load a .mat file and return a NMatrix corresponding to it.\n"],["load_matlab_file","NMatrix","NMatrix.html#method-c-load_matlab_file","(file_path)","<p><strong>Arguments</strong> :\n<p><code>file_path</code> -&gt; The path to a version 5 .mat file.\n\n<p><strong>Returns</strong> :\n"],["load_matlab_file","NMatrix","NMatrix.html#method-c-load_matlab_file","(file_path)","<p><strong>Arguments</strong> :\n<p><code>file_path</code> -&gt; The path to a version 5 .mat file.\n\n<p><strong>Returns</strong> :\n"],["load_pcd_file","NMatrix","NMatrix.html#method-c-load_pcd_file","(file_path)","<p><strong>Arguments</strong> :\n<p><code>file_path</code> -&gt; The path to a PCL PCD file.\n\n<p><strong>Returns</strong> :\n"],["load_pcd_file","NMatrix","NMatrix.html#method-c-load_pcd_file","(file_path)","<p><strong>Arguments</strong> :\n<p><code>file_path</code> -&gt; The path to a PCL PCD file.\n\n<p><strong>Returns</strong> :\n"],["log","NMatrix","NMatrix.html#method-i-log","(*args)",""],["log","NMatrix","NMatrix.html#method-i-log","(*args)",""],["lower_triangle","NMatrix","NMatrix.html#method-i-lower_triangle","(k = 0)","<p>Returns the lower triangular portion of a matrix. This is analogous to the\n<code>tril</code> method in MATLAB.\n<p><strong>Arguments</strong> …\n"],["lower_triangle","NMatrix","NMatrix.html#method-i-lower_triangle","(k = 0)","<p>Returns the lower triangular portion of a matrix. This is analogous to the\n<code>tril</code> method in MATLAB.\n<p><strong>Arguments</strong> …\n"],["lower_triangle!","NMatrix","NMatrix.html#method-i-lower_triangle-21","(k = 0)","<p>Deletes the upper triangular portion of the matrix (in-place) so only the\nlower portion remains.\n<p><strong>Arguments</strong> …\n"],["lower_triangle!","NMatrix","NMatrix.html#method-i-lower_triangle-21","(k = 0)","<p>Deletes the upper triangular portion of the matrix (in-place) so only the\nlower portion remains.\n<p><strong>Arguments</strong> …\n"],["map","NMatrix","NMatrix.html#method-i-map","(&bl)","<p>Returns an NMatrix if a block is given. For an Array, use #flat_map\n<p>Note that #map will always return …\n"],["map","NMatrix","NMatrix.html#method-i-map","(&bl)","<p>Returns an NMatrix if a block is given. For an Array, use #flat_map\n<p>Note that #map will always return …\n"],["map!","NMatrix","NMatrix.html#method-i-map-21","()","<p>Maps in place. @see #map\n"],["map!","NMatrix","NMatrix.html#method-i-map-21","()","<p>Maps in place. @see #map\n"],["map_stored","NMatrix","NMatrix.html#method-i-map_stored","()","<p>Iterate over the stored entries of any matrix. For dense and yale, this\niterates over non-zero entries; …\n"],["map_stored","NMatrix","NMatrix.html#method-i-map_stored","()","<p>Iterate over the stored entries of any matrix. For dense and yale, this\niterates over non-zero entries; …\n"],["max","NMatrix","NMatrix.html#method-i-max","(dimen=0)","<p>Calculates the maximum along the specified dimension.\n<p>@see #inject_rank\n"],["max","NMatrix","NMatrix.html#method-i-max","(dimen=0)","<p>Calculates the maximum along the specified dimension.\n<p>@see #inject_rank\n"],["mean","NMatrix","NMatrix.html#method-i-mean","(dimen=0)","<p>Calculates the mean along the specified dimension.\n<p>This will force integer types to float64 dtype.\n<p>@see …\n"],["mean","NMatrix","NMatrix.html#method-i-mean","(dimen=0)","<p>Calculates the mean along the specified dimension.\n<p>This will force integer types to float64 dtype.\n<p>@see …\n"],["meshgrid","NMatrix","NMatrix.html#method-c-meshgrid","(vectors, options = {})","<p>Make N-D coordinate arrays for vectorized evaluations of N-D scalar/vector\nfields over N-D grids, given …\n"],["meshgrid","NMatrix","NMatrix.html#method-c-meshgrid","(vectors, options = {})","<p>Make N-D coordinate arrays for vectorized evaluations of N-D scalar/vector\nfields over N-D grids, given …\n"],["min","NMatrix","NMatrix.html#method-i-min","(dimen=0)","<p>Calculates the minimum along the specified dimension.\n<p>@see #inject_rank\n"],["min","NMatrix","NMatrix.html#method-i-min","(dimen=0)","<p>Calculates the minimum along the specified dimension.\n<p>@see #inject_rank\n"],["min_dtype","NMatrix","NMatrix.html#method-c-min_dtype","(p1)","<p>Get the minimum allowable dtype for a Ruby VALUE and return it as a symbol.\n"],["min_dtype","NMatrix","NMatrix.html#method-c-min_dtype","(p1)","<p>Get the minimum allowable dtype for a Ruby VALUE and return it as a symbol.\n"],["new","NMatrix","NMatrix.html#method-c-new","(*args)","<p>Create a new NMatrix.\n<p>The only mandatory argument is shape, which may be a positive integer or an\narray …\n"],["new","NMatrix","NMatrix.html#method-c-new","(*args)","<p>Create a new NMatrix.\n<p>The only mandatory argument is shape, which may be a positive integer or an\narray …\n"],["new","NMatrix::IO::FortranFormat::Reader","NMatrix/IO/FortranFormat/Reader.html#method-c-new","(string)","<p>Accepts a string in FORTRAN format and initializes the \nNMatrix::IO::FortranFormat::Reader object for …\n"],["new","NMatrix::IO::HarwellBoeing::Reader","NMatrix/IO/HarwellBoeing/Reader.html#method-c-new","(file_name)",""],["norm2","NMatrix","NMatrix.html#method-i-norm2","(incx=1, n=nil)",""],["norm2","NMatrix","NMatrix.html#method-i-norm2","(incx=1, n=nil)",""],["nrm2","NMatrix","NMatrix.html#method-i-nrm2","(incx=1, n=nil)","<p>Arguments\n\n<pre>- +incx+ -&gt; the skip size (defaults to 1, no skip)\n- +n+ -&gt; the number of elements to include</pre>\n"],["nrm2","NMatrix","NMatrix.html#method-i-nrm2","(incx=1, n=nil)","<p>Arguments\n\n<pre>- +incx+ -&gt; the skip size (defaults to 1, no skip)\n- +n+ -&gt; the number of elements to include</pre>\n"],["nrm2","NMatrix::BLAS","NMatrix/BLAS.html#method-c-nrm2","(x, incx = 1, n = nil)","<p>Calculate the 2-norm of a vector <code>x</code> of size <code>n</code>\n<p><strong>Arguments</strong> :\n<p><code>x</code> -&gt; an NMatrix (will also allow an NMatrix …\n"],["nvector?","NMatrix","NMatrix.html#method-i-nvector-3F","()","<p>Shortcut function for determining whether the effective dimension is less\nthan the dimension. Useful …\n"],["nvector?","NMatrix","NMatrix.html#method-i-nvector-3F","()","<p>Shortcut function for determining whether the effective dimension is less\nthan the dimension. Useful …\n"],["object_dtype?","NMatrix","NMatrix.html#method-i-object_dtype-3F","()","<p>Checks if dtype is a ruby object\n"],["object_dtype?","NMatrix","NMatrix.html#method-i-object_dtype-3F","()","<p>Checks if dtype is a ruby object\n"],["offset","NMatrix","NMatrix.html#method-i-offset","()","<p>Get the offset (slice position) of a matrix. Typically all zeros, unless\nyou have a reference slice. …\n"],["offset","NMatrix","NMatrix.html#method-i-offset","()","<p>Get the offset (slice position) of a matrix. Typically all zeros, unless\nyou have a reference slice. …\n"],["ones","NMatrix","NMatrix.html#method-c-ones","(shape, opts={})","<p>Creates a matrix filled with ones.\n<p><strong>Arguments</strong> :\n<p><code>shape</code> -&gt; Array (or integer for square matrix) specifying …\n"],["ones","NMatrix","NMatrix.html#method-c-ones","(shape, opts={})","<p>Creates a matrix filled with ones.\n<p><strong>Arguments</strong> :\n<p><code>shape</code> -&gt; Array (or integer for square matrix) specifying …\n"],["ones_like","NMatrix","NMatrix.html#method-c-ones_like","(nm)","<p>Creates a new matrix of ones with the same dtype and shape as the provided\nmatrix.\n<p>@param [NMatrix] nm …\n"],["ones_like","NMatrix","NMatrix.html#method-c-ones_like","(nm)","<p>Creates a new matrix of ones with the same dtype and shape as the provided\nmatrix.\n<p>@param [NMatrix] nm …\n"],["parse","NMatrix::IO::FortranFormat::Reader","NMatrix/IO/FortranFormat/Reader.html#method-i-parse","()","<p>Parses the FORTRAN format string passed in initialize and returns a hash of\nthe results.\n<p>Result Hash  …\n"],["permutation_array_for","NMatrix::FactorizeLUMethods","NMatrix/FactorizeLUMethods.html#method-c-permutation_array_for","(pivot_array)",""],["permutation_matrix_from","NMatrix::FactorizeLUMethods","NMatrix/FactorizeLUMethods.html#method-c-permutation_matrix_from","(pivot_array)",""],["permute_columns","NMatrix","NMatrix.html#method-i-permute_columns","(ary, opts={})",""],["permute_columns","NMatrix","NMatrix.html#method-i-permute_columns","(ary, opts={})",""],["permute_columns!","NMatrix","NMatrix.html#method-i-permute_columns-21","(ary, opts={})",""],["permute_columns!","NMatrix","NMatrix.html#method-i-permute_columns-21","(ary, opts={})",""],["posv","NMatrix::LAPACK","NMatrix/LAPACK.html#method-c-posv","(uplo, a, b)",""],["potrf!","NMatrix","NMatrix.html#method-i-potrf-21","(which)",""],["potrf!","NMatrix","NMatrix.html#method-i-potrf-21","(which)",""],["potrf_lower!","NMatrix","NMatrix.html#method-i-potrf_lower-21","()",""],["potrf_lower!","NMatrix","NMatrix.html#method-i-potrf_lower-21","()",""],["potrf_upper!","NMatrix","NMatrix.html#method-i-potrf_upper-21","()",""],["potrf_upper!","NMatrix","NMatrix.html#method-i-potrf_upper-21","()",""],["pow","NMatrix","NMatrix.html#method-i-pow","(n)","<p>Raise a square matrix to a power. Be careful of numeric overflows! In case\n<strong>n</strong> is 0, an identity matrix …\n"],["pow","NMatrix","NMatrix.html#method-i-pow","(n)","<p>Raise a square matrix to a power. Be careful of numeric overflows! In case\n<strong>n</strong> is 0, an identity matrix …\n"],["quaternion","NMatrix","NMatrix.html#method-i-quaternion","()","<p>Find the quaternion for a 3D rotation matrix.\n<p>Code borrowed from: courses.cms.caltech.edu/cs171/quatut.pdf …\n"],["quaternion","NMatrix","NMatrix.html#method-i-quaternion","()","<p>Find the quaternion for a 3D rotation matrix.\n<p>Code borrowed from: courses.cms.caltech.edu/cs171/quatut.pdf …\n"],["rand","NMatrix","NMatrix.html#method-c-rand","(shape, opts={})",""],["rand","NMatrix","NMatrix.html#method-c-rand","(shape, opts={})",""],["random","NMatrix","NMatrix.html#method-c-random","(shape, opts={})","<p>Creates a <code>:dense</code> NMatrix with random numbers between 0 and 1\ngenerated by <code>Random::rand</code>. The parameter …\n"],["random","NMatrix","NMatrix.html#method-c-random","(shape, opts={})","<p>Creates a <code>:dense</code> NMatrix with random numbers between 0 and 1\ngenerated by <code>Random::rand</code>. The parameter …\n"],["rank","NMatrix","NMatrix.html#method-i-rank","(shape_idx, rank_idx, meth = :copy)","<p>Returns the rank (e.g., row, column, or layer) specified, using slicing by\ncopy as default.\n<p>See @row (dimension …\n"],["rank","NMatrix","NMatrix.html#method-i-rank","(shape_idx, rank_idx, meth = :copy)","<p>Returns the rank (e.g., row, column, or layer) specified, using slicing by\ncopy as default.\n<p>See @row (dimension …\n"],["read","NMatrix","NMatrix.html#method-c-read","(p1, p2 = v2)","<p>Binary file reader for NMatrix standard format. file should be a path,\nwhich we aren&#39;t going to check …\n"],["read","NMatrix","NMatrix.html#method-c-read","(p1, p2 = v2)","<p>Binary file reader for NMatrix standard format. file should be a path,\nwhich we aren&#39;t going to check …\n"],["reduce_along_dim","NMatrix","NMatrix.html#method-i-reduce_along_dim","(dimen=0, initial=nil, dtype=nil)",""],["reduce_along_dim","NMatrix","NMatrix.html#method-i-reduce_along_dim","(dimen=0, initial=nil, dtype=nil)",""],["register_lapack_extension","NMatrix","NMatrix.html#method-c-register_lapack_extension","(name)",""],["register_lapack_extension","NMatrix","NMatrix.html#method-c-register_lapack_extension","(name)",""],["repack","NMatrix::IO::Matlab","NMatrix/IO/Matlab.html#method-c-repack","(p1, p2, p3)","<p>Take a string of bytes which represent MATLAB data type values and repack\nthem into a string of bytes …\n"],["repeat","NMatrix","NMatrix.html#method-i-repeat","(count, axis)","<p><strong>Arguments</strong> :\n<p><code>count</code> -&gt; how many times NMatrix should be repeated\n<p><code>axis</code> -&gt; index of axis along which …\n"],["repeat","NMatrix","NMatrix.html#method-i-repeat","(count, axis)","<p><strong>Arguments</strong> :\n<p><code>count</code> -&gt; how many times NMatrix should be repeated\n<p><code>axis</code> -&gt; index of axis along which …\n"],["reshape","NMatrix","NMatrix.html#method-i-reshape","(new_shape,*shapes)","<p>Clone a matrix, changing the shape in the process. Note that this function\ndoes not do a resize; the …\n"],["reshape","NMatrix","NMatrix.html#method-i-reshape","(new_shape,*shapes)","<p>Clone a matrix, changing the shape in the process. Note that this function\ndoes not do a resize; the …\n"],["reshape!","NMatrix","NMatrix.html#method-i-reshape-21","(new_shape,*shapes)","<p>Reshapes the matrix (in-place) to the desired shape. Note that this\nfunction does not do a resize; the …\n"],["reshape!","NMatrix","NMatrix.html#method-i-reshape-21","(new_shape,*shapes)","<p>Reshapes the matrix (in-place) to the desired shape. Note that this\nfunction does not do a resize; the …\n"],["rot","NMatrix::BLAS","NMatrix/BLAS.html#method-c-rot","(x, y, c, s, incx = 1, incy = 1, n = nil, in_place=false)","<p>Apply plane rotation.\n<p><strong>Arguments</strong> :\n<p><code>x</code> -&gt; NMatrix\n"],["rot!","NMatrix::BLAS","NMatrix/BLAS.html#method-c-rot-21","(x, y, c, s, incx = 1, incy = 1, n = nil)","<p>Apply plane rotation directly to <code>x</code> and <code>y</code>.\n<p>See rot for arguments.\n"],["rotg","NMatrix::BLAS","NMatrix/BLAS.html#method-c-rotg","(ab)","<p>Apply givens plane rotation to the coordinates (a,b), returning the cosine\nand sine of the angle theta. …\n"],["round","NMatrix","NMatrix.html#method-i-round","(*args)",""],["round","NMatrix","NMatrix.html#method-i-round","(*args)",""],["row","NMatrix","NMatrix.html#method-i-row","(row_number, get_by = :copy)","<p><strong>Arguments</strong> :\n<p><code>row_number</code> -&gt; Integer.\n<p><code>get_by</code> -&gt; Type of slicing to use, <code>:copy</code> or\n<code>:reference</code>.\n"],["row","NMatrix","NMatrix.html#method-i-row","(row_number, get_by = :copy)","<p><strong>Arguments</strong> :\n<p><code>row_number</code> -&gt; Integer.\n<p><code>get_by</code> -&gt; Type of slicing to use, <code>:copy</code> or\n<code>:reference</code>.\n"],["rows","NMatrix","NMatrix.html#method-i-rows","()","<p>This shortcut use #shape to return the number of rows (the first dimension)\nof the matrix.\n"],["rows","NMatrix","NMatrix.html#method-i-rows","()","<p>This shortcut use #shape to return the number of rows (the first dimension)\nof the matrix.\n"],["save","NMatrix::IO::Market","NMatrix/IO/Market.html#method-c-save","(matrix, filename, options = {})","<p>Can optionally set :symmetry to :general, :symmetric, :hermitian; and can\nset :pattern =&gt; true if …\n"],["save_array","NMatrix::IO::Market","NMatrix/IO/Market.html#method-c-save_array","(matrix, file, symmetry)",""],["save_coordinate","NMatrix::IO::Market","NMatrix/IO/Market.html#method-c-save_coordinate","(matrix, file, symmetry, pattern)",""],["seq","NMatrix","NMatrix.html#method-c-seq","(shape, options={})","<p>Creates a matrix filled with a sequence of integers starting at zero.\n<p><strong>Arguments</strong> :\n<p><code>shape</code> -&gt; Array (or …\n"],["seq","NMatrix","NMatrix.html#method-c-seq","(shape, options={})","<p>Creates a matrix filled with a sequence of integers starting at zero.\n<p><strong>Arguments</strong> :\n<p><code>shape</code> -&gt; Array (or …\n"],["shape","NMatrix","NMatrix.html#method-i-shape","()","<p>Get the shape (dimensions) of a matrix.\n"],["shape","NMatrix","NMatrix.html#method-i-shape","()","<p>Get the shape (dimensions) of a matrix.\n"],["shuffle","NMatrix","NMatrix.html#method-i-shuffle","(*args)","<p>Re-arranges the contents of an NVector.\n<p>TODO: Write more efficient version for Yale, list. TODO: Generalize …\n"],["shuffle","NMatrix","NMatrix.html#method-i-shuffle","(*args)","<p>Re-arranges the contents of an NVector.\n<p>TODO: Write more efficient version for Yale, list. TODO: Generalize …\n"],["shuffle!","NMatrix","NMatrix.html#method-i-shuffle-21","(*args)","<p>Re-arranges the contents of an NVector.\n<p>TODO: Write more efficient version for Yale, list. TODO: Generalize …\n"],["shuffle!","NMatrix","NMatrix.html#method-i-shuffle-21","(*args)","<p>Re-arranges the contents of an NVector.\n<p>TODO: Write more efficient version for Yale, list. TODO: Generalize …\n"],["size","NMatrix","NMatrix.html#method-c-size","(shape)","<p>Calculate the size of an NMatrix of a given shape.\n"],["size","NMatrix","NMatrix.html#method-i-size","()","<p>Returns the total size of the NMatrix based on its shape.\n"],["size","NMatrix","NMatrix.html#method-c-size","(shape)","<p>Calculate the size of an NMatrix of a given shape.\n"],["size","NMatrix","NMatrix.html#method-i-size","()","<p>Returns the total size of the NMatrix based on its shape.\n"],["slice","NMatrix","NMatrix.html#method-i-slice","(*args)","<p>Access the contents of an NMatrix at given coordinates, using copying.\n\n<pre>n.slice(3,3)  # =&gt; 5.0\nn.slice(0..1,0..1) ...</pre>\n"],["slice","NMatrix","NMatrix.html#method-i-slice","(*args)","<p>Access the contents of an NMatrix at given coordinates, using copying.\n\n<pre>n.slice(3,3)  # =&gt; 5.0\nn.slice(0..1,0..1) ...</pre>\n"],["solve","NMatrix","NMatrix.html#method-i-solve","(b)",""],["solve","NMatrix","NMatrix.html#method-i-solve","(b)",""],["sorted_indices","NMatrix","NMatrix.html#method-i-sorted_indices","()","<p>Returns an array of the indices ordered by value sorted.\n"],["sorted_indices","NMatrix","NMatrix.html#method-i-sorted_indices","()","<p>Returns an array of the indices ordered by value sorted.\n"],["std","NMatrix","NMatrix.html#method-i-std","(dimen=0)","<p>Calculates the sample standard deviation along the specified dimension.\n<p>This will force integer types …\n"],["std","NMatrix","NMatrix.html#method-i-std","(dimen=0)","<p>Calculates the sample standard deviation along the specified dimension.\n<p>This will force integer types …\n"],["stype","NMatrix","NMatrix.html#method-i-stype","()","<p>Get the storage type (stype) of a matrix, e.g., :yale, :dense, or :list.\n"],["stype","NMatrix","NMatrix.html#method-i-stype","()","<p>Get the storage type (stype) of a matrix, e.g., :yale, :dense, or :list.\n"],["sum","NMatrix","NMatrix.html#method-i-sum","(dimen=0)","<p>Calculates the sum along the specified dimension.\n<p>@see #inject_rank\n"],["sum","NMatrix","NMatrix.html#method-i-sum","(dimen=0)","<p>Calculates the sum along the specified dimension.\n<p>@see #inject_rank\n"],["supershape","NMatrix","NMatrix.html#method-i-supershape","()","<p>Get the shape of a slice&#39;s parent.\n"],["supershape","NMatrix","NMatrix.html#method-i-supershape","()","<p>Get the shape of a slice&#39;s parent.\n"],["symmetric?","NMatrix","NMatrix.html#method-i-symmetric-3F","()","<p>Is this matrix symmetric?\n"],["symmetric?","NMatrix","NMatrix.html#method-i-symmetric-3F","()","<p>Is this matrix symmetric?\n"],["to_a","NMatrix","NMatrix.html#method-i-to_a","(dimen=nil)","<p>Converts an NMatrix to an array of arrays, or an NMatrix of effective\ndimension 1 to an array.\n<p>Does not …\n"],["to_a","NMatrix","NMatrix.html#method-i-to_a","(dimen=nil)","<p>Converts an NMatrix to an array of arrays, or an NMatrix of effective\ndimension 1 to an array.\n<p>Does not …\n"],["to_f","NMatrix","NMatrix.html#method-i-to_f","()","<p>Converts an nmatrix with a single element (but any number of dimensions)\n\n<pre>to a float.</pre>\n<p>Raises an IndexError …\n"],["to_f","NMatrix","NMatrix.html#method-i-to_f","()","<p>Converts an nmatrix with a single element (but any number of dimensions)\n\n<pre>to a float.</pre>\n<p>Raises an IndexError …\n"],["to_flat_a","NMatrix","NMatrix.html#method-i-to_flat_a","()",""],["to_flat_a","NMatrix","NMatrix.html#method-i-to_flat_a","()",""],["to_flat_array","NMatrix","NMatrix.html#method-i-to_flat_array","()","<p>Converts an NMatrix to a one-dimensional Ruby Array.\n"],["to_flat_array","NMatrix","NMatrix.html#method-i-to_flat_array","()","<p>Converts an NMatrix to a one-dimensional Ruby Array.\n"],["to_h","NMatrix","NMatrix.html#method-i-to_h","()",""],["to_h","NMatrix","NMatrix.html#method-i-to_h","()",""],["to_hash","NMatrix","NMatrix.html#method-i-to_hash","()","<p>Create a Ruby Hash from an NMatrix.\n"],["to_hash","NMatrix","NMatrix.html#method-i-to_hash","()","<p>Create a Ruby Hash from an NMatrix.\n"],["to_nm","Array","Array.html#method-i-to_nm","(shape = nil, dtype = nil, stype = :dense)","<p>Convert a Ruby Array to an NMatrix.\n<p>You must provide a shape for the matrix as the first argument.\n<p>Arguments: …\n"],["trace","NMatrix","NMatrix.html#method-i-trace","()","<p>Calculates the trace of an nxn matrix.\n<p><strong>Raises</strong> :\n<p><code>ShapeError</code> -&gt; Expected square matrix\n"],["trace","NMatrix","NMatrix.html#method-i-trace","()","<p>Calculates the trace of an nxn matrix.\n<p><strong>Raises</strong> :\n<p><code>ShapeError</code> -&gt; Expected square matrix\n"],["translation","NMatrix","NMatrix.html#method-c-translation","(*args)","<p>Generate a 4x4 homogeneous transformation matrix representing a\ntranslation.\n<p><strong>Returns</strong> :\n<p>A homogeneous transformation …\n"],["translation","NMatrix","NMatrix.html#method-c-translation","(*args)","<p>Generate a 4x4 homogeneous transformation matrix representing a\ntranslation.\n<p><strong>Returns</strong> :\n<p>A homogeneous transformation …\n"],["transpose","NMatrix","NMatrix.html#method-i-transpose","(permute = nil)","<p>Clone a matrix, transposing it in the process. If the matrix is\ntwo-dimensional, the permutation is taken …\n"],["transpose","NMatrix","NMatrix.html#method-i-transpose","(permute = nil)","<p>Clone a matrix, transposing it in the process. If the matrix is\ntwo-dimensional, the permutation is taken …\n"],["tril","NMatrix","NMatrix.html#method-i-tril","(k = 0)",""],["tril","NMatrix","NMatrix.html#method-i-tril","(k = 0)",""],["tril!","NMatrix","NMatrix.html#method-i-tril-21","(k = 0)",""],["tril!","NMatrix","NMatrix.html#method-i-tril-21","(k = 0)",""],["triu","NMatrix","NMatrix.html#method-i-triu","(k = 0)",""],["triu","NMatrix","NMatrix.html#method-i-triu","(k = 0)",""],["triu!","NMatrix","NMatrix.html#method-i-triu-21","(k = 0)",""],["triu!","NMatrix","NMatrix.html#method-i-triu-21","(k = 0)",""],["underscore","String","String.html#method-i-underscore","()",""],["upcast","NMatrix","NMatrix.html#method-c-upcast","(p1, p2)","<p>Given a binary operation between types t1 and t2, what type will be\nreturned?\n<p>This is a singleton method …\n"],["upcast","NMatrix","NMatrix.html#method-c-upcast","(p1, p2)","<p>Given a binary operation between types t1 and t2, what type will be\nreturned?\n<p>This is a singleton method …\n"],["upper_triangle","NMatrix","NMatrix.html#method-i-upper_triangle","(k = 0)","<p>Returns the upper triangular portion of a matrix. This is analogous to the\n<code>triu</code> method in MATLAB.\n<p><strong>Arguments</strong> …\n"],["upper_triangle","NMatrix","NMatrix.html#method-i-upper_triangle","(k = 0)","<p>Returns the upper triangular portion of a matrix. This is analogous to the\n<code>triu</code> method in MATLAB.\n<p><strong>Arguments</strong> …\n"],["upper_triangle!","NMatrix","NMatrix.html#method-i-upper_triangle-21","(k = 0)","<p>Deletes the lower triangular portion of the matrix (in-place) so only the\nupper portion remains.\n<p><strong>Arguments</strong> …\n"],["upper_triangle!","NMatrix","NMatrix.html#method-i-upper_triangle-21","(k = 0)","<p>Deletes the lower triangular portion of the matrix (in-place) so only the\nupper portion remains.\n<p><strong>Arguments</strong> …\n"],["values","NMatrix::IO::HarwellBoeing::Reader","NMatrix/IO/HarwellBoeing/Reader.html#method-i-values","()",""],["variance","NMatrix","NMatrix.html#method-i-variance","(dimen=0)","<p>Calculates the sample variance along the specified dimension.\n<p>This will force integer types to float64 …\n"],["variance","NMatrix","NMatrix.html#method-i-variance","(dimen=0)","<p>Calculates the sample variance along the specified dimension.\n<p>This will force integer types to float64 …\n"],["vconcat","NMatrix","NMatrix.html#method-i-vconcat","(*matrices)","<p>Vertical concatenation with <code>matrices</code>.\n"],["vconcat","NMatrix","NMatrix.html#method-i-vconcat","(*matrices)","<p>Vertical concatenation with <code>matrices</code>.\n"],["vector?","NMatrix","NMatrix.html#method-i-vector-3F","()","<p>Shortcut function for determining whether the effective dimension is 1. See\nalso #nvector?\n"],["vector?","NMatrix","NMatrix.html#method-i-vector-3F","()","<p>Shortcut function for determining whether the effective dimension is 1. See\nalso #nvector?\n"],["write","NMatrix","NMatrix.html#method-i-write","(*args)","<p>Binary file writer for NMatrix standard format. file should be a path,\nwhich we aren&#39;t going to check …\n"],["write","NMatrix","NMatrix.html#method-i-write","(*args)","<p>Binary file writer for NMatrix standard format. file should be a path,\nwhich we aren&#39;t going to check …\n"],["x_rotation","NMatrix","NMatrix.html#method-c-x_rotation","(angle_in_radians, opts={})","<p>Generate a 4x4 homogeneous transformation matrix representing a rotation\nabout the x, y, or z axis respectively. …\n"],["x_rotation","NMatrix","NMatrix.html#method-c-x_rotation","(angle_in_radians, opts={})","<p>Generate a 4x4 homogeneous transformation matrix representing a rotation\nabout the x, y, or z axis respectively. …\n"],["y_rotation","NMatrix","NMatrix.html#method-c-y_rotation","(angle_in_radians, opts={})",""],["y_rotation","NMatrix","NMatrix.html#method-c-y_rotation","(angle_in_radians, opts={})",""],["yale?","NMatrix","NMatrix.html#method-i-yale-3F","()","<p>Determine if <code>m</code> is a Yale matrix.\n"],["yale?","NMatrix","NMatrix.html#method-i-yale-3F","()","<p>Determine if <code>m</code> is a Yale matrix.\n"],["yale_a","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_a","(p1 = v1)","<p>Get the A array of a Yale matrix (which stores the diagonal and the LU\nportions of the matrix).\n"],["yale_d","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_d","(p1 = v1)","<p>Get the diagonal (“D”) portion of the A array of a Yale matrix.\n"],["yale_ia","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_ia","()","<p>Get the IA portion of the IJA array of a Yale matrix. This gives the start\nand end positions of rows …\n"],["yale_ija","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_ija","(p1 = v1)","<p>Get the IJA array of a Yale matrix (or a component of the IJA array).\n"],["yale_ja","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_ja","()","<p>Get the JA portion of the IJA array of a Yale matrix. This gives the column\nindices for entries in corresponding …\n"],["yale_ja_at","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_ja_at","(i)","<p>Returns the non-diagonal column indices which are stored in a given row.\n"],["yale_ja_d_keys_at","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_ja_d_keys_at","(i)","<p>Returns the diagonal and non-digonal column indices stored in a given row.\n"],["yale_ja_d_keys_set_at","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_ja_d_keys_set_at","(i)","<p>Returns the diagonal and non-diagonal column indices stored in a given row.\n"],["yale_ja_d_keys_sorted_set_at","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_ja_d_keys_sorted_set_at","(i)","<p>Returns the diagonal and non-diagonal column indices stored in a given row.\n"],["yale_ja_set_at","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_ja_set_at","(i)","<p>Returns the non-diagonal column indices which are stored in a given row, as\na Set.\n"],["yale_ja_sorted_set_at","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_ja_sorted_set_at","(i)","<p>Returns the non-diagonal column indices which are stored in a given row, as\na Set.\n"],["yale_lu","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_lu","()","<p>Get the non-diagonal (“LU”) portion of the A array of a Yale matrix.\n"],["yale_nd_row","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_nd_row","(p1, p2 = v2)","<p>This function gets the non-diagonal contents of a Yale matrix row. The\nfirst argument should be the row …\n"],["yale_nd_row_as_array","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_nd_row_as_array","(i)",""],["yale_nd_row_as_hash","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_nd_row_as_hash","(i)","<p>Returns the non-diagonal column indices and entries stored in a given row.\n"],["yale_nd_row_as_set","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_nd_row_as_set","(i)",""],["yale_nd_row_as_sorted_set","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_nd_row_as_sorted_set","(i)",""],["yale_nd_row_size","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_nd_row_size","(i)","<p>Returns the size of a given non-diagonal row.\n"],["yale_row_as_array","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_row_as_array","(i)",""],["yale_row_as_hash","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_row_as_hash","(i)","<p>Returns the diagonal and non-diagonal column indices and entries stored in\na given row.\n"],["yale_row_as_set","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_row_as_set","(i)",""],["yale_row_as_sorted_set","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_row_as_sorted_set","(i)",""],["yale_row_keys_intersection","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_row_keys_intersection","(p1, p2, p3)","<p>This function is experimental.\n<p>It finds the intersection of row i of the current matrix with row i2 of …\n"],["yale_size","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_size","()","<p>Get the size of a Yale matrix (the number of elements actually stored).\n<p>For capacity (the maximum number …\n"],["z_rotation","NMatrix","NMatrix.html#method-c-z_rotation","(angle_in_radians, opts={})",""],["z_rotation","NMatrix","NMatrix.html#method-c-z_rotation","(angle_in_radians, opts={})",""],["zeroes","NMatrix","NMatrix.html#method-c-zeroes","(shape, opts = {})",""],["zeroes","NMatrix","NMatrix.html#method-c-zeroes","(shape, opts = {})",""],["zeros","NMatrix","NMatrix.html#method-c-zeros","(shape, opts = {})","<p>Creates a new matrix of zeros with the dimensions supplied as parameters.\n<p><strong>Arguments</strong> :\n<p><code>shape</code> -&gt; Array …\n"],["zeros","NMatrix","NMatrix.html#method-c-zeros","(shape, opts = {})","<p>Creates a new matrix of zeros with the dimensions supplied as parameters.\n<p><strong>Arguments</strong> :\n<p><code>shape</code> -&gt; Array …\n"],["zeros_like","NMatrix","NMatrix.html#method-c-zeros_like","(nm)","<p>Creates a new matrix of zeros with the same stype, dtype, and shape as the\nprovided matrix.\n<p>@param [NMatrix] …\n"],["zeros_like","NMatrix","NMatrix.html#method-c-zeros_like","(nm)","<p>Creates a new matrix of zeros with the same stype, dtype, and shape as the\nprovided matrix.\n<p>@param [NMatrix] …\n"],["CONTRIBUTING","","CONTRIBUTING_md.html","","<p>NMatrix is part of SciRuby, a collaborative effort to bring scientific\ncomputation to Ruby. If you want …\n"],["History","","History_txt.html","","<p>0.0.1 / 2012-04-10\n<p>1 major enhancement\n<p>Initial alpha release\n"],["LICENSE","","LICENSE_txt.html","","<p>This version of NMatrix is licensed under the BSD 2-clause license.\n<p>sciruby.com\n<p>github.com/sciruby/sciruby/wiki/License …\n"],["README","","README_rdoc.html","","<p>NMatrix\n<p>Fast Numerical Linear Algebra Library for Ruby\n<p>sciruby.com\n"],["binary_format","","ext/nmatrix/binary_format_txt.html","","<p>This is the proposed binary format for saving and loading NMatrix objects.\n<p>Order is little-endian.\n<p>List …\n"]]}}