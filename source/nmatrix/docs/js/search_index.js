var search_data = {"index":{"searchIndex":["array","datatypeerror","n","n","blas","io","market","matlab","pointcloud","lapack","yalefunctions","nvector","notinvertibleerror","object","shapeerror","storagetypeerror","unknown","==()","==()","[]()","[]()","[]()","[]=()","[]=()","[]=()","abs()","abs()","abs_dtype()","abs_dtype()","absolute_sum()","absolute_sum()","alloc_evd_result()","alloc_svd_result()","asum()","asum()","asum()","binned_sorted_indices()","binned_sorted_indices()","capacity()","capacity()","cast()","cast()","cast_full()","cast_full()","clapack_gesv()","clapack_posv()","clone_structure()","clone_structure()","col()","col()","cols()","cols()","column()","column()","complex_conjugate()","complex_conjugate()","complex_conjugate!()","complex_conjugate!()","complex_merge()","concat()","concat()","conjugate_transpose()","conjugate_transpose()","data_pointer()","data_pointer()","dconcat()","dconcat()","default_value()","default_value()","dense?()","dense?()","det()","det()","det_exact()","det_exact()","diagonal()","diagonal()","dim()","dim()","dim()","dimensions()","dimensions()","dot()","dot()","dtype()","dtype()","dtype_for_floor_or_ceil()","dtype_for_floor_or_ceil()","each()","each()","each_along_dim()","each_along_dim()","each_column()","each_column()","each_layer()","each_layer()","each_ordered_stored_with_indices()","each_ordered_stored_with_indices()","each_rank()","each_rank()","each_row()","each_row()","each_stored_with_index()","each_stored_with_index()","each_stored_with_indices()","each_stored_with_indices()","each_with_indices()","each_with_indices()","effective_dim()","effective_dim()","effective_dimensions()","effective_dimensions()","eye()","eye()","factorize_cholesky()","factorize_cholesky()","factorize_lu()","factorize_lu()","flat_map()","flat_map()","geev()","gemm()","gemv()","gesdd()","gesdd()","gesdd()","gesdd!()","gesdd!()","gesvd()","gesvd()","gesvd()","gesvd!()","gesvd!()","getrf()","getrf()","getrf!()","getrf!()","guess_dtype()","guess_dtype()","hconcat()","hconcat()","hermitian?()","hermitian?()","initialize_copy()","initialize_copy()","inject_along_dim()","inject_along_dim()","inject_rank()","inject_rank()","integer_dtype?()","integer_dtype?()","inverse()","inverse()","invert()","invert()","invert!()","invert!()","is_ref?()","is_ref?()","laswp()","laswp()","laswp()","laswp!()","laswp!()","layer()","layer()","list?()","list?()","load()","load()","load_array()","load_coordinate()","load_mat()","load_matlab_file()","load_matlab_file()","load_pcd_file()","load_pcd_file()","log()","log()","lower_triangle()","lower_triangle()","lower_triangle!()","lower_triangle!()","map()","map()","map!()","map!()","map_stored()","map_stored()","max()","max()","max()","mean()","mean()","min()","min()","min()","min_dtype()","min_dtype()","new()","new()","new()","norm2()","norm2()","nrm2()","nrm2()","nrm2()","nvector?()","nvector?()","offset()","offset()","ones()","ones()","ones_like()","ones_like()","orientation()","permute_columns()","permute_columns()","permute_columns!()","permute_columns!()","potrf!()","potrf!()","potrf_lower!()","potrf_lower!()","potrf_upper!()","potrf_upper!()","random()","random()","rank()","rank()","read()","read()","reduce_along_dim()","reduce_along_dim()","repack()","reshape()","reshape()","reshape!()","reshape!()","rot()","rot!()","rotg()","row()","row()","rows()","rows()","save()","save_array()","save_coordinate()","seq()","seq()","shape()","shape()","shuffle()","shuffle()","shuffle!()","shuffle!()","size()","size()","size()","slice()","slice()","sorted_indices()","sorted_indices()","std()","std()","stype()","stype()","sum()","sum()","supershape()","supershape()","symmetric?()","symmetric?()","to_a()","to_a()","to_f()","to_f()","to_flat_a()","to_flat_a()","to_flat_array()","to_flat_array()","to_h()","to_h()","to_hash()","to_hash()","to_nm()","transpose()","transpose()","tril()","tril()","tril!()","tril!()","triu()","triu()","triu!()","triu!()","upcast()","upcast()","upper_triangle()","upper_triangle()","upper_triangle!()","upper_triangle!()","variance()","variance()","vconcat()","vconcat()","vector?()","vector?()","write()","write()","yale?()","yale?()","yale_a()","yale_d()","yale_ia()","yale_ija()","yale_ja()","yale_ja_at()","yale_ja_d_keys_at()","yale_ja_d_keys_set_at()","yale_ja_d_keys_sorted_set_at()","yale_ja_set_at()","yale_ja_sorted_set_at()","yale_lu()","yale_nd_row()","yale_nd_row_as_array()","yale_nd_row_as_hash()","yale_nd_row_as_set()","yale_nd_row_as_sorted_set()","yale_nd_row_size()","yale_row_as_array()","yale_row_as_hash()","yale_row_as_set()","yale_row_as_sorted_set()","yale_row_keys_intersection()","yale_size()","zeros()","zeros()","zeros_like()","zeros_like()","contributing","history","license","readme","binary_format"],"longSearchIndex":["array","datatypeerror","n","nmatrix","nmatrix::blas","nmatrix::io","nmatrix::io::market","nmatrix::io::matlab","nmatrix::io::pointcloud","nmatrix::lapack","nmatrix::yalefunctions","nvector","notinvertibleerror","object","shapeerror","storagetypeerror","unknown","nmatrix#==()","nmatrix#==()","nmatrix#[]()","nmatrix#[]()","nvector#[]()","nmatrix#[]=()","nmatrix#[]=()","nvector#[]=()","nmatrix#abs()","nmatrix#abs()","nmatrix#abs_dtype()","nmatrix#abs_dtype()","nmatrix#absolute_sum()","nmatrix#absolute_sum()","nmatrix::lapack#alloc_evd_result()","nmatrix::lapack#alloc_svd_result()","nmatrix#asum()","nmatrix#asum()","nmatrix::blas#asum()","nmatrix#binned_sorted_indices()","nmatrix#binned_sorted_indices()","nmatrix#capacity()","nmatrix#capacity()","nmatrix#cast()","nmatrix#cast()","nmatrix#cast_full()","nmatrix#cast_full()","nmatrix::lapack#clapack_gesv()","nmatrix::lapack#clapack_posv()","nmatrix#clone_structure()","nmatrix#clone_structure()","nmatrix#col()","nmatrix#col()","nmatrix#cols()","nmatrix#cols()","nmatrix#column()","nmatrix#column()","nmatrix#complex_conjugate()","nmatrix#complex_conjugate()","nmatrix#complex_conjugate!()","nmatrix#complex_conjugate!()","nmatrix::io::matlab::complex_merge()","nmatrix#concat()","nmatrix#concat()","nmatrix#conjugate_transpose()","nmatrix#conjugate_transpose()","nmatrix#data_pointer()","nmatrix#data_pointer()","nmatrix#dconcat()","nmatrix#dconcat()","nmatrix#default_value()","nmatrix#default_value()","nmatrix#dense?()","nmatrix#dense?()","nmatrix#det()","nmatrix#det()","nmatrix#det_exact()","nmatrix#det_exact()","nmatrix#diagonal()","nmatrix#diagonal()","nmatrix#dim()","nmatrix#dim()","nvector#dim()","nmatrix#dimensions()","nmatrix#dimensions()","nmatrix#dot()","nmatrix#dot()","nmatrix#dtype()","nmatrix#dtype()","nmatrix#dtype_for_floor_or_ceil()","nmatrix#dtype_for_floor_or_ceil()","nmatrix#each()","nmatrix#each()","nmatrix#each_along_dim()","nmatrix#each_along_dim()","nmatrix#each_column()","nmatrix#each_column()","nmatrix#each_layer()","nmatrix#each_layer()","nmatrix#each_ordered_stored_with_indices()","nmatrix#each_ordered_stored_with_indices()","nmatrix#each_rank()","nmatrix#each_rank()","nmatrix#each_row()","nmatrix#each_row()","nmatrix#each_stored_with_index()","nmatrix#each_stored_with_index()","nmatrix#each_stored_with_indices()","nmatrix#each_stored_with_indices()","nmatrix#each_with_indices()","nmatrix#each_with_indices()","nmatrix#effective_dim()","nmatrix#effective_dim()","nmatrix#effective_dimensions()","nmatrix#effective_dimensions()","nmatrix#eye()","nmatrix#eye()","nmatrix#factorize_cholesky()","nmatrix#factorize_cholesky()","nmatrix#factorize_lu()","nmatrix#factorize_lu()","nmatrix#flat_map()","nmatrix#flat_map()","nmatrix::lapack#geev()","nmatrix::blas#gemm()","nmatrix::blas#gemv()","nmatrix#gesdd()","nmatrix#gesdd()","nmatrix::lapack#gesdd()","nmatrix#gesdd!()","nmatrix#gesdd!()","nmatrix#gesvd()","nmatrix#gesvd()","nmatrix::lapack#gesvd()","nmatrix#gesvd!()","nmatrix#gesvd!()","nmatrix#getrf()","nmatrix#getrf()","nmatrix#getrf!()","nmatrix#getrf!()","nmatrix::guess_dtype()","nmatrix::guess_dtype()","nmatrix#hconcat()","nmatrix#hconcat()","nmatrix#hermitian?()","nmatrix#hermitian?()","nmatrix#initialize_copy()","nmatrix#initialize_copy()","nmatrix#inject_along_dim()","nmatrix#inject_along_dim()","nmatrix#inject_rank()","nmatrix#inject_rank()","nmatrix#integer_dtype?()","nmatrix#integer_dtype?()","nmatrix#inverse()","nmatrix#inverse()","nmatrix#invert()","nmatrix#invert()","nmatrix#invert!()","nmatrix#invert!()","nmatrix#is_ref?()","nmatrix#is_ref?()","nmatrix#laswp()","nmatrix#laswp()","nmatrix::lapack#laswp()","nmatrix#laswp!()","nmatrix#laswp!()","nmatrix#layer()","nmatrix#layer()","nmatrix#list?()","nmatrix#list?()","nmatrix::io::market#load()","nmatrix::io::pointcloud#load()","nmatrix::io::market#load_array()","nmatrix::io::market#load_coordinate()","nmatrix::io::matlab#load_mat()","nmatrix#load_matlab_file()","nmatrix#load_matlab_file()","nmatrix#load_pcd_file()","nmatrix#load_pcd_file()","nmatrix#log()","nmatrix#log()","nmatrix#lower_triangle()","nmatrix#lower_triangle()","nmatrix#lower_triangle!()","nmatrix#lower_triangle!()","nmatrix#map()","nmatrix#map()","nmatrix#map!()","nmatrix#map!()","nmatrix#map_stored()","nmatrix#map_stored()","nmatrix#max()","nmatrix#max()","nvector#max()","nmatrix#mean()","nmatrix#mean()","nmatrix#min()","nmatrix#min()","nvector#min()","nmatrix::min_dtype()","nmatrix::min_dtype()","nmatrix::new()","nmatrix::new()","nvector::new()","nmatrix#norm2()","nmatrix#norm2()","nmatrix#nrm2()","nmatrix#nrm2()","nmatrix::blas#nrm2()","nmatrix#nvector?()","nmatrix#nvector?()","nmatrix#offset()","nmatrix#offset()","nmatrix#ones()","nmatrix#ones()","nmatrix#ones_like()","nmatrix#ones_like()","nvector#orientation()","nmatrix#permute_columns()","nmatrix#permute_columns()","nmatrix#permute_columns!()","nmatrix#permute_columns!()","nmatrix#potrf!()","nmatrix#potrf!()","nmatrix#potrf_lower!()","nmatrix#potrf_lower!()","nmatrix#potrf_upper!()","nmatrix#potrf_upper!()","nmatrix#random()","nmatrix#random()","nmatrix#rank()","nmatrix#rank()","nmatrix::read()","nmatrix::read()","nmatrix#reduce_along_dim()","nmatrix#reduce_along_dim()","nmatrix::io::matlab::repack()","nmatrix#reshape()","nmatrix#reshape()","nmatrix#reshape!()","nmatrix#reshape!()","nmatrix::blas#rot()","nmatrix::blas#rot!()","nmatrix::blas#rotg()","nmatrix#row()","nmatrix#row()","nmatrix#rows()","nmatrix#rows()","nmatrix::io::market#save()","nmatrix::io::market#save_array()","nmatrix::io::market#save_coordinate()","nmatrix#seq()","nmatrix#seq()","nmatrix#shape()","nmatrix#shape()","nmatrix#shuffle()","nmatrix#shuffle()","nmatrix#shuffle!()","nmatrix#shuffle!()","nmatrix#size()","nmatrix#size()","nvector#size()","nmatrix#slice()","nmatrix#slice()","nmatrix#sorted_indices()","nmatrix#sorted_indices()","nmatrix#std()","nmatrix#std()","nmatrix#stype()","nmatrix#stype()","nmatrix#sum()","nmatrix#sum()","nmatrix#supershape()","nmatrix#supershape()","nmatrix#symmetric?()","nmatrix#symmetric?()","nmatrix#to_a()","nmatrix#to_a()","nmatrix#to_f()","nmatrix#to_f()","nmatrix#to_flat_a()","nmatrix#to_flat_a()","nmatrix#to_flat_array()","nmatrix#to_flat_array()","nmatrix#to_h()","nmatrix#to_h()","nmatrix#to_hash()","nmatrix#to_hash()","array#to_nm()","nmatrix#transpose()","nmatrix#transpose()","nmatrix#tril()","nmatrix#tril()","nmatrix#tril!()","nmatrix#tril!()","nmatrix#triu()","nmatrix#triu()","nmatrix#triu!()","nmatrix#triu!()","nmatrix::upcast()","nmatrix::upcast()","nmatrix#upper_triangle()","nmatrix#upper_triangle()","nmatrix#upper_triangle!()","nmatrix#upper_triangle!()","nmatrix#variance()","nmatrix#variance()","nmatrix#vconcat()","nmatrix#vconcat()","nmatrix#vector?()","nmatrix#vector?()","nmatrix#write()","nmatrix#write()","nmatrix#yale?()","nmatrix#yale?()","nmatrix::yalefunctions#yale_a()","nmatrix::yalefunctions#yale_d()","nmatrix::yalefunctions#yale_ia()","nmatrix::yalefunctions#yale_ija()","nmatrix::yalefunctions#yale_ja()","nmatrix::yalefunctions#yale_ja_at()","nmatrix::yalefunctions#yale_ja_d_keys_at()","nmatrix::yalefunctions#yale_ja_d_keys_set_at()","nmatrix::yalefunctions#yale_ja_d_keys_sorted_set_at()","nmatrix::yalefunctions#yale_ja_set_at()","nmatrix::yalefunctions#yale_ja_sorted_set_at()","nmatrix::yalefunctions#yale_lu()","nmatrix::yalefunctions#yale_nd_row()","nmatrix::yalefunctions#yale_nd_row_as_array()","nmatrix::yalefunctions#yale_nd_row_as_hash()","nmatrix::yalefunctions#yale_nd_row_as_set()","nmatrix::yalefunctions#yale_nd_row_as_sorted_set()","nmatrix::yalefunctions#yale_nd_row_size()","nmatrix::yalefunctions#yale_row_as_array()","nmatrix::yalefunctions#yale_row_as_hash()","nmatrix::yalefunctions#yale_row_as_set()","nmatrix::yalefunctions#yale_row_as_sorted_set()","nmatrix::yalefunctions#yale_row_keys_intersection()","nmatrix::yalefunctions#yale_size()","nmatrix#zeros()","nmatrix#zeros()","nmatrix#zeros_like()","nmatrix#zeros_like()","","","","",""],"info":[["Array","","Array.html","","<p>Classes and Modules #\n"],["DataTypeError","","DataTypeError.html","","<p>Exception raised when there&#39;s a problem with data.\n"],["N","","N.html","","<p>NMatrix is a multidimensional array with support to both dense and sparse\nstorage and 13 data types, …\n"],["NMatrix","","NMatrix.html","","<p>NMatrix is a multidimensional array with support to both dense and sparse\nstorage and 13 data types, …\n"],["NMatrix::BLAS","","NMatrix/BLAS.html","",""],["NMatrix::IO","","NMatrix/IO.html","","<p>Read and write extensions for NMatrix.\n"],["NMatrix::IO::Market","","NMatrix/IO/Market.html","","<p>Matrix Market is a repository of test data for use in studies of algorithms\nfor numerical linear algebra. …\n"],["NMatrix::IO::Matlab","","NMatrix/IO/Matlab.html","","<p>Reader (and eventually writer) of Matlab .mat files.\n<p>The .mat file format is documented in the following …\n"],["NMatrix::IO::PointCloud","","NMatrix/IO/PointCloud.html","","<p>Reader for Point Cloud Data (PCD) file format.\n<p>The documentation of this format can be found in:\n<p>pointclouds.org/documentation/tutorials/pcd_file_format.php …\n"],["NMatrix::LAPACK","","NMatrix/LAPACK.html","",""],["NMatrix::YaleFunctions","","NMatrix/YaleFunctions.html","","<p>This module stores methods that are useful for debugging Yale matrices,\ni.e. the ones with <code>:yale</code> stype. …\n"],["NVector","","NVector.html","","<p>This is a specific type of NMatrix in which only one dimension is not 1.\nAlthough it is stored as a dim-2, …\n"],["NotInvertibleError","","NotInvertibleError.html","","<p>Exception raise when an inverse is requested but the matrix is not\ninvertible.\n"],["Object","","Object.html","",""],["ShapeError","","ShapeError.html","","<p>Exception raise when the matrix shape is not appropriate for a given\noperation.\n"],["StorageTypeError","","StorageTypeError.html","","<p>Exception raised when something goes wrong with the storage of a matrix.\n"],["unknown","","unknown.html","",""],["==","NMatrix","NMatrix.html#method-i-3D-3D","(p1)","<p>Equality operator. Returns a single true or false value indicating whether\nthe matrices are equivalent. …\n"],["==","NMatrix","NMatrix.html#method-i-3D-3D","(p1)","<p>Equality operator. Returns a single true or false value indicating whether\nthe matrices are equivalent. …\n"],["[]","NMatrix","NMatrix.html#method-i-5B-5D","(*args)","<p>Access the contents of an NMatrix at given coordinates by reference.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">n</span>[<span class=\"ruby-value\">3</span>,<span class=\"ruby-value\">3</span>]  <span class=\"ruby-comment\"># =&gt; 5.0</span>\n<span class=\"ruby-identifier\">n</span>[<span class=\"ruby-value\">0</span><span class=\"ruby-operator\">..</span><span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">0</span><span class=\"ruby-operator\">..</span><span class=\"ruby-value\">1</span>] <span class=\"ruby-comment\">#=&gt; ...</span>\n</pre>\n"],["[]","NMatrix","NMatrix.html#method-i-5B-5D","(*args)","<p>Access the contents of an NMatrix at given coordinates by reference.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">n</span>[<span class=\"ruby-value\">3</span>,<span class=\"ruby-value\">3</span>]  <span class=\"ruby-comment\"># =&gt; 5.0</span>\n<span class=\"ruby-identifier\">n</span>[<span class=\"ruby-value\">0</span><span class=\"ruby-operator\">..</span><span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">0</span><span class=\"ruby-operator\">..</span><span class=\"ruby-value\">1</span>] <span class=\"ruby-comment\">#=&gt; ...</span>\n</pre>\n"],["[]","NVector","NVector.html#method-i-5B-5D","(i)","<p>Retrieves an element or return a slice.\n<p>Examples:\n\n<pre>u = NVector.new(3, [10, 20, 30])\nu[0]              # ...</pre>\n"],["[]=","NMatrix","NMatrix.html#method-i-5B-5D-3D","(*args)","<p>Modify the contents of an NMatrix in the given cell\n\n<pre>n[3,3] = 5.0</pre>\n<p>Also returns the new contents, so you …\n"],["[]=","NMatrix","NMatrix.html#method-i-5B-5D-3D","(*args)","<p>Modify the contents of an NMatrix in the given cell\n\n<pre>n[3,3] = 5.0</pre>\n<p>Also returns the new contents, so you …\n"],["[]=","NVector","NVector.html#method-i-5B-5D-3D","(i, val)","<p>Stores <code>value</code> at position <code>index</code>.\n"],["abs","NMatrix","NMatrix.html#method-i-abs","()","<p>Maps all values in a matrix to their absolute values.\n"],["abs","NMatrix","NMatrix.html#method-i-abs","()","<p>Maps all values in a matrix to their absolute values.\n"],["abs_dtype","NMatrix","NMatrix.html#method-i-abs_dtype","()","<p>Returns the dtype of the result of a call to #abs. In most cases, this is\nthe same as dtype; it should …\n"],["abs_dtype","NMatrix","NMatrix.html#method-i-abs_dtype","()","<p>Returns the dtype of the result of a call to #abs. In most cases, this is\nthe same as dtype; it should …\n"],["absolute_sum","NMatrix","NMatrix.html#method-i-absolute_sum","(incx=1, n=nil)",""],["absolute_sum","NMatrix","NMatrix.html#method-i-absolute_sum","(incx=1, n=nil)",""],["alloc_evd_result","NMatrix::LAPACK","NMatrix/LAPACK.html#method-i-alloc_evd_result","(matrix)",""],["alloc_svd_result","NMatrix::LAPACK","NMatrix/LAPACK.html#method-i-alloc_svd_result","(matrix)",""],["asum","NMatrix","NMatrix.html#method-i-asum","(incx=1, n=nil)","<p>Arguments\n\n<pre>- +incx+ -&gt; the skip size (defaults to 1, no skip)\n- +n+ -&gt; the number of elements to include</pre>\n"],["asum","NMatrix","NMatrix.html#method-i-asum","(incx=1, n=nil)","<p>Arguments\n\n<pre>- +incx+ -&gt; the skip size (defaults to 1, no skip)\n- +n+ -&gt; the number of elements to include</pre>\n"],["asum","NMatrix::BLAS","NMatrix/BLAS.html#method-i-asum","(x, incx = 1, n = nil)","<p>Calculate the sum of absolute values of the entries of a vector\n<code>x</code> of size <code>n</code>\n<p><strong>Arguments</strong> :\n<p><code>x</code> -&gt; an NMatrix …\n"],["binned_sorted_indices","NMatrix","NMatrix.html#method-i-binned_sorted_indices","()","<p>Returns an array of arrays of indices ordered by value sorted. Functions\nbasically like <code>sorted_indices</code> …\n"],["binned_sorted_indices","NMatrix","NMatrix.html#method-i-binned_sorted_indices","()","<p>Returns an array of arrays of indices ordered by value sorted. Functions\nbasically like <code>sorted_indices</code> …\n"],["capacity","NMatrix","NMatrix.html#method-i-capacity","()","<p>Find the capacity of an NMatrix. The capacity only differs from the size\nfor Yale matrices, which occasionally …\n"],["capacity","NMatrix","NMatrix.html#method-i-capacity","()","<p>Find the capacity of an NMatrix. The capacity only differs from the size\nfor Yale matrices, which occasionally …\n"],["cast","NMatrix","NMatrix.html#method-i-cast","(*params)","<p>This is a user-friendly helper for calling #cast_full. The easiest way to\ncall this function is using …\n"],["cast","NMatrix","NMatrix.html#method-i-cast","(*params)","<p>This is a user-friendly helper for calling #cast_full. The easiest way to\ncall this function is using …\n"],["cast_full","NMatrix","NMatrix.html#method-i-cast_full","(p1, p2, p3)","<p>Copy constructor for changing dtypes and stypes.\n"],["cast_full","NMatrix","NMatrix.html#method-i-cast_full","(p1, p2, p3)","<p>Copy constructor for changing dtypes and stypes.\n"],["clapack_gesv","NMatrix::LAPACK","NMatrix/LAPACK.html#method-i-clapack_gesv","(order, n, nrhs, a, lda, b, ldb, ipiv=nil)","<p>Computes the solution to a system of linear equations\n\n<pre>A * X = B,</pre>\n<p>where A is an N-by-N matrix and X and …\n"],["clapack_posv","NMatrix::LAPACK","NMatrix/LAPACK.html#method-i-clapack_posv","(order, uplo, n, nrhs, a, lda, b, ldb)","<p>TODO Complete this description.\n<p>Computes the solution to a real system of linear equations\n\n<pre>A * X = B,</pre>\n"],["clone_structure","NMatrix","NMatrix.html#method-i-clone_structure","(capacity = nil)","<p>This function is like clone, but it only copies the structure and the\ndefault value. None of the other …\n"],["clone_structure","NMatrix","NMatrix.html#method-i-clone_structure","(capacity = nil)","<p>This function is like clone, but it only copies the structure and the\ndefault value. None of the other …\n"],["col","NMatrix","NMatrix.html#method-i-col","(column_number, get_by = :copy)",""],["col","NMatrix","NMatrix.html#method-i-col","(column_number, get_by = :copy)",""],["cols","NMatrix","NMatrix.html#method-i-cols","()","<p>This shortcut use #shape to return the number of columns (the second\ndimension) of the matrix.\n"],["cols","NMatrix","NMatrix.html#method-i-cols","()","<p>This shortcut use #shape to return the number of columns (the second\ndimension) of the matrix.\n"],["column","NMatrix","NMatrix.html#method-i-column","(column_number, get_by = :copy)","<p>Returns the column specified. Uses slicing by copy as default.\n<p><strong>Arguments</strong> :\n<p><code>column_number</code> -&gt; Integer …\n"],["column","NMatrix","NMatrix.html#method-i-column","(column_number, get_by = :copy)","<p>Returns the column specified. Uses slicing by copy as default.\n<p><strong>Arguments</strong> :\n<p><code>column_number</code> -&gt; Integer …\n"],["complex_conjugate","NMatrix","NMatrix.html#method-i-complex_conjugate","()","<p>Transform the matrix (non-in-place) to its complex conjugate. Only works on\ncomplex matrices.\n"],["complex_conjugate","NMatrix","NMatrix.html#method-i-complex_conjugate","()","<p>Transform the matrix (non-in-place) to its complex conjugate. Only works on\ncomplex matrices.\n"],["complex_conjugate!","NMatrix","NMatrix.html#method-i-complex_conjugate-21","()","<p>Transform the matrix (in-place) to its complex conjugate. Only works on\ncomplex matrices.\n<p>Bang should …\n"],["complex_conjugate!","NMatrix","NMatrix.html#method-i-complex_conjugate-21","()","<p>Transform the matrix (in-place) to its complex conjugate. Only works on\ncomplex matrices.\n<p>Bang should …\n"],["complex_merge","NMatrix::IO::Matlab","NMatrix/IO/Matlab.html#method-c-complex_merge","(p1, p2, p3)","<p>Take two byte-strings (real and imaginary) and treat them as if they\ncontain a sequence of data of type …\n"],["concat","NMatrix","NMatrix.html#method-i-concat","(*matrices)","<p>Joins two matrices together into a new larger matrix. Attempts to determine\nwhich direction to concatenate …\n"],["concat","NMatrix","NMatrix.html#method-i-concat","(*matrices)","<p>Joins two matrices together into a new larger matrix. Attempts to determine\nwhich direction to concatenate …\n"],["conjugate_transpose","NMatrix","NMatrix.html#method-i-conjugate_transpose","()","<p>Calculate the conjugate transpose of a matrix. If your dtype is already\ncomplex, this should only require …\n"],["conjugate_transpose","NMatrix","NMatrix.html#method-i-conjugate_transpose","()","<p>Calculate the conjugate transpose of a matrix. If your dtype is already\ncomplex, this should only require …\n"],["data_pointer","NMatrix","NMatrix.html#method-i-data_pointer","()","<p>Returns the pointer to the matrix storage&#39;s data. This is useful\nprimarily when you are using FFI …\n"],["data_pointer","NMatrix","NMatrix.html#method-i-data_pointer","()","<p>Returns the pointer to the matrix storage&#39;s data. This is useful\nprimarily when you are using FFI …\n"],["dconcat","NMatrix","NMatrix.html#method-i-dconcat","(*matrices)","<p>Depth concatenation with <code>matrices</code>.\n"],["dconcat","NMatrix","NMatrix.html#method-i-dconcat","(*matrices)","<p>Depth concatenation with <code>matrices</code>.\n"],["default_value","NMatrix","NMatrix.html#method-i-default_value","()","<p>Get the default value for the matrix. For dense, this is undefined and will\nreturn Qnil. For list, it …\n"],["default_value","NMatrix","NMatrix.html#method-i-default_value","()","<p>Get the default value for the matrix. For dense, this is undefined and will\nreturn Qnil. For list, it …\n"],["dense?","NMatrix","NMatrix.html#method-i-dense-3F","()","<p>Determine if <code>m</code> is a dense matrix.\n"],["dense?","NMatrix","NMatrix.html#method-i-dense-3F","()","<p>Determine if <code>m</code> is a dense matrix.\n"],["det","NMatrix","NMatrix.html#method-i-det","()","<p>Calculate the determinant by way of LU decomposition. This is accomplished\nusing clapack_getrf, and then …\n"],["det","NMatrix","NMatrix.html#method-i-det","()","<p>Calculate the determinant by way of LU decomposition. This is accomplished\nusing clapack_getrf, and then …\n"],["det_exact","NMatrix","NMatrix.html#method-i-det_exact","()","<p>Calculate the exact determinant of a dense matrix.\n<p>Returns nil for dense matrices which are not square …\n"],["det_exact","NMatrix","NMatrix.html#method-i-det_exact","()","<p>Calculate the exact determinant of a dense matrix.\n<p>Returns nil for dense matrices which are not square …\n"],["diagonal","NMatrix","NMatrix.html#method-i-diagonal","(entries, opts={})","<p>Creates a matrix filled with specified diagonals.\n<p><strong>Arguments</strong> :\n<p><code>entries</code> -&gt; Array containing input values …\n"],["diagonal","NMatrix","NMatrix.html#method-i-diagonal","(entries, opts={})","<p>Creates a matrix filled with specified diagonals.\n<p><strong>Arguments</strong> :\n<p><code>entries</code> -&gt; Array containing input values …\n"],["dim","NMatrix","NMatrix.html#method-i-dim","()",""],["dim","NMatrix","NMatrix.html#method-i-dim","()",""],["dim","NVector","NVector.html#method-i-dim","()","<p>Returns the dimension of a vector, which is 1.\n"],["dimensions","NMatrix","NMatrix.html#method-i-dimensions","()","<p>Get the number of dimensions of a matrix.\n<p>In other words, if you set your matrix to be 3x4, the dim is …\n"],["dimensions","NMatrix","NMatrix.html#method-i-dimensions","()","<p>Get the number of dimensions of a matrix.\n<p>In other words, if you set your matrix to be 3x4, the dim is …\n"],["dot","NMatrix","NMatrix.html#method-i-dot","(p1)","<p>Matrix multiply (dot product): against another matrix or a vector.\n<p>For elementwise, use * instead.\n<p>The …\n"],["dot","NMatrix","NMatrix.html#method-i-dot","(p1)","<p>Matrix multiply (dot product): against another matrix or a vector.\n<p>For elementwise, use * instead.\n<p>The …\n"],["dtype","NMatrix","NMatrix.html#method-i-dtype","()","<p>Get the data type (dtype) of a matrix, e.g., :byte, :int8, :int16, :int32,\n:int64, :float32, :float64, …\n"],["dtype","NMatrix","NMatrix.html#method-i-dtype","()","<p>Get the data type (dtype) of a matrix, e.g., :byte, :int8, :int16, :int32,\n:int64, :float32, :float64, …\n"],["dtype_for_floor_or_ceil","NMatrix","NMatrix.html#method-i-dtype_for_floor_or_ceil","()","<p>These are for calculating the floor or ceil of matrix\n"],["dtype_for_floor_or_ceil","NMatrix","NMatrix.html#method-i-dtype_for_floor_or_ceil","()","<p>These are for calculating the floor or ceil of matrix\n"],["each","NMatrix","NMatrix.html#method-i-each","(&bl)","<p>Enumerate through the matrix. @see Enumerable#each\n<p>For dense, this actually calls a specialized each iterator …\n"],["each","NMatrix","NMatrix.html#method-i-each","(&bl)","<p>Enumerate through the matrix. @see Enumerable#each\n<p>For dense, this actually calls a specialized each iterator …\n"],["each_along_dim","NMatrix","NMatrix.html#method-i-each_along_dim","(dimen=0, get_by=:reference)",""],["each_along_dim","NMatrix","NMatrix.html#method-i-each_along_dim","(dimen=0, get_by=:reference)",""],["each_column","NMatrix","NMatrix.html#method-i-each_column","(get_by=:reference)","<p>Iterate through each column, referencing it as an NMatrix slice.\n"],["each_column","NMatrix","NMatrix.html#method-i-each_column","(get_by=:reference)","<p>Iterate through each column, referencing it as an NMatrix slice.\n"],["each_layer","NMatrix","NMatrix.html#method-i-each_layer","(get_by=:reference)","<p>Iterate through each layer, referencing it as an NMatrix slice.\n<p>Note: If you have a 3-dimensional matrix, …\n"],["each_layer","NMatrix","NMatrix.html#method-i-each_layer","(get_by=:reference)","<p>Iterate through each layer, referencing it as an NMatrix slice.\n<p>Note: If you have a 3-dimensional matrix, …\n"],["each_ordered_stored_with_indices","NMatrix","NMatrix.html#method-i-each_ordered_stored_with_indices","()","<p>Very similar to #each_stored_with_indices. The key difference is that it\nenforces matrix ordering rather …\n"],["each_ordered_stored_with_indices","NMatrix","NMatrix.html#method-i-each_ordered_stored_with_indices","()","<p>Very similar to #each_stored_with_indices. The key difference is that it\nenforces matrix ordering rather …\n"],["each_rank","NMatrix","NMatrix.html#method-i-each_rank","(dimen=0, get_by=:reference)","<p>Generic for @each_row, @each_col\n<p>Iterate through each rank by reference.\n<p>@param [Fixnum] dimen the rank …\n"],["each_rank","NMatrix","NMatrix.html#method-i-each_rank","(dimen=0, get_by=:reference)","<p>Generic for @each_row, @each_col\n<p>Iterate through each rank by reference.\n<p>@param [Fixnum] dimen the rank …\n"],["each_row","NMatrix","NMatrix.html#method-i-each_row","(get_by=:reference)","<p>Iterate through each row, referencing it as an NMatrix slice.\n"],["each_row","NMatrix","NMatrix.html#method-i-each_row","(get_by=:reference)","<p>Iterate through each row, referencing it as an NMatrix slice.\n"],["each_stored_with_index","NMatrix","NMatrix.html#method-i-each_stored_with_index","(&block)","<p>Allow iteration across a vector NMatrix&#39;s stored values. See also\n@each_stored_with_indices\n"],["each_stored_with_index","NMatrix","NMatrix.html#method-i-each_stored_with_index","(&block)","<p>Allow iteration across a vector NMatrix&#39;s stored values. See also\n@each_stored_with_indices\n"],["each_stored_with_indices","NMatrix","NMatrix.html#method-i-each_stored_with_indices","()","<p>Iterate over the stored entries of any matrix. For dense and yale, this\niterates over non-zero entries; …\n"],["each_stored_with_indices","NMatrix","NMatrix.html#method-i-each_stored_with_indices","()","<p>Iterate over the stored entries of any matrix. For dense and yale, this\niterates over non-zero entries; …\n"],["each_with_indices","NMatrix","NMatrix.html#method-i-each_with_indices","()","<p>Iterate over all entries of any matrix in standard storage order (as with\n#each), and include the indices. …\n"],["each_with_indices","NMatrix","NMatrix.html#method-i-each_with_indices","()","<p>Iterate over all entries of any matrix in standard storage order (as with\n#each), and include the indices. …\n"],["effective_dim","NMatrix","NMatrix.html#method-i-effective_dim","()",""],["effective_dim","NMatrix","NMatrix.html#method-i-effective_dim","()",""],["effective_dimensions","NMatrix","NMatrix.html#method-i-effective_dimensions","()","<p>Returns the number of dimensions that don&#39;t have length 1. Guaranteed\nto be less than or equal to …\n"],["effective_dimensions","NMatrix","NMatrix.html#method-i-effective_dimensions","()","<p>Returns the number of dimensions that don&#39;t have length 1. Guaranteed\nto be less than or equal to …\n"],["eye","NMatrix","NMatrix.html#method-i-eye","(shape, opts={})","<p>Creates an identity matrix (square matrix rank 2).\n<p><strong>Arguments</strong> :\n<p><code>size</code> -&gt; Array (or integer for square …\n"],["eye","NMatrix","NMatrix.html#method-i-eye","(shape, opts={})","<p>Creates an identity matrix (square matrix rank 2).\n<p><strong>Arguments</strong> :\n<p><code>size</code> -&gt; Array (or integer for square …\n"],["factorize_cholesky","NMatrix","NMatrix.html#method-i-factorize_cholesky","()","<p>Cholesky factorization of a matrix.\n"],["factorize_cholesky","NMatrix","NMatrix.html#method-i-factorize_cholesky","()","<p>Cholesky factorization of a matrix.\n"],["factorize_lu","NMatrix","NMatrix.html#method-i-factorize_lu","()","<p>LU factorization of a matrix.\n<p>FIXME: For some reason, getrf seems to require that the matrix be\ntransposed …\n"],["factorize_lu","NMatrix","NMatrix.html#method-i-factorize_lu","()","<p>LU factorization of a matrix.\n<p>FIXME: For some reason, getrf seems to require that the matrix be\ntransposed …\n"],["flat_map","NMatrix","NMatrix.html#method-i-flat_map","(&bl)","<p>call-seq:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">flat_map</span> <span class=\"ruby-operator\">-</span><span class=\"ruby-operator\">&gt;</span> <span class=\"ruby-constant\">Enumerator</span>\n<span class=\"ruby-identifier\">flat_map</span> { <span class=\"ruby-operator\">|</span><span class=\"ruby-identifier\">elem</span><span class=\"ruby-operator\">|</span> <span class=\"ruby-identifier\">block</span> } <span class=\"ruby-operator\">-</span><span class=\"ruby-operator\">&gt;</span> <span class=\"ruby-constant\">Array</span>\n</pre>\n<p>Maps using Enumerator (returns an  …\n"],["flat_map","NMatrix","NMatrix.html#method-i-flat_map","(&bl)","<p>call-seq:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">flat_map</span> <span class=\"ruby-operator\">-</span><span class=\"ruby-operator\">&gt;</span> <span class=\"ruby-constant\">Enumerator</span>\n<span class=\"ruby-identifier\">flat_map</span> { <span class=\"ruby-operator\">|</span><span class=\"ruby-identifier\">elem</span><span class=\"ruby-operator\">|</span> <span class=\"ruby-identifier\">block</span> } <span class=\"ruby-operator\">-</span><span class=\"ruby-operator\">&gt;</span> <span class=\"ruby-constant\">Array</span>\n</pre>\n<p>Maps using Enumerator (returns an  …\n"],["geev","NMatrix::LAPACK","NMatrix/LAPACK.html#method-i-geev","(matrix, which=:both)","<p>Perform eigenvalue decomposition on a matrix using LAPACK&#39;s xGEEV\nfunction.\n"],["gemm","NMatrix::BLAS","NMatrix/BLAS.html#method-i-gemm","(a, b, c = nil, alpha = 1.0, beta = 0.0, transpose_a = false, transpose_b = false, m = nil, n = nil, k = nil, lda = nil, ldb = nil, ldc = nil)","<p>Updates the value of C via the matrix multiplication\n\n<pre>C = (alpha * A * B) + (beta * C)</pre>\n<p>where <code>alpha</code> and  …\n"],["gemv","NMatrix::BLAS","NMatrix/BLAS.html#method-i-gemv","(a, x, y = nil, alpha = 1.0, beta = 0.0, transpose_a = false, m = nil, n = nil, lda = nil, incx = nil, incy = nil)","<p>Implements matrix-vector product via\n\n<pre>y = (alpha * A * x) + (beta * y)</pre>\n<p>where <code>alpha</code> and <code>beta</code> are scalar values. …\n"],["gesdd","NMatrix","NMatrix.html#method-i-gesdd","(workspace_size=1)","<p>Compute the singular value decomposition of a matrix using LAPACK&#39;s\nGESDD function. This uses a divide-and-conquer …\n"],["gesdd","NMatrix","NMatrix.html#method-i-gesdd","(workspace_size=1)","<p>Compute the singular value decomposition of a matrix using LAPACK&#39;s\nGESDD function. This uses a divide-and-conquer …\n"],["gesdd","NMatrix::LAPACK","NMatrix/LAPACK.html#method-i-gesdd","(matrix, workspace_size=100000)","<p>Compute the singular value decomposition of a matrix using LAPACK&#39;s\nGESDD function. This uses a divide-and-conquer …\n"],["gesdd!","NMatrix","NMatrix.html#method-i-gesdd-21","(workspace_size=1)","<p>Compute the singular value decomposition of a matrix using LAPACK&#39;s\nGESDD function. This uses a divide-and-conquer …\n"],["gesdd!","NMatrix","NMatrix.html#method-i-gesdd-21","(workspace_size=1)","<p>Compute the singular value decomposition of a matrix using LAPACK&#39;s\nGESDD function. This uses a divide-and-conquer …\n"],["gesvd","NMatrix","NMatrix.html#method-i-gesvd","(workspace_size=1)","<p>Compute the singular value decomposition of a matrix using LAPACK&#39;s\nGESVD function.\n<p>Optionally accepts …\n"],["gesvd","NMatrix","NMatrix.html#method-i-gesvd","(workspace_size=1)","<p>Compute the singular value decomposition of a matrix using LAPACK&#39;s\nGESVD function.\n<p>Optionally accepts …\n"],["gesvd","NMatrix::LAPACK","NMatrix/LAPACK.html#method-i-gesvd","(matrix, workspace_size=1)","<p>Compute the singular value decomposition of a matrix using LAPACK&#39;s\nGESVD function.\n<p>Optionally accepts …\n"],["gesvd!","NMatrix","NMatrix.html#method-i-gesvd-21","(workspace_size=1)","<p>Compute the singular value decomposition of a matrix using LAPACK&#39;s\nGESVD function. This is destructive, …\n"],["gesvd!","NMatrix","NMatrix.html#method-i-gesvd-21","(workspace_size=1)","<p>Compute the singular value decomposition of a matrix using LAPACK&#39;s\nGESVD function. This is destructive, …\n"],["getrf","NMatrix","NMatrix.html#method-i-getrf","()","<p>In-place version of #getrf!. Returns the new matrix, which contains L and U\nmatrices.\n<p><strong>Raises</strong> :\n<p><code>StorageTypeError</code> …\n"],["getrf","NMatrix","NMatrix.html#method-i-getrf","()","<p>In-place version of #getrf!. Returns the new matrix, which contains L and U\nmatrices.\n<p><strong>Raises</strong> :\n<p><code>StorageTypeError</code> …\n"],["getrf!","NMatrix","NMatrix.html#method-i-getrf-21","()","<p>LU factorization of a general M-by-N matrix <code>A</code> using partial\npivoting with row interchanges. Only works …\n"],["getrf!","NMatrix","NMatrix.html#method-i-getrf-21","()","<p>LU factorization of a general M-by-N matrix <code>A</code> using partial\npivoting with row interchanges. Only works …\n"],["guess_dtype","NMatrix","NMatrix.html#method-c-guess_dtype","(p1)","<p>Guess the dtype given a Ruby VALUE and return it as a symbol.\n<p>Not to be confused with nm_dtype_guess, …\n"],["guess_dtype","NMatrix","NMatrix.html#method-c-guess_dtype","(p1)","<p>Guess the dtype given a Ruby VALUE and return it as a symbol.\n<p>Not to be confused with nm_dtype_guess, …\n"],["hconcat","NMatrix","NMatrix.html#method-i-hconcat","(*matrices)","<p>Horizontal concatenation with <code>matrices</code>.\n"],["hconcat","NMatrix","NMatrix.html#method-i-hconcat","(*matrices)","<p>Horizontal concatenation with <code>matrices</code>.\n"],["hermitian?","NMatrix","NMatrix.html#method-i-hermitian-3F","()","<p>Is this matrix hermitian?\n<p>Definition: en.wikipedia.org/wiki/Hermitian_matrix\n<p>For non-complex matrices, …\n"],["hermitian?","NMatrix","NMatrix.html#method-i-hermitian-3F","()","<p>Is this matrix hermitian?\n<p>Definition: en.wikipedia.org/wiki/Hermitian_matrix\n<p>For non-complex matrices, …\n"],["initialize_copy","NMatrix","NMatrix.html#method-i-initialize_copy","(p1)","<p>Copy constructor for no change of dtype or stype (used for #initialize_copy\nhook).\n"],["initialize_copy","NMatrix","NMatrix.html#method-i-initialize_copy","(p1)","<p>Copy constructor for no change of dtype or stype (used for #initialize_copy\nhook).\n"],["inject_along_dim","NMatrix","NMatrix.html#method-i-inject_along_dim","(dimen=0, initial=nil, dtype=nil)",""],["inject_along_dim","NMatrix","NMatrix.html#method-i-inject_along_dim","(dimen=0, initial=nil, dtype=nil)",""],["inject_rank","NMatrix","NMatrix.html#method-i-inject_rank","(dimen=0, initial=nil, dtype=nil)","<p>Reduces an NMatrix using a supplied block over a specified dimension. The\nblock should behave the same …\n"],["inject_rank","NMatrix","NMatrix.html#method-i-inject_rank","(dimen=0, initial=nil, dtype=nil)","<p>Reduces an NMatrix using a supplied block over a specified dimension. The\nblock should behave the same …\n"],["integer_dtype?","NMatrix","NMatrix.html#method-i-integer_dtype-3F","()","<p>Checks if dtype is an integer type\n"],["integer_dtype?","NMatrix","NMatrix.html#method-i-integer_dtype-3F","()","<p>Checks if dtype is an integer type\n"],["inverse","NMatrix","NMatrix.html#method-i-inverse","()",""],["inverse","NMatrix","NMatrix.html#method-i-inverse","()",""],["invert","NMatrix","NMatrix.html#method-i-invert","()","<p>Make a copy of the matrix, then invert it (requires LAPACK for matrices\nlarger than 3x3).\n<p><strong>Returns</strong> :\n<p>A dense …\n"],["invert","NMatrix","NMatrix.html#method-i-invert","()","<p>Make a copy of the matrix, then invert it (requires LAPACK for matrices\nlarger than 3x3).\n<p><strong>Returns</strong> :\n<p>A dense …\n"],["invert!","NMatrix","NMatrix.html#method-i-invert-21","()","<p>Use LAPACK to calculate the inverse of the matrix (in-place). Only works on\ndense matrices.\n<p>Note: If you …\n"],["invert!","NMatrix","NMatrix.html#method-i-invert-21","()","<p>Use LAPACK to calculate the inverse of the matrix (in-place). Only works on\ndense matrices.\n<p>Note: If you …\n"],["is_ref?","NMatrix","NMatrix.html#method-i-is_ref-3F","()","<p>Check to determine whether matrix is a reference to another matrix.\n"],["is_ref?","NMatrix","NMatrix.html#method-i-is_ref-3F","()","<p>Check to determine whether matrix is a reference to another matrix.\n"],["laswp","NMatrix","NMatrix.html#method-i-laswp","(ary)","<p>Permute the columns of a dense matrix using LASWP according to the order\ngiven in an Array <code>ary</code>. Not yet …\n"],["laswp","NMatrix","NMatrix.html#method-i-laswp","(ary)","<p>Permute the columns of a dense matrix using LASWP according to the order\ngiven in an Array <code>ary</code>. Not yet …\n"],["laswp","NMatrix::LAPACK","NMatrix/LAPACK.html#method-i-laswp","(matrix, ipiv)","\n<pre>laswp(matrix, ipiv) -&gt; NMatrix</pre>\n<p>Permute the columns of a matrix (in-place) according to the Array\n<code>ipiv</code> …\n"],["laswp!","NMatrix","NMatrix.html#method-i-laswp-21","(ary)","<p>In-place permute the columns of a dense matrix using LASWP according to the\norder given in an Array  …\n"],["laswp!","NMatrix","NMatrix.html#method-i-laswp-21","(ary)","<p>In-place permute the columns of a dense matrix using LASWP according to the\norder given in an Array  …\n"],["layer","NMatrix","NMatrix.html#method-i-layer","(layer_number, get_by = :copy)","<p><strong>Arguments</strong> :\n<p><code>layer_number</code> -&gt; Integer.\n<p><code>get_by</code> -&gt; Type of slicing to use, <code>:copy</code> or\n<code>:reference</code>.\n"],["layer","NMatrix","NMatrix.html#method-i-layer","(layer_number, get_by = :copy)","<p><strong>Arguments</strong> :\n<p><code>layer_number</code> -&gt; Integer.\n<p><code>get_by</code> -&gt; Type of slicing to use, <code>:copy</code> or\n<code>:reference</code>.\n"],["list?","NMatrix","NMatrix.html#method-i-list-3F","()","<p>Determine if <code>m</code> is a list-of-lists matrix.\n"],["list?","NMatrix","NMatrix.html#method-i-list-3F","()","<p>Determine if <code>m</code> is a list-of-lists matrix.\n"],["load","NMatrix::IO::Market","NMatrix/IO/Market.html#method-i-load","(filename)","<p>Load a MatrixMarket file. Requires a <code>filename</code> as an argument.\n<p><strong>Arguments</strong> :\n<p><code>filename</code> -&gt; String with the …\n"],["load","NMatrix::IO::PointCloud","NMatrix/IO/PointCloud.html#method-i-load","(filename)","<p><strong>Arguments</strong> :\n<p><code>filename</code> -&gt; String giving the name of the file to be\nloaded.\n\n\n<p>Load a Point Cloud Library …\n"],["load_array","NMatrix::IO::Market","NMatrix/IO/Market.html#method-i-load_array","(file, converter, dtype, entry_type, symmetry)",""],["load_coordinate","NMatrix::IO::Market","NMatrix/IO/Market.html#method-i-load_coordinate","(file, converter, dtype, entry_type, symmetry)","<p>Creates a :list NMatrix from a coordinate-list MatrixMarket file.\n"],["load_mat","NMatrix::IO::Matlab","NMatrix/IO/Matlab.html#method-i-load_mat","(file_path)","<p>Load a .mat file and return a NMatrix corresponding to it.\n"],["load_matlab_file","NMatrix","NMatrix.html#method-i-load_matlab_file","(file_path)","<p><strong>Arguments</strong> :\n<p><code>file_path</code> -&gt; The path to a version 5 .mat file.\n\n<p><strong>Returns</strong> :\n"],["load_matlab_file","NMatrix","NMatrix.html#method-i-load_matlab_file","(file_path)","<p><strong>Arguments</strong> :\n<p><code>file_path</code> -&gt; The path to a version 5 .mat file.\n\n<p><strong>Returns</strong> :\n"],["load_pcd_file","NMatrix","NMatrix.html#method-i-load_pcd_file","(file_path)","<p><strong>Arguments</strong> :\n<p><code>file_path</code> -&gt; The path to a PCL PCD file.\n\n<p><strong>Returns</strong> :\n"],["load_pcd_file","NMatrix","NMatrix.html#method-i-load_pcd_file","(file_path)","<p><strong>Arguments</strong> :\n<p><code>file_path</code> -&gt; The path to a PCL PCD file.\n\n<p><strong>Returns</strong> :\n"],["log","NMatrix","NMatrix.html#method-i-log","(*args)",""],["log","NMatrix","NMatrix.html#method-i-log","(*args)",""],["lower_triangle","NMatrix","NMatrix.html#method-i-lower_triangle","(k = 0)","<p>Returns the lower triangular portion of a matrix. This is analogous to the\n<code>tril</code> method in MATLAB.\n<p><strong>Arguments</strong> …\n"],["lower_triangle","NMatrix","NMatrix.html#method-i-lower_triangle","(k = 0)","<p>Returns the lower triangular portion of a matrix. This is analogous to the\n<code>tril</code> method in MATLAB.\n<p><strong>Arguments</strong> …\n"],["lower_triangle!","NMatrix","NMatrix.html#method-i-lower_triangle-21","(k = 0)","<p>Deletes the upper triangular portion of the matrix (in-place) so only the\nlower portion remains.\n<p><strong>Arguments</strong> …\n"],["lower_triangle!","NMatrix","NMatrix.html#method-i-lower_triangle-21","(k = 0)","<p>Deletes the upper triangular portion of the matrix (in-place) so only the\nlower portion remains.\n<p><strong>Arguments</strong> …\n"],["map","NMatrix","NMatrix.html#method-i-map","(&bl)","<p>Returns an NMatrix if a block is given. For an Array, use #flat_map\n<p>Note that #map will always return …\n"],["map","NMatrix","NMatrix.html#method-i-map","(&bl)","<p>Returns an NMatrix if a block is given. For an Array, use #flat_map\n<p>Note that #map will always return …\n"],["map!","NMatrix","NMatrix.html#method-i-map-21","()","<p>Maps in place. @see #map\n"],["map!","NMatrix","NMatrix.html#method-i-map-21","()","<p>Maps in place. @see #map\n"],["map_stored","NMatrix","NMatrix.html#method-i-map_stored","()","<p>Iterate over the stored entries of any matrix. For dense and yale, this\niterates over non-zero entries; …\n"],["map_stored","NMatrix","NMatrix.html#method-i-map_stored","()","<p>Iterate over the stored entries of any matrix. For dense and yale, this\niterates over non-zero entries; …\n"],["max","NMatrix","NMatrix.html#method-i-max","(dimen=0)","<p>Calculates the maximum along the specified dimension.\n<p>@see #inject_rank\n"],["max","NMatrix","NMatrix.html#method-i-max","(dimen=0)","<p>Calculates the maximum along the specified dimension.\n<p>@see #inject_rank\n"],["max","NVector","NVector.html#method-i-max","()","<p>Return the maximum element.\n"],["mean","NMatrix","NMatrix.html#method-i-mean","(dimen=0)","<p>Calculates the mean along the specified dimension.\n<p>This will force integer types to float64 dtype.\n<p>@see …\n"],["mean","NMatrix","NMatrix.html#method-i-mean","(dimen=0)","<p>Calculates the mean along the specified dimension.\n<p>This will force integer types to float64 dtype.\n<p>@see …\n"],["min","NMatrix","NMatrix.html#method-i-min","(dimen=0)","<p>Calculates the minimum along the specified dimension.\n<p>@see #inject_rank\n"],["min","NMatrix","NMatrix.html#method-i-min","(dimen=0)","<p>Calculates the minimum along the specified dimension.\n<p>@see #inject_rank\n"],["min","NVector","NVector.html#method-i-min","()","<p>Return the minimum element.\n"],["min_dtype","NMatrix","NMatrix.html#method-c-min_dtype","(p1)","<p>Get the minimum allowable dtype for a Ruby VALUE and return it as a symbol.\n"],["min_dtype","NMatrix","NMatrix.html#method-c-min_dtype","(p1)","<p>Get the minimum allowable dtype for a Ruby VALUE and return it as a symbol.\n"],["new","NMatrix","NMatrix.html#method-c-new","(*args)","<p>Create a new NMatrix.\n<p>The only mandatory argument is shape, which may be a positive integer or an\narray …\n"],["new","NMatrix","NMatrix.html#method-c-new","(*args)","<p>Create a new NMatrix.\n<p>The only mandatory argument is shape, which may be a positive integer or an\narray …\n"],["new","NVector","NVector.html#method-c-new","(*args)","<p>Creates a new NVector. See also NMatrix#initialize for a more detailed\nexplanation of the arguments. …\n"],["norm2","NMatrix","NMatrix.html#method-i-norm2","(incx=1, n=nil)",""],["norm2","NMatrix","NMatrix.html#method-i-norm2","(incx=1, n=nil)",""],["nrm2","NMatrix","NMatrix.html#method-i-nrm2","(incx=1, n=nil)","<p>Arguments\n\n<pre>- +incx+ -&gt; the skip size (defaults to 1, no skip)\n- +n+ -&gt; the number of elements to include</pre>\n"],["nrm2","NMatrix","NMatrix.html#method-i-nrm2","(incx=1, n=nil)","<p>Arguments\n\n<pre>- +incx+ -&gt; the skip size (defaults to 1, no skip)\n- +n+ -&gt; the number of elements to include</pre>\n"],["nrm2","NMatrix::BLAS","NMatrix/BLAS.html#method-i-nrm2","(x, incx = 1, n = nil)","<p>Calculate the 2-norm of a vector <code>x</code> of size <code>n</code>\n<p><strong>Arguments</strong> :\n<p><code>x</code> -&gt; an NMatrix (will also allow an NMatrix …\n"],["nvector?","NMatrix","NMatrix.html#method-i-nvector-3F","()","<p>Shortcut function for determining whether the effective dimension is less\nthan the dimension. Useful …\n"],["nvector?","NMatrix","NMatrix.html#method-i-nvector-3F","()","<p>Shortcut function for determining whether the effective dimension is less\nthan the dimension. Useful …\n"],["offset","NMatrix","NMatrix.html#method-i-offset","()","<p>Get the offset (slice position) of a matrix. Typically all zeros, unless\nyou have a reference slice. …\n"],["offset","NMatrix","NMatrix.html#method-i-offset","()","<p>Get the offset (slice position) of a matrix. Typically all zeros, unless\nyou have a reference slice. …\n"],["ones","NMatrix","NMatrix.html#method-i-ones","(shape, opts={})","<p>Creates a matrix filled with ones.\n<p><strong>Arguments</strong> :\n<p><code>shape</code> -&gt; Array (or integer for square matrix) specifying …\n"],["ones","NMatrix","NMatrix.html#method-i-ones","(shape, opts={})","<p>Creates a matrix filled with ones.\n<p><strong>Arguments</strong> :\n<p><code>shape</code> -&gt; Array (or integer for square matrix) specifying …\n"],["ones_like","NMatrix","NMatrix.html#method-i-ones_like","(nm)","<p>Creates a new matrix of ones with the same dtype and shape as the provided\nmatrix.\n<p>@param [NMatrix] nm …\n"],["ones_like","NMatrix","NMatrix.html#method-i-ones_like","(nm)","<p>Creates a new matrix of ones with the same dtype and shape as the provided\nmatrix.\n<p>@param [NMatrix] nm …\n"],["orientation","NVector","NVector.html#method-i-orientation","()","<p>Orientation defaults to row (e.g., [1,3] is a row of length 3). It may also\nbe column, e.g., for [5,1]. …\n"],["permute_columns","NMatrix","NMatrix.html#method-i-permute_columns","(ary)",""],["permute_columns","NMatrix","NMatrix.html#method-i-permute_columns","(ary)",""],["permute_columns!","NMatrix","NMatrix.html#method-i-permute_columns-21","(ary)",""],["permute_columns!","NMatrix","NMatrix.html#method-i-permute_columns-21","(ary)",""],["potrf!","NMatrix","NMatrix.html#method-i-potrf-21","(which)","<p>Cholesky factorization of a symmetric positive-definite matrix – or, if\ncomplex, a Hermitian positive-definite …\n"],["potrf!","NMatrix","NMatrix.html#method-i-potrf-21","(which)","<p>Cholesky factorization of a symmetric positive-definite matrix – or, if\ncomplex, a Hermitian positive-definite …\n"],["potrf_lower!","NMatrix","NMatrix.html#method-i-potrf_lower-21","()",""],["potrf_lower!","NMatrix","NMatrix.html#method-i-potrf_lower-21","()",""],["potrf_upper!","NMatrix","NMatrix.html#method-i-potrf_upper-21","()",""],["potrf_upper!","NMatrix","NMatrix.html#method-i-potrf_upper-21","()",""],["random","NMatrix","NMatrix.html#method-i-random","(shape, opts={})","<p>Creates a <code>:dense</code> NMatrix with random numbers between 0 and 1\ngenerated by +Random::rand+. The parameter …\n"],["random","NMatrix","NMatrix.html#method-i-random","(shape, opts={})","<p>Creates a <code>:dense</code> NMatrix with random numbers between 0 and 1\ngenerated by +Random::rand+. The parameter …\n"],["rank","NMatrix","NMatrix.html#method-i-rank","(shape_idx, rank_idx, meth = :copy)","<p>Returns the rank (e.g., row, column, or layer) specified, using slicing by\ncopy as default.\n<p>See @row (dimension …\n"],["rank","NMatrix","NMatrix.html#method-i-rank","(shape_idx, rank_idx, meth = :copy)","<p>Returns the rank (e.g., row, column, or layer) specified, using slicing by\ncopy as default.\n<p>See @row (dimension …\n"],["read","NMatrix","NMatrix.html#method-c-read","(p1, p2 = v2)","<p>Binary file reader for NMatrix standard format. file should be a path,\nwhich we aren&#39;t going to check …\n"],["read","NMatrix","NMatrix.html#method-c-read","(p1, p2 = v2)","<p>Binary file reader for NMatrix standard format. file should be a path,\nwhich we aren&#39;t going to check …\n"],["reduce_along_dim","NMatrix","NMatrix.html#method-i-reduce_along_dim","(dimen=0, initial=nil, dtype=nil)",""],["reduce_along_dim","NMatrix","NMatrix.html#method-i-reduce_along_dim","(dimen=0, initial=nil, dtype=nil)",""],["repack","NMatrix::IO::Matlab","NMatrix/IO/Matlab.html#method-c-repack","(p1, p2, p3)","<p>Take a string of bytes which represent MATLAB data type values and repack\nthem into a string of bytes …\n"],["reshape","NMatrix","NMatrix.html#method-i-reshape","(new_shape,*shapes)","<p>Clone a matrix, changing the shape in the process. Note that this function\ndoes not do a resize; the …\n"],["reshape","NMatrix","NMatrix.html#method-i-reshape","(new_shape,*shapes)","<p>Clone a matrix, changing the shape in the process. Note that this function\ndoes not do a resize; the …\n"],["reshape!","NMatrix","NMatrix.html#method-i-reshape-21","(new_shape,*shapes)","<p>Reshapes the matrix (in-place) to the desired shape. Note that this\nfunction does not do a resize; the …\n"],["reshape!","NMatrix","NMatrix.html#method-i-reshape-21","(new_shape,*shapes)","<p>Reshapes the matrix (in-place) to the desired shape. Note that this\nfunction does not do a resize; the …\n"],["rot","NMatrix::BLAS","NMatrix/BLAS.html#method-i-rot","(x, y, c, s, incx = 1, incy = 1, n = nil, in_place=false)","<p>Apply plane rotation.\n<p><strong>Arguments</strong> :\n<p><code>x</code> -&gt; NMatrix\n"],["rot!","NMatrix::BLAS","NMatrix/BLAS.html#method-i-rot-21","(x, y, c, s, incx = 1, incy = 1, n = nil)","<p>Apply plane rotation directly to <code>x</code> and <code>y</code>.\n<p>See rot for arguments.\n"],["rotg","NMatrix::BLAS","NMatrix/BLAS.html#method-i-rotg","(ab)","<p>Apply givens plane rotation to the coordinates (a,b), returning the cosine\nand sine of the angle theta. …\n"],["row","NMatrix","NMatrix.html#method-i-row","(row_number, get_by = :copy)","<p><strong>Arguments</strong> :\n<p><code>row_number</code> -&gt; Integer.\n<p><code>get_by</code> -&gt; Type of slicing to use, <code>:copy</code> or\n<code>:reference</code>.\n"],["row","NMatrix","NMatrix.html#method-i-row","(row_number, get_by = :copy)","<p><strong>Arguments</strong> :\n<p><code>row_number</code> -&gt; Integer.\n<p><code>get_by</code> -&gt; Type of slicing to use, <code>:copy</code> or\n<code>:reference</code>.\n"],["rows","NMatrix","NMatrix.html#method-i-rows","()","<p>This shortcut use #shape to return the number of rows (the first dimension)\nof the matrix.\n"],["rows","NMatrix","NMatrix.html#method-i-rows","()","<p>This shortcut use #shape to return the number of rows (the first dimension)\nof the matrix.\n"],["save","NMatrix::IO::Market","NMatrix/IO/Market.html#method-i-save","(matrix, filename, options = {})","<p>Can optionally set :symmetry to :general, :symmetric, :hermitian; and can\nset :pattern =&gt; true if …\n"],["save_array","NMatrix::IO::Market","NMatrix/IO/Market.html#method-i-save_array","(matrix, file, symmetry)",""],["save_coordinate","NMatrix::IO::Market","NMatrix/IO/Market.html#method-i-save_coordinate","(matrix, file, symmetry, pattern)",""],["seq","NMatrix","NMatrix.html#method-i-seq","(shape, options={})","<p>Creates a matrix filled with a sequence of integers starting at zero.\n<p><strong>Arguments</strong> :\n<p><code>shape</code> -&gt; Array (or …\n"],["seq","NMatrix","NMatrix.html#method-i-seq","(shape, options={})","<p>Creates a matrix filled with a sequence of integers starting at zero.\n<p><strong>Arguments</strong> :\n<p><code>shape</code> -&gt; Array (or …\n"],["shape","NMatrix","NMatrix.html#method-i-shape","()","<p>Get the shape (dimensions) of a matrix.\n"],["shape","NMatrix","NMatrix.html#method-i-shape","()","<p>Get the shape (dimensions) of a matrix.\n"],["shuffle","NMatrix","NMatrix.html#method-i-shuffle","(*args)","<p>Re-arranges the contents of an NVector.\n<p>TODO: Write more efficient version for Yale, list. TODO: Generalize …\n"],["shuffle","NMatrix","NMatrix.html#method-i-shuffle","(*args)","<p>Re-arranges the contents of an NVector.\n<p>TODO: Write more efficient version for Yale, list. TODO: Generalize …\n"],["shuffle!","NMatrix","NMatrix.html#method-i-shuffle-21","(*args)","<p>Re-arranges the contents of an NVector.\n<p>TODO: Write more efficient version for Yale, list. TODO: Generalize …\n"],["shuffle!","NMatrix","NMatrix.html#method-i-shuffle-21","(*args)","<p>Re-arranges the contents of an NVector.\n<p>TODO: Write more efficient version for Yale, list. TODO: Generalize …\n"],["size","NMatrix","NMatrix.html#method-i-size","(shape)","<p>Calculate the size of an NMatrix of a given shape.\n"],["size","NMatrix","NMatrix.html#method-i-size","(shape)","<p>Calculate the size of an NMatrix of a given shape.\n"],["size","NVector","NVector.html#method-i-size","()","<p>Shorthand for the dominant shape component\n"],["slice","NMatrix","NMatrix.html#method-i-slice","(*args)","<p>Access the contents of an NMatrix at given coordinates, using copying.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">n</span>.<span class=\"ruby-identifier\">slice</span>(<span class=\"ruby-value\">3</span>,<span class=\"ruby-value\">3</span>)  <span class=\"ruby-comment\"># =&gt; 5.0</span>\n<span class=\"ruby-identifier\">n</span>.<span class=\"ruby-identifier\">slice</span>(<span class=\"ruby-value\">0</span><span class=\"ruby-operator\">..</span><span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">0</span><span class=\"ruby-operator\">..</span><span class=\"ruby-value\">1</span>) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["slice","NMatrix","NMatrix.html#method-i-slice","(*args)","<p>Access the contents of an NMatrix at given coordinates, using copying.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">n</span>.<span class=\"ruby-identifier\">slice</span>(<span class=\"ruby-value\">3</span>,<span class=\"ruby-value\">3</span>)  <span class=\"ruby-comment\"># =&gt; 5.0</span>\n<span class=\"ruby-identifier\">n</span>.<span class=\"ruby-identifier\">slice</span>(<span class=\"ruby-value\">0</span><span class=\"ruby-operator\">..</span><span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">0</span><span class=\"ruby-operator\">..</span><span class=\"ruby-value\">1</span>) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["sorted_indices","NMatrix","NMatrix.html#method-i-sorted_indices","()","<p>Returns an array of the indices ordered by value sorted.\n"],["sorted_indices","NMatrix","NMatrix.html#method-i-sorted_indices","()","<p>Returns an array of the indices ordered by value sorted.\n"],["std","NMatrix","NMatrix.html#method-i-std","(dimen=0)","<p>Calculates the sample standard deviation along the specified dimension.\n<p>This will force integer types …\n"],["std","NMatrix","NMatrix.html#method-i-std","(dimen=0)","<p>Calculates the sample standard deviation along the specified dimension.\n<p>This will force integer types …\n"],["stype","NMatrix","NMatrix.html#method-i-stype","()","<p>Get the storage type (stype) of a matrix, e.g., :yale, :dense, or :list.\n"],["stype","NMatrix","NMatrix.html#method-i-stype","()","<p>Get the storage type (stype) of a matrix, e.g., :yale, :dense, or :list.\n"],["sum","NMatrix","NMatrix.html#method-i-sum","(dimen=0)","<p>Calculates the sum along the specified dimension.\n<p>@see #inject_rank\n"],["sum","NMatrix","NMatrix.html#method-i-sum","(dimen=0)","<p>Calculates the sum along the specified dimension.\n<p>@see #inject_rank\n"],["supershape","NMatrix","NMatrix.html#method-i-supershape","()","<p>Get the shape of a slice&#39;s parent.\n"],["supershape","NMatrix","NMatrix.html#method-i-supershape","()","<p>Get the shape of a slice&#39;s parent.\n"],["symmetric?","NMatrix","NMatrix.html#method-i-symmetric-3F","()","<p>Is this matrix symmetric?\n"],["symmetric?","NMatrix","NMatrix.html#method-i-symmetric-3F","()","<p>Is this matrix symmetric?\n"],["to_a","NMatrix","NMatrix.html#method-i-to_a","(dimen=nil)","<p>Converts an NMatrix to an array of arrays, or an NMatrix of effective\ndimension 1 to an array.\n<p>Does not …\n"],["to_a","NMatrix","NMatrix.html#method-i-to_a","(dimen=nil)","<p>Converts an NMatrix to an array of arrays, or an NMatrix of effective\ndimension 1 to an array.\n<p>Does not …\n"],["to_f","NMatrix","NMatrix.html#method-i-to_f","()","<p>Converts an nmatrix with a single element (but any number of dimensions)\n\n<pre>to a float.</pre>\n<p>Raises an IndexError …\n"],["to_f","NMatrix","NMatrix.html#method-i-to_f","()","<p>Converts an nmatrix with a single element (but any number of dimensions)\n\n<pre>to a float.</pre>\n<p>Raises an IndexError …\n"],["to_flat_a","NMatrix","NMatrix.html#method-i-to_flat_a","()",""],["to_flat_a","NMatrix","NMatrix.html#method-i-to_flat_a","()",""],["to_flat_array","NMatrix","NMatrix.html#method-i-to_flat_array","()","<p>Converts an NMatrix to a one-dimensional Ruby Array.\n"],["to_flat_array","NMatrix","NMatrix.html#method-i-to_flat_array","()","<p>Converts an NMatrix to a one-dimensional Ruby Array.\n"],["to_h","NMatrix","NMatrix.html#method-i-to_h","()",""],["to_h","NMatrix","NMatrix.html#method-i-to_h","()",""],["to_hash","NMatrix","NMatrix.html#method-i-to_hash","()","<p>Create a Ruby Hash from an NMatrix.\n"],["to_hash","NMatrix","NMatrix.html#method-i-to_hash","()","<p>Create a Ruby Hash from an NMatrix.\n"],["to_nm","Array","Array.html#method-i-to_nm","(shape, dtype = nil, stype = :dense)","<p>Convert a Ruby Array to an NMatrix.\n<p>You must provide a shape for the matrix as the first argument.\n<p>Arguments: …\n"],["transpose","NMatrix","NMatrix.html#method-i-transpose","(permute = nil)","<p>Clone a matrix, transposing it in the process. If the matrix is\ntwo-dimensional, the permutation is taken …\n"],["transpose","NMatrix","NMatrix.html#method-i-transpose","(permute = nil)","<p>Clone a matrix, transposing it in the process. If the matrix is\ntwo-dimensional, the permutation is taken …\n"],["tril","NMatrix","NMatrix.html#method-i-tril","(k = 0)",""],["tril","NMatrix","NMatrix.html#method-i-tril","(k = 0)",""],["tril!","NMatrix","NMatrix.html#method-i-tril-21","(k = 0)",""],["tril!","NMatrix","NMatrix.html#method-i-tril-21","(k = 0)",""],["triu","NMatrix","NMatrix.html#method-i-triu","(k = 0)",""],["triu","NMatrix","NMatrix.html#method-i-triu","(k = 0)",""],["triu!","NMatrix","NMatrix.html#method-i-triu-21","(k = 0)",""],["triu!","NMatrix","NMatrix.html#method-i-triu-21","(k = 0)",""],["upcast","NMatrix","NMatrix.html#method-c-upcast","(p1, p2)","<p>Given a binary operation between types t1 and t2, what type will be\nreturned?\n<p>This is a singleton method …\n"],["upcast","NMatrix","NMatrix.html#method-c-upcast","(p1, p2)","<p>Given a binary operation between types t1 and t2, what type will be\nreturned?\n<p>This is a singleton method …\n"],["upper_triangle","NMatrix","NMatrix.html#method-i-upper_triangle","(k = 0)","<p>Returns the upper triangular portion of a matrix. This is analogous to the\n<code>triu</code> method in MATLAB.\n<p><strong>Arguments</strong> …\n"],["upper_triangle","NMatrix","NMatrix.html#method-i-upper_triangle","(k = 0)","<p>Returns the upper triangular portion of a matrix. This is analogous to the\n<code>triu</code> method in MATLAB.\n<p><strong>Arguments</strong> …\n"],["upper_triangle!","NMatrix","NMatrix.html#method-i-upper_triangle-21","(k = 0)","<p>Deletes the lower triangular portion of the matrix (in-place) so only the\nupper portion remains.\n<p><strong>Arguments</strong> …\n"],["upper_triangle!","NMatrix","NMatrix.html#method-i-upper_triangle-21","(k = 0)","<p>Deletes the lower triangular portion of the matrix (in-place) so only the\nupper portion remains.\n<p><strong>Arguments</strong> …\n"],["variance","NMatrix","NMatrix.html#method-i-variance","(dimen=0)","<p>Calculates the sample variance along the specified dimension.\n<p>This will force integer types to float64 …\n"],["variance","NMatrix","NMatrix.html#method-i-variance","(dimen=0)","<p>Calculates the sample variance along the specified dimension.\n<p>This will force integer types to float64 …\n"],["vconcat","NMatrix","NMatrix.html#method-i-vconcat","(*matrices)","<p>Vertical concatenation with <code>matrices</code>.\n"],["vconcat","NMatrix","NMatrix.html#method-i-vconcat","(*matrices)","<p>Vertical concatenation with <code>matrices</code>.\n"],["vector?","NMatrix","NMatrix.html#method-i-vector-3F","()","<p>Shortcut function for determining whether the effective dimension is 1. See\nalso #nvector?\n"],["vector?","NMatrix","NMatrix.html#method-i-vector-3F","()","<p>Shortcut function for determining whether the effective dimension is 1. See\nalso #nvector?\n"],["write","NMatrix","NMatrix.html#method-i-write","(*args)","<p>Binary file writer for NMatrix standard format. file should be a path,\nwhich we aren&#39;t going to check …\n"],["write","NMatrix","NMatrix.html#method-i-write","(*args)","<p>Binary file writer for NMatrix standard format. file should be a path,\nwhich we aren&#39;t going to check …\n"],["yale?","NMatrix","NMatrix.html#method-i-yale-3F","()","<p>Determine if <code>m</code> is a Yale matrix.\n"],["yale?","NMatrix","NMatrix.html#method-i-yale-3F","()","<p>Determine if <code>m</code> is a Yale matrix.\n"],["yale_a","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_a","(p1 = v1)","<p>Get the A array of a Yale matrix (which stores the diagonal and the LU\nportions of the matrix).\n"],["yale_d","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_d","(p1 = v1)","<p>Get the diagonal (“D”) portion of the A array of a Yale matrix.\n"],["yale_ia","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_ia","()","<p>Get the IA portion of the IJA array of a Yale matrix. This gives the start\nand end positions of rows …\n"],["yale_ija","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_ija","(p1 = v1)","<p>Get the IJA array of a Yale matrix (or a component of the IJA array).\n"],["yale_ja","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_ja","()","<p>Get the JA portion of the IJA array of a Yale matrix. This gives the column\nindices for entries in corresponding …\n"],["yale_ja_at","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_ja_at","(i)","<p>Returns the non-diagonal column indices which are stored in a given row.\n"],["yale_ja_d_keys_at","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_ja_d_keys_at","(i)","<p>Returns the diagonal and non-digonal column indices stored in a given row.\n"],["yale_ja_d_keys_set_at","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_ja_d_keys_set_at","(i)","<p>Returns the diagonal and non-diagonal column indices stored in a given row.\n"],["yale_ja_d_keys_sorted_set_at","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_ja_d_keys_sorted_set_at","(i)","<p>Returns the diagonal and non-diagonal column indices stored in a given row.\n"],["yale_ja_set_at","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_ja_set_at","(i)","<p>Returns the non-diagonal column indices which are stored in a given row, as\na Set.\n"],["yale_ja_sorted_set_at","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_ja_sorted_set_at","(i)","<p>Returns the non-diagonal column indices which are stored in a given row, as\na Set.\n"],["yale_lu","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_lu","()","<p>Get the non-diagonal (“LU”) portion of the A array of a Yale matrix.\n"],["yale_nd_row","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_nd_row","(p1, p2 = v2)","<p>This function gets the non-diagonal contents of a Yale matrix row. The\nfirst argument should be the row …\n"],["yale_nd_row_as_array","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_nd_row_as_array","(i)",""],["yale_nd_row_as_hash","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_nd_row_as_hash","(i)","<p>Returns the non-diagonal column indices and entries stored in a given row.\n"],["yale_nd_row_as_set","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_nd_row_as_set","(i)",""],["yale_nd_row_as_sorted_set","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_nd_row_as_sorted_set","(i)",""],["yale_nd_row_size","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_nd_row_size","(i)","<p>Returns the size of a given non-diagonal row.\n"],["yale_row_as_array","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_row_as_array","(i)",""],["yale_row_as_hash","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_row_as_hash","(i)","<p>Returns the diagonal and non-diagonal column indices and entries stored in\na given row.\n"],["yale_row_as_set","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_row_as_set","(i)",""],["yale_row_as_sorted_set","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_row_as_sorted_set","(i)",""],["yale_row_keys_intersection","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_row_keys_intersection","(p1, p2, p3)","<p>This function is experimental.\n<p>It finds the intersection of row i of the current matrix with row i2 of …\n"],["yale_size","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_size","()","<p>Get the size of a Yale matrix (the number of elements actually stored).\n<p>For capacity (the maximum number …\n"],["zeros","NMatrix","NMatrix.html#method-i-zeros","(shape, opts = {})","<p>Creates a new matrix of zeros with the dimensions supplied as parameters.\n<p><strong>Arguments</strong> :\n<p><code>shape</code> -&gt; Array …\n"],["zeros","NMatrix","NMatrix.html#method-i-zeros","(shape, opts = {})","<p>Creates a new matrix of zeros with the dimensions supplied as parameters.\n<p><strong>Arguments</strong> :\n<p><code>shape</code> -&gt; Array …\n"],["zeros_like","NMatrix","NMatrix.html#method-i-zeros_like","(nm)","<p>Creates a new matrix of zeros with the same stype, dtype, and shape as the\nprovided matrix.\n<p>@param [NMatrix] …\n"],["zeros_like","NMatrix","NMatrix.html#method-i-zeros_like","(nm)","<p>Creates a new matrix of zeros with the same stype, dtype, and shape as the\nprovided matrix.\n<p>@param [NMatrix] …\n"],["CONTRIBUTING","","CONTRIBUTING_md.html","","<p>NMatrix is part of SciRuby, a collaborative effort to bring scientific\ncomputation to Ruby. If you want …\n"],["History","","History_txt.html","","<p>0.0.1 / 2012-04-10\n<p>1 major enhancement\n<p>Initial alpha release\n"],["LICENSE","","LICENSE_txt.html","","<p>This version of NMatrix is licensed under the BSD 2-clause license.\n<p>sciruby.com\n<p>github.com/sciruby/sciruby/wiki/License …\n"],["README","","README_rdoc.html","","<p>NMatrix\n<p>Fast Numerical Linear Algebra Library for Ruby\n<p>sciruby.com\n"],["binary_format","","ext/nmatrix/binary_format_txt.html","","<p>This is the proposed binary format for saving and loading NMatrix objects.\n<p>Order is little-endian.\n<p>List …\n"]]}}