var search_data = {"index":{"searchIndex":["array","datatypeerror","n","nmatrix","blas","io","market","matlab","mat5reader","compressed","element","elementdataioerror","header","matrixdata","rawelement","tag","matreader","lapack","yalefunctions","nvector","object","storagetypeerror","==()","[]()","[]()","[]()","[]=()","[]=()","bindgen()","bindgen()","capacity()","cast()","cblas_gemm()","cblas_gemv()","cblas_herk()","cblas_rot()","cblas_rotg()","cblas_syrk()","cblas_trmm()","cblas_trsm()","cindgen()","cindgen()","clapack_gesv()","clapack_getrf()","clapack_getri()","clapack_getrs()","clapack_laswp()","clapack_lauum()","clapack_posv()","clapack_potrf()","clapack_potri()","clapack_potrs()","clapack_scal()","cols()","column()","complex_conjugate()","complex_conjugate!()","complex_merge()","compressed()","conjugate_transpose()","content()","det()","det_exact()","dim()","dim()","dimensions()","dot()","dtype()","each()","each()","each_stored_with_indices()","extract()","eye()","factorize_lu()","findgen()","findgen()","flip!()","flip_orientation!()","gemm()","gemv()","getrf!()","guess_byte_order()","guess_byte_order()","guess_dtype_from_mdtype()","hermitian?()","identity()","ignore_padding()","ignore_padding()","indgen()","indgen()","initialize_copy()","inspect()","inverse()","invert()","invert!()","is_ref?()","itype()","itype_by_shape()","linspace()","load()","load_array()","load_coordinate()","load_file()","load_mat()","multiply()","multiply!()","new()","new()","new()","new()","new()","new()","ones()","ones()","orientation()","padded_bytes()","random()","random()","read()","read_packed()","read_packed()","read_packed()","read_packed()","read_packed()","read_packed()","repack()","repacked_data()","repacked_indices()","rot()","rows()","save()","save_array()","save_coordinate()","seek_and_read_file_header()","seq()","seq()","shape()","size()","size()","slice()","small?()","stype()","symmetric?()","to_a()","to_h()","to_hash()","to_nm()","to_nm()","to_ruby()","to_ruby()","to_ruby()","to_s()","transpose()","transpose()","transpose!()","unpacked_data()","upcast()","write()","write_packed()","write_packed()","write_packed()","write_packed()","write_packed()","yale_a()","yale_d()","yale_ia()","yale_ija()","yale_ja()","yale_lu()","yale_size()","zeroes()","zeroes()","zeros()","zeros()","history","readme","binary_format"],"longSearchIndex":["array","datatypeerror","n","nmatrix","nmatrix::blas","nmatrix::io","nmatrix::io::market","nmatrix::io::matlab","nmatrix::io::matlab::mat5reader","nmatrix::io::matlab::mat5reader::compressed","nmatrix::io::matlab::mat5reader::element","nmatrix::io::matlab::mat5reader::elementdataioerror","nmatrix::io::matlab::mat5reader::header","nmatrix::io::matlab::mat5reader::matrixdata","nmatrix::io::matlab::mat5reader::rawelement","nmatrix::io::matlab::mat5reader::tag","nmatrix::io::matlab::matreader","nmatrix::lapack","nmatrix::yalefunctions","nvector","object","storagetypeerror","nmatrix#==()","n::[]()","nmatrix#[]()","nvector#[]()","nmatrix#[]=()","nvector#[]=()","nmatrix::bindgen()","nvector::bindgen()","nmatrix#capacity()","nmatrix#cast()","nmatrix::blas::cblas_gemm()","nmatrix::blas::cblas_gemv()","nmatrix::blas::cblas_herk()","nmatrix::blas::cblas_rot()","nmatrix::blas::cblas_rotg()","nmatrix::blas::cblas_syrk()","nmatrix::blas::cblas_trmm()","nmatrix::blas::cblas_trsm()","nmatrix::cindgen()","nvector::cindgen()","nmatrix::lapack::clapack_gesv()","nmatrix::lapack::clapack_getrf()","nmatrix::lapack::clapack_getri()","nmatrix::lapack::clapack_getrs()","nmatrix::lapack::clapack_laswp()","nmatrix::lapack::clapack_lauum()","nmatrix::lapack::clapack_posv()","nmatrix::lapack::clapack_potrf()","nmatrix::lapack::clapack_potri()","nmatrix::lapack::clapack_potrs()","nmatrix::lapack::clapack_scal()","nmatrix#cols()","nmatrix#column()","nmatrix#complex_conjugate()","nmatrix#complex_conjugate!()","nmatrix::io::matlab::complex_merge()","nmatrix::io::matlab::mat5reader::compressed#compressed()","nmatrix#conjugate_transpose()","nmatrix::io::matlab::mat5reader::compressed#content()","nmatrix#det()","nmatrix#det_exact()","nmatrix#dim()","nvector#dim()","nmatrix#dimensions()","nmatrix#dot()","nmatrix#dtype()","nmatrix#each()","nmatrix::io::matlab::mat5reader#each()","nmatrix#each_stored_with_indices()","nmatrix::io::matlab::mat5reader::compressed#extract()","nmatrix::eye()","nmatrix#factorize_lu()","nmatrix::findgen()","nvector::findgen()","nvector#flip!()","nvector#flip_orientation!()","nmatrix::blas::gemm()","nmatrix::blas::gemv()","nmatrix#getrf!()","nmatrix::io::matlab::mat5reader#guess_byte_order()","nmatrix::io::matlab::matreader#guess_byte_order()","nmatrix::io::matlab::mat5reader::matrixdata#guess_dtype_from_mdtype()","nmatrix#hermitian?()","nmatrix::identity()","nmatrix::io::matlab::mat5reader::element#ignore_padding()","nmatrix::io::matlab::mat5reader::matrixdata#ignore_padding()","nmatrix::indgen()","nvector::indgen()","nmatrix#initialize_copy()","nmatrix::io::matlab::mat5reader::tag#inspect()","nmatrix#inverse()","nmatrix#invert()","nmatrix#invert!()","nmatrix#is_ref?()","nmatrix#itype()","nmatrix::itype_by_shape()","nvector::linspace()","nmatrix::io::market::load()","nmatrix::io::market::load_array()","nmatrix::io::market::load_coordinate()","nmatrix::load_file()","nmatrix::io::matlab::load_mat()","nvector#multiply()","nvector#multiply!()","nmatrix::new()","nmatrix::io::matlab::mat5reader::new()","nmatrix::io::matlab::mat5reader::compressed::new()","nmatrix::io::matlab::mat5reader::elementdataioerror::new()","nmatrix::io::matlab::matreader::new()","nvector::new()","nmatrix::ones()","nvector::ones()","nvector#orientation()","nmatrix::io::matlab::mat5reader::compressed#padded_bytes()","nmatrix::random()","nvector::random()","nmatrix::read()","nmatrix::io::matlab::mat5reader::compressed#read_packed()","nmatrix::io::matlab::mat5reader::element#read_packed()","nmatrix::io::matlab::mat5reader::header#read_packed()","nmatrix::io::matlab::mat5reader::matrixdata#read_packed()","nmatrix::io::matlab::mat5reader::rawelement#read_packed()","nmatrix::io::matlab::mat5reader::tag#read_packed()","nmatrix::io::matlab::repack()","nmatrix::io::matlab::mat5reader::matrixdata#repacked_data()","nmatrix::io::matlab::mat5reader::matrixdata#repacked_indices()","nmatrix::blas::rot()","nmatrix#rows()","nmatrix::io::market::save()","nmatrix::io::market::save_array()","nmatrix::io::market::save_coordinate()","nmatrix::io::matlab::mat5reader#seek_and_read_file_header()","nmatrix::seq()","nvector::seq()","nmatrix#shape()","nmatrix::io::matlab::mat5reader::tag#size()","nvector#size()","nmatrix#slice()","nmatrix::io::matlab::mat5reader::tag#small?()","nmatrix#stype()","nmatrix#symmetric?()","nmatrix::io::matlab::mat5reader#to_a()","nmatrix#to_h()","nmatrix#to_hash()","array#to_nm()","nmatrix::io::matlab::mat5reader::matrixdata#to_nm()","nmatrix::io::matlab::mat5reader#to_ruby()","nmatrix::io::matlab::mat5reader::element#to_ruby()","nmatrix::io::matlab::mat5reader::matrixdata#to_ruby()","nmatrix::io::matlab::mat5reader::elementdataioerror#to_s()","nmatrix#transpose()","nvector#transpose()","nvector#transpose!()","nmatrix::io::matlab::mat5reader::matrixdata#unpacked_data()","nmatrix::upcast()","nmatrix#write()","nmatrix::io::matlab::mat5reader::compressed#write_packed()","nmatrix::io::matlab::mat5reader::element#write_packed()","nmatrix::io::matlab::mat5reader::header#write_packed()","nmatrix::io::matlab::mat5reader::matrixdata#write_packed()","nmatrix::io::matlab::mat5reader::tag#write_packed()","nmatrix::yalefunctions#yale_a()","nmatrix::yalefunctions#yale_d()","nmatrix::yalefunctions#yale_ia()","nmatrix::yalefunctions#yale_ija()","nmatrix::yalefunctions#yale_ja()","nmatrix::yalefunctions#yale_lu()","nmatrix::yalefunctions#yale_size()","nmatrix::zeroes()","nvector::zeroes()","nmatrix::zeros()","nvector::zeros()","","",""],"info":[["Array","","Array.html","","<p>Classes and Modules #\n"],["DataTypeError","","DataTypeError.html","","<p>Exception raised when there’s a problem with data.\n"],["N","","N.html","","<p>NMatrix needs to have a succinct way to create a matrix by specifying the\ncomponents directly. This is …\n"],["NMatrix","","NMatrix.html","",""],["NMatrix::BLAS","","NMatrix/BLAS.html","",""],["NMatrix::IO","","NMatrix/IO.html","","<p>Read and write extensions for NMatrix. These are only loaded when needed.\n"],["NMatrix::IO::Market","","NMatrix/IO/Market.html","",""],["NMatrix::IO::Matlab","","NMatrix/IO/Matlab.html","",""],["NMatrix::IO::Matlab::Mat5Reader","","NMatrix/IO/Matlab/Mat5Reader.html","","<p>Reader (and eventual writer) for a version 5 .mat file.\n"],["NMatrix::IO::Matlab::Mat5Reader::Compressed","","NMatrix/IO/Matlab/Mat5Reader/Compressed.html","",""],["NMatrix::IO::Matlab::Mat5Reader::Element","","NMatrix/IO/Matlab/Mat5Reader/Element.html","",""],["NMatrix::IO::Matlab::Mat5Reader::ElementDataIOError","","NMatrix/IO/Matlab/Mat5Reader/ElementDataIOError.html","",""],["NMatrix::IO::Matlab::Mat5Reader::Header","","NMatrix/IO/Matlab/Mat5Reader/Header.html","","<p>Internal Classes #\n"],["NMatrix::IO::Matlab::Mat5Reader::MatrixData","","NMatrix/IO/Matlab/Mat5Reader/MatrixData.html","",""],["NMatrix::IO::Matlab::Mat5Reader::RawElement","","NMatrix/IO/Matlab/Mat5Reader/RawElement.html","","<p>Doesn’t unpack the contents of the element, e.g., if we want to handle\nmanually, or pass the raw string …\n"],["NMatrix::IO::Matlab::Mat5Reader::Tag","","NMatrix/IO/Matlab/Mat5Reader/Tag.html","",""],["NMatrix::IO::Matlab::MatReader","","NMatrix/IO/Matlab/MatReader.html","","<p>Class for parsing a .mat file stream.\n<p>The full format of .mat files is available here:\n<p>www.mathworks.com/help/pdf_doc/matlab/matfile_format.pdf …\n"],["NMatrix::LAPACK","","NMatrix/LAPACK.html","",""],["NMatrix::YaleFunctions","","NMatrix/YaleFunctions.html","","<p>This module stores methods that are useful for debugging Yale matrices,\ni.e. the ones with <code>:yale</code> stype. …\n"],["NVector","","NVector.html","","<p>This is a specific type of NMatrix in which only one dimension is not 1.\nAlthough it is stored as a dim-2, …\n"],["Object","","Object.html","",""],["StorageTypeError","","StorageTypeError.html","","<p>Exception raised when something goes wrong with the storage of a matrix.\n"],["==","NMatrix","NMatrix.html#method-i-3D-3D","(p1)","<p>Equality operator. Returns a single true or false value indicating whether\nthe matrices are equivalent. …\n"],["[]","N","N.html#method-c-5B-5D","(*params)",""],["[]","NMatrix","NMatrix.html#method-i-5B-5D","(*args)","<p>Access the contents of an NMatrix at given coordinates by reference.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">n</span>[<span class=\"ruby-value\">3</span>,<span class=\"ruby-value\">3</span>]  <span class=\"ruby-comment\"># =&gt; 5.0</span>\n<span class=\"ruby-identifier\">n</span>[<span class=\"ruby-value\">0</span><span class=\"ruby-operator\">..</span><span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">0</span><span class=\"ruby-operator\">..</span><span class=\"ruby-value\">1</span>] <span class=\"ruby-comment\">#=&gt; ...</span>\n</pre>\n"],["[]","NVector","NVector.html#method-i-5B-5D","(i)","<p>Retrieves an element or return a slice.\n<p>Examples:\n\n<pre>u = NVector.new(3, [10, 20, 30])\nu[0]              # ...</pre>\n"],["[]=","NMatrix","NMatrix.html#method-i-5B-5D-3D","(*args)","<p>Modify the contents of an NMatrix in the given cell\n\n<pre>n[3,3] = 5.0</pre>\n<p>Also returns the new contents, so you …\n"],["[]=","NVector","NVector.html#method-i-5B-5D-3D","(i, val)","<p>Stores <code>value</code> at position <code>index</code>.\n"],["bindgen","NMatrix","NMatrix.html#method-c-bindgen","(size)","<p>Returns a byte NMatrix. Equivalent to <code>seq(n, :byte)</code>.\n<p><strong>Arguments</strong> :\n<p><code>size</code> -&gt; Size of the sequence.\n"],["bindgen","NVector","NVector.html#method-c-bindgen","(n)","<p>Returns a byte NVector. Equivalent to <code>seq(n, :byte)</code>.\n<p><strong>Arguments</strong> :\n<p><code>n</code> -&gt; Size of the sequence.\n"],["capacity","NMatrix","NMatrix.html#method-i-capacity","()","<p>Find the capacity of an NMatrix. The capacity only differs from the size\nfor Yale matrices, which occasionally …\n"],["cast","NMatrix","NMatrix.html#method-i-cast","(p1, p2)","<p>Copy constructor for changing dtypes and stypes.\n"],["cblas_gemm","NMatrix::BLAS","NMatrix/BLAS.html#method-c-cblas_gemm","(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14)","<p>Call any of the cblas_xgemm functions as directly as possible.\n<p>The cblas_xgemm functions (dgemm, sgemm, …\n"],["cblas_gemv","NMatrix::BLAS","NMatrix/BLAS.html#method-c-cblas_gemv","(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11)","<p>Call any of the cblas_xgemv functions as directly as possible.\n<p>The cblas_xgemv functions (dgemv, sgemv, …\n"],["cblas_herk","NMatrix::BLAS","NMatrix/BLAS.html#method-c-cblas_herk","(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11)",""],["cblas_rot","NMatrix::BLAS","NMatrix/BLAS.html#method-c-cblas_rot","(p1, p2, p3, p4, p5, p6, p7)","<p>Call any of the cblas_xrot functions as directly as possible.\n<p>xROT is a BLAS level 1 routine (taking two …\n"],["cblas_rotg","NMatrix::BLAS","NMatrix/BLAS.html#method-c-cblas_rotg","(p1)","<p>Call any of the cblas_xrotg functions as directly as possible.\n<p>xROTG computes the elements of a Givens …\n"],["cblas_syrk","NMatrix::BLAS","NMatrix/BLAS.html#method-c-cblas_syrk","(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11)",""],["cblas_trmm","NMatrix::BLAS","NMatrix/BLAS.html#method-c-cblas_trmm","(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12)",""],["cblas_trsm","NMatrix::BLAS","NMatrix/BLAS.html#method-c-cblas_trsm","(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12)",""],["cindgen","NMatrix","NMatrix.html#method-c-cindgen","(size)","<p>Returns an complex NMatrix. Equivalent to <code>seq(n, :complex64)</code>.\n<p><strong>Arguments</strong> :\n<p><code>size</code> -&gt; Size of the sequence. ...\n"],["cindgen","NVector","NVector.html#method-c-cindgen","(n)","<p>Returns a complex NVector. Equivalent to <code>seq(n, :complex64)</code>.\n<p><strong>Arguments</strong> :\n<p><code>n</code> -&gt; Size of the sequence. ...\n"],["clapack_gesv","NMatrix::LAPACK","NMatrix/LAPACK.html#method-c-clapack_gesv","(order, n, nrhs, a, lda, ipiv, b, ldb)","<p>Computes the solution to a system of linear equations\n\n<pre>A * X = B,</pre>\n<p>where A is an N-by-N matrix and X and …\n"],["clapack_getrf","NMatrix::LAPACK","NMatrix/LAPACK.html#method-c-clapack_getrf","(p1, p2, p3, p4, p5)","<p>Call any of the clapack_xgetrf functions as directly as possible.\n<p>The clapack_getrf functions (dgetrf, …\n"],["clapack_getri","NMatrix::LAPACK","NMatrix/LAPACK.html#method-c-clapack_getri","(p1, p2, p3, p4, p5)","<p>Call any of the clapack_xgetri functions as directly as possible.\n<p>You probably don’t want to call this …\n"],["clapack_getrs","NMatrix::LAPACK","NMatrix/LAPACK.html#method-c-clapack_getrs","(p1, p2, p3, p4, p5, p6, p7, p8, p9)","<p>Call any of the clapack_xgetrs functions as directly as possible.\n"],["clapack_laswp","NMatrix::LAPACK","NMatrix/LAPACK.html#method-c-clapack_laswp","(p1, p2, p3, p4, p5, p6, p7)","<p>Call any of the clapack_xlaswp functions as directly as possible.\n<p>Note that LAPACK’s xlaswp functions …\n"],["clapack_lauum","NMatrix::LAPACK","NMatrix/LAPACK.html#method-c-clapack_lauum","(p1, p2, p3, p4, p5)",""],["clapack_posv","NMatrix::LAPACK","NMatrix/LAPACK.html#method-c-clapack_posv","(order, uplo, n, nrhs, a, lda, b, ldb)","<p>TODO Complete this description.\n<p>Computes the solution to a real system of linear equations\n\n<pre>A * X = B,</pre>\n"],["clapack_potrf","NMatrix::LAPACK","NMatrix/LAPACK.html#method-c-clapack_potrf","(p1, p2, p3, p4, p5)","<p>Call any of the clapack_xpotrf functions as directly as possible.\n<p>You probably don’t want to call this …\n"],["clapack_potri","NMatrix::LAPACK","NMatrix/LAPACK.html#method-c-clapack_potri","(p1, p2, p3, p4, p5)","<p>Call any of the clapack_xpotri functions as directly as possible.\n<p>You probably don’t want to call this …\n"],["clapack_potrs","NMatrix::LAPACK","NMatrix/LAPACK.html#method-c-clapack_potrs","(p1, p2, p3, p4, p5, p6, p7, p8)","<p>Call any of the clapack_xpotrs functions as directly as possible.\n"],["clapack_scal","NMatrix::LAPACK","NMatrix/LAPACK.html#method-c-clapack_scal","(p1, p2, p3, p4)","<p>Based on LAPACK’s dscal function, but for any dtype.\n<p>In-place modification; returns the modified vector …\n"],["cols","NMatrix","NMatrix.html#method-i-cols","()","<p>This shortcut use #shape to return the number of columns (the second\ndimension) of the matrix.\n"],["column","NMatrix","NMatrix.html#method-i-column","(column_number, get_by = :copy)","<p>Returns the column specified. Uses slicing by copy as default.\n<p><strong>Arguments</strong> :\n<p><code>column_number</code> -&gt; Integer ...\n"],["complex_conjugate","NMatrix","NMatrix.html#method-i-complex_conjugate","(new_stype = self.stype)","<p>Get the complex conjugate of this matrix. See also complex_conjugate! for\nan in-place operation (provided …\n"],["complex_conjugate!","NMatrix","NMatrix.html#method-i-complex_conjugate-21","()","<p>Transform the matrix (in-place) to its complex conjugate. Only works on\ncomplex matrices.\n<p>FIXME: For non-complex …\n"],["complex_merge","NMatrix::IO::Matlab","NMatrix/IO/Matlab.html#method-c-complex_merge","(p1, p2, p3)","<p>Take two byte-strings (real and imaginary) and treat them as if they\ncontain a sequence of data of type …\n"],["compressed","NMatrix::IO::Matlab::Mat5Reader::Compressed","NMatrix/IO/Matlab/Mat5Reader/Compressed.html#method-i-compressed","()",""],["conjugate_transpose","NMatrix","NMatrix.html#method-i-conjugate_transpose","()","<p>Calculate the conjugate transpose of a matrix. If your dtype is already\ncomplex, this should only require …\n"],["content","NMatrix::IO::Matlab::Mat5Reader::Compressed","NMatrix/IO/Matlab/Mat5Reader/Compressed.html#method-i-content","()",""],["det","NMatrix","NMatrix.html#method-i-det","()","<p>Calculate the determinant by way of LU decomposition. This is accomplished\nusing clapack_getrf, and then …\n"],["det_exact","NMatrix","NMatrix.html#method-i-det_exact","()","<p>Calculate the exact determinant of a dense matrix.\n<p>Returns nil for dense matrices which are not square …\n"],["dim","NMatrix","NMatrix.html#method-i-dim","()",""],["dim","NVector","NVector.html#method-i-dim","()","<p>Returns the dimension of a vector, which is 1.\n"],["dimensions","NMatrix","NMatrix.html#method-i-dimensions","()","<p>Get the number of dimensions of a matrix.\n<p>In other words, if you set your matrix to be 3x4, the dim is …\n"],["dot","NMatrix","NMatrix.html#method-i-dot","(p1)","<p>Matrix multiply (dot product): against another matrix or a vector.\n<p>For elementwise, use * instead.\n<p>The …\n"],["dtype","NMatrix","NMatrix.html#method-i-dtype","()","<p>Get the data type (dtype) of a matrix, e.g., :byte, :int8, :int16, :int32,\n:int64, :float32, :float64, …\n"],["each","NMatrix","NMatrix.html#method-i-each","()","<p>Iterate over the matrix as you would an Enumerable (e.g., Array).\n<p>Currently only works for dense.\n"],["each","NMatrix::IO::Matlab::Mat5Reader","NMatrix/IO/Matlab/Mat5Reader.html#method-i-each","(&block)",""],["each_stored_with_indices","NMatrix","NMatrix.html#method-i-each_stored_with_indices","()","<p>Iterate over the sparse entries of any matrix. For dense and yale, this\niterates over non-zero entries; …\n"],["extract","NMatrix::IO::Matlab::Mat5Reader::Compressed","NMatrix/IO/Matlab/Mat5Reader/Compressed.html#method-i-extract","()",""],["eye","NMatrix","NMatrix.html#method-c-eye","(*params)","<p>Creates an identity matrix (square matrix rank 2).\n<p><strong>Arguments</strong> :\n<p><code>stype</code> -&gt; (optional) Default is <code>:dense</code> ...\n"],["factorize_lu","NMatrix","NMatrix.html#method-i-factorize_lu","()","<p>LU factorization of a matrix.\n<p>FIXME: For some reason, getrf seems to require that the matrix be\ntransposed …\n"],["findgen","NMatrix","NMatrix.html#method-c-findgen","(size)","<p>Returns a float NMatrix. Equivalent to <code>seq(n, :float32)</code>.\n<p><strong>Arguments</strong> :\n<p><code>size</code> -&gt; Size of the sequence.\n"],["findgen","NVector","NVector.html#method-c-findgen","(n)","<p>Returns a float NVector. Equivalent to <code>seq(n, :float32)</code>.\n<p><strong>Arguments</strong> :\n<p><code>n</code> -&gt; Size of the sequence.\n"],["flip!","NVector","NVector.html#method-i-flip-21","()",""],["flip_orientation!","NVector","NVector.html#method-i-flip_orientation-21","()","<p>Flip the orientation of the vector.\n<p><strong>Returns</strong> :\n<p>NVector with orientation changed.\n"],["gemm","NMatrix::BLAS","NMatrix/BLAS.html#method-c-gemm","(a, b, c = nil, alpha = 1.0, beta = 0.0, transpose_a = false, transpose_b = false, m = nil, n = nil, k = nil, lda = nil, ldb = nil, ldc = nil)","<p>Updates the value of C via the matrix multiplication\n\n<pre>C = (alpha * A * B) + (beta * C)</pre>\n<p>where <code>alpha</code> and  …\n"],["gemv","NMatrix::BLAS","NMatrix/BLAS.html#method-c-gemv","(a, x, y = nil, alpha = 1.0, beta = 0.0, transpose_a = false, m = nil, n = nil, lda = nil, incx = nil, incy = nil)","<p>Implements matrix-vector product via\n\n<pre>y = (alpha * A * x) + (beta * y)</pre>\n<p>where <code>alpha</code> and <code>beta</code> are scalar values. …\n"],["getrf!","NMatrix","NMatrix.html#method-i-getrf-21","()","<p>LU factorization of a general M-by-N matrix <code>A</code> using partial\npivoting with row interchanges. Only works …\n"],["guess_byte_order","NMatrix::IO::Matlab::Mat5Reader","NMatrix/IO/Matlab/Mat5Reader.html#method-i-guess_byte_order","()",""],["guess_byte_order","NMatrix::IO::Matlab::MatReader","NMatrix/IO/Matlab/MatReader.html#method-i-guess_byte_order","()",""],["guess_dtype_from_mdtype","NMatrix::IO::Matlab::Mat5Reader::MatrixData","NMatrix/IO/Matlab/Mat5Reader/MatrixData.html#method-i-guess_dtype_from_mdtype","()","<p>Try to determine what dtype and such to use.\n<p>TODO: Needs to be verified that unsigned MATLAB types are …\n"],["hermitian?","NMatrix","NMatrix.html#method-i-hermitian-3F","()","<p>Is this matrix hermitian?\n<p>Definition: en.wikipedia.org/wiki/Hermitian_matrix\n<p>For non-complex matrices, …\n"],["identity","NMatrix","NMatrix.html#method-c-identity","(*params)",""],["ignore_padding","NMatrix::IO::Matlab::Mat5Reader::Element","NMatrix/IO/Matlab/Mat5Reader/Element.html#method-i-ignore_padding","(packedio, bytes)",""],["ignore_padding","NMatrix::IO::Matlab::Mat5Reader::MatrixData","NMatrix/IO/Matlab/Mat5Reader/MatrixData.html#method-i-ignore_padding","(packedio, bytes)","<p><strong>Arguments</strong> :\n<p>++ -&gt;\n\n<p><strong>Returns</strong> : -\n"],["indgen","NMatrix","NMatrix.html#method-c-indgen","(size)","<p>Returns an integer NMatrix. Equivalent to <code>seq(n, :int32)</code>.\n<p><strong>Arguments</strong> :\n<p><code>size</code> -&gt; Size of the sequence. ...\n"],["indgen","NVector","NVector.html#method-c-indgen","(n)","<p>Returns an integer NVector. Equivalent to <code>seq(n, :int32)</code>.\n<p><strong>Arguments</strong> :\n<p><code>n</code> -&gt; Size of the sequence.\n"],["initialize_copy","NMatrix","NMatrix.html#method-i-initialize_copy","(p1)","<p>Copy constructor for no change of dtype or stype (used for #initialize_copy\nhook).\n"],["inspect","NMatrix::IO::Matlab::Mat5Reader::Tag","NMatrix/IO/Matlab/Mat5Reader/Tag.html#method-i-inspect","()",""],["inverse","NMatrix","NMatrix.html#method-i-inverse","()",""],["invert","NMatrix","NMatrix.html#method-i-invert","()","<p>Make a copy of the matrix, then invert it (requires LAPACK).\n<p><strong>Returns</strong> :\n<p>A dense NMatrix.\n"],["invert!","NMatrix","NMatrix.html#method-i-invert-21","()","<p>Use LAPACK to calculate the inverse of the matrix (in-place). Only works on\ndense matrices.\n<p>Note: If you …\n"],["is_ref?","NMatrix","NMatrix.html#method-i-is_ref-3F","()","<p>Check to determine whether matrix is a reference to another matrix.\n"],["itype","NMatrix","NMatrix.html#method-i-itype","()","<p>Get the index data type (dtype) of a matrix. Defined only for yale; others\nreturn nil.\n"],["itype_by_shape","NMatrix","NMatrix.html#method-c-itype_by_shape","(p1)","<p>Get the index data type (dtype) of a matrix. Defined only for yale; others\nreturn nil.\n"],["linspace","NVector","NVector.html#method-c-linspace","(a, b, n = 100)","<p>Returns a NVector with <code>n</code> values of dtype <code>:float64</code>\nequally spaced from <code>a</code> to <code>b</code>, inclusive.\n<p>Following the …\n"],["load","NMatrix::IO::Market","NMatrix/IO/Market.html#method-c-load","(filename)","<p><strong>Arguments</strong> :\n<p><code>filename</code> -&gt; String with the filename to be saved.\n\n<p><strong>Raises</strong> :\n"],["load_array","NMatrix::IO::Market","NMatrix/IO/Market.html#method-c-load_array","(file, converter, dtype, entry_type, symmetry)",""],["load_coordinate","NMatrix::IO::Market","NMatrix/IO/Market.html#method-c-load_coordinate","(file, converter, dtype, entry_type, symmetry)","<p>Creates a :list NMatrix from a coordinate-list MatrixMarket file.\n"],["load_file","NMatrix","NMatrix.html#method-c-load_file","(file_path)","<p><strong>Arguments</strong> :\n<p><code>path</code> -&gt; The path to a version 5 .mat file.\n\n<p><strong>Returns</strong> :\n"],["load_mat","NMatrix::IO::Matlab","NMatrix/IO/Matlab.html#method-c-load_mat","(file_path)",""],["multiply","NVector","NVector.html#method-i-multiply","(m)","<p>…\n<p><strong>Arguments</strong> :\n<p>++ -&gt;\n"],["multiply!","NVector","NVector.html#method-i-multiply-21","(m)","<p>…\n<p><strong>Arguments</strong> :\n<p>++ -&gt;\n"],["new","NMatrix","NMatrix.html#method-c-new","(*args)","<p>Create a new NMatrix.\n<p>There are several ways to do this. At a minimum, dimensions and either a\ndtype or …\n"],["new","NMatrix::IO::Matlab::Mat5Reader","NMatrix/IO/Matlab/Mat5Reader.html#method-c-new","(stream, options = {})","<p>Instance Methods #\n"],["new","NMatrix::IO::Matlab::Mat5Reader::Compressed","NMatrix/IO/Matlab/Mat5Reader/Compressed.html#method-c-new","(stream = nil, byte_order = nil, content_or_bytes = nil)","<p><strong>Arguments</strong> :\n<p>++ -&gt;\n\n<p><strong>Raises</strong> :\n"],["new","NMatrix::IO::Matlab::Mat5Reader::ElementDataIOError","NMatrix/IO/Matlab/Mat5Reader/ElementDataIOError.html#method-c-new","(tag = nil, msg = nil)",""],["new","NMatrix::IO::Matlab::MatReader","NMatrix/IO/Matlab/MatReader.html#method-c-new","(stream, options = {})","<p><strong>Raises</strong> :\n<p><code>ArgumentError</code> -&gt; First argument must be IO.\n\n\n"],["new","NVector","NVector.html#method-c-new","(length, *args)","<p>Creates a new NVector.\n<p><strong>Arguments</strong> :\n<p><code>length</code> -&gt; Size of the vector.\n"],["ones","NMatrix","NMatrix.html#method-c-ones","(*params)","<p>Creates a matrix filled with ones.\n<p><strong>Arguments</strong> :\n<p><code>size</code> -&gt; Array (or integer for square matrix) specifying ...\n"],["ones","NVector","NVector.html#method-c-ones","(size, dtype = :float64)","<p>Creates a vector of ones with the dimensions supplied as parameters.\n<p><strong>Arguments</strong> :\n<p><code>size</code> -&gt; Array (or integer ...\n"],["orientation","NVector","NVector.html#method-i-orientation","()","<p>Orientation defaults to column (e.g., [3,1] is a column of length 3). It\nmay also be row, e.g., for [1,5]. …\n"],["padded_bytes","NMatrix::IO::Matlab::Mat5Reader::Compressed","NMatrix/IO/Matlab/Mat5Reader/Compressed.html#method-i-padded_bytes","()",""],["random","NMatrix","NMatrix.html#method-c-random","(size)","<p>Creates a <code>:dense</code> NMatrix with random numbers between 0 and 1\ngenerated by +Random::rand+. The parameter …\n"],["random","NVector","NVector.html#method-c-random","(size)","<p>Creates a vector with random numbers between 0 and 1 generated by\n+Random::rand+ with the dimensions …\n"],["read","NMatrix","NMatrix.html#method-c-read","(*args)","<p>Binary file reader for NMatrix standard format. file should be a path,\nwhich we aren’t going to check …\n"],["read_packed","NMatrix::IO::Matlab::Mat5Reader::Compressed","NMatrix/IO/Matlab/Mat5Reader/Compressed.html#method-i-read_packed","(packedio, options)","<p><strong>Arguments</strong> :\n<p>++ -&gt;\n\n<p><strong>Returns</strong> : -\n"],["read_packed","NMatrix::IO::Matlab::Mat5Reader::Element","NMatrix/IO/Matlab/Mat5Reader/Element.html#method-i-read_packed","(packedio, options)",""],["read_packed","NMatrix::IO::Matlab::Mat5Reader::Header","NMatrix/IO/Matlab/Mat5Reader/Header.html#method-i-read_packed","(packedio, options)",""],["read_packed","NMatrix::IO::Matlab::Mat5Reader::MatrixData","NMatrix/IO/Matlab/Mat5Reader/MatrixData.html#method-i-read_packed","(packedio, options)","<p><strong>Arguments</strong> :\n<p>++ -&gt;\n\n<p><strong>Returns</strong> : -\n"],["read_packed","NMatrix::IO::Matlab::Mat5Reader::RawElement","NMatrix/IO/Matlab/Mat5Reader/RawElement.html#method-i-read_packed","(packedio, options)",""],["read_packed","NMatrix::IO::Matlab::Mat5Reader::Tag","NMatrix/IO/Matlab/Mat5Reader/Tag.html#method-i-read_packed","(packedio, options)",""],["repack","NMatrix::IO::Matlab","NMatrix/IO/Matlab.html#method-c-repack","(p1, p2, p3)","<p>Take a string of bytes which represent MATLAB data type values and repack\nthem into a string of bytes …\n"],["repacked_data","NMatrix::IO::Matlab::Mat5Reader::MatrixData","NMatrix/IO/Matlab/Mat5Reader/MatrixData.html#method-i-repacked_data","(to_dtype = nil)","<p>Unpacks and repacks data into the appropriate format for NMatrix.\n<p>If data is already in the appropriate …\n"],["repacked_indices","NMatrix::IO::Matlab::Mat5Reader::MatrixData","NMatrix/IO/Matlab/Mat5Reader/MatrixData.html#method-i-repacked_indices","(to_itype)","<p>Unpacks and repacks index data into the appropriate format for NMatrix.\n<p>If data is already in the appropriate …\n"],["rot","NMatrix::BLAS","NMatrix/BLAS.html#method-c-rot","(x, y, c, s, incx = 1, incy = 1, n = nil)","<p>Apply plane rotation.\n<p><strong>Arguments</strong> :\n<p><code>x</code> -&gt;\n"],["rows","NMatrix","NMatrix.html#method-i-rows","()","<p>This shortcut use #shape to return the number of rows (the first dimension)\nof the matrix.\n"],["save","NMatrix::IO::Market","NMatrix/IO/Market.html#method-c-save","(matrix, filename, options = {})","<p>Can optionally set :symmetry to :general, :symmetric, :hermitian; and can\nset :pattern =&gt; true if …\n"],["save_array","NMatrix::IO::Market","NMatrix/IO/Market.html#method-c-save_array","(matrix, file, symmetry)",""],["save_coordinate","NMatrix::IO::Market","NMatrix/IO/Market.html#method-c-save_coordinate","(matrix, file, symmetry, pattern)",""],["seek_and_read_file_header","NMatrix::IO::Matlab::Mat5Reader","NMatrix/IO/Matlab/Mat5Reader.html#method-i-seek_and_read_file_header","()",""],["seq","NMatrix","NMatrix.html#method-c-seq","(*params)","<p>Creates a matrix filled with a sequence of integers starting at zero.\n<p><strong>Arguments</strong> :\n<p><code>size</code> -&gt; Array (or ...\n"],["seq","NVector","NVector.html#method-c-seq","(n, dtype = :int64)","<p>Creates a vector with a sequence of <code>n</code> integers starting at\nzero. You can choose other types based on …\n"],["shape","NMatrix","NMatrix.html#method-i-shape","()","<p>Get the shape (dimensions) of a matrix.\n"],["size","NMatrix::IO::Matlab::Mat5Reader::Tag","NMatrix/IO/Matlab/Mat5Reader/Tag.html#method-i-size","()",""],["size","NVector","NVector.html#method-i-size","()","<p>shorthand for the dominant shape component\n"],["slice","NMatrix","NMatrix.html#method-i-slice","(*args)","<p>Access the contents of an NMatrix at given coordinates, using copying.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">n</span>.<span class=\"ruby-identifier\">slice</span>(<span class=\"ruby-value\">3</span>,<span class=\"ruby-value\">3</span>)  <span class=\"ruby-comment\"># =&gt; 5.0</span>\n<span class=\"ruby-identifier\">n</span>.<span class=\"ruby-identifier\">slice</span>(<span class=\"ruby-value\">0</span><span class=\"ruby-operator\">..</span><span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">0</span><span class=\"ruby-operator\">..</span><span class=\"ruby-value\">1</span>) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["small?","NMatrix::IO::Matlab::Mat5Reader::Tag","NMatrix/IO/Matlab/Mat5Reader/Tag.html#method-i-small-3F","()",""],["stype","NMatrix","NMatrix.html#method-i-stype","()","<p>Get the storage type (stype) of a matrix, e.g., :yale, :dense, or :list.\n"],["symmetric?","NMatrix","NMatrix.html#method-i-symmetric-3F","()","<p>Is this matrix symmetric?\n"],["to_a","NMatrix::IO::Matlab::Mat5Reader","NMatrix/IO/Matlab/Mat5Reader.html#method-i-to_a","()",""],["to_h","NMatrix","NMatrix.html#method-i-to_h","()",""],["to_hash","NMatrix","NMatrix.html#method-i-to_hash","()","<p>Create a Ruby Hash from an NMatrix.\n<p>Currently only works for list storage.\n"],["to_nm","Array","Array.html#method-i-to_nm","(shape, dtype = nil, stype = :dense)","<p>Convert a Ruby Array to an NMatrix.\n<p>You must provide a shape for the matrix as the first argument.\n<p>Arguments: …\n"],["to_nm","NMatrix::IO::Matlab::Mat5Reader::MatrixData","NMatrix/IO/Matlab/Mat5Reader/MatrixData.html#method-i-to_nm","(dtype = nil)","<p>Create an NMatrix from a MATLAB .mat (v5) matrix.\n<p>This function matches the storage type exactly. That …\n"],["to_ruby","NMatrix::IO::Matlab::Mat5Reader","NMatrix/IO/Matlab/Mat5Reader.html#method-i-to_ruby","()",""],["to_ruby","NMatrix::IO::Matlab::Mat5Reader::Element","NMatrix/IO/Matlab/Mat5Reader/Element.html#method-i-to_ruby","()",""],["to_ruby","NMatrix::IO::Matlab::Mat5Reader::MatrixData","NMatrix/IO/Matlab/Mat5Reader/MatrixData.html#method-i-to_ruby","()","<p>Figure out the appropriate Ruby type to convert to, and do it. There are\nbasically two possible types: …\n"],["to_s","NMatrix::IO::Matlab::Mat5Reader::ElementDataIOError","NMatrix/IO/Matlab/Mat5Reader/ElementDataIOError.html#method-i-to_s","()",""],["transpose","NMatrix","NMatrix.html#method-i-transpose","()","<p>Copy constructor for transposing.\n"],["transpose","NVector","NVector.html#method-i-transpose","()","<p>Returns a transposed copy of the vector.\n<p><strong>Returns</strong> :\n<p>NVector containing the transposed vector.\n"],["transpose!","NVector","NVector.html#method-i-transpose-21","()","<p>Transpose the vector in-place.\n<p><strong>Returns</strong> :\n<p>NVector containing the transposed vector.\n"],["unpacked_data","NMatrix::IO::Matlab::Mat5Reader::MatrixData","NMatrix/IO/Matlab/Mat5Reader/MatrixData.html#method-i-unpacked_data","(real_mdtype = nil, imag_mdtype = nil)","<p>Unpacks data without repacking it.\n<p>Used only for dense matrix creation. Yale matrix creation uses\nrepacked_data. …\n"],["upcast","NMatrix","NMatrix.html#method-c-upcast","(p1, p2)","<p>Given a binary operation between types t1 and t2, what type will be\nreturned?\n<p>This is a singleton method …\n"],["write","NMatrix","NMatrix.html#method-i-write","(*args)","<p>Binary file writer for NMatrix standard format. file should be a path,\nwhich we aren’t going to check …\n"],["write_packed","NMatrix::IO::Matlab::Mat5Reader::Compressed","NMatrix/IO/Matlab/Mat5Reader/Compressed.html#method-i-write_packed","(packedio, options = {})","<p><strong>Arguments</strong> :\n<p>++ -&gt;\n\n<p><strong>Returns</strong> : -\n"],["write_packed","NMatrix::IO::Matlab::Mat5Reader::Element","NMatrix/IO/Matlab/Mat5Reader/Element.html#method-i-write_packed","(packedio, options)",""],["write_packed","NMatrix::IO::Matlab::Mat5Reader::Header","NMatrix/IO/Matlab/Mat5Reader/Header.html#method-i-write_packed","(packedio, options)","<p>TODO: TEST WRITE.\n"],["write_packed","NMatrix::IO::Matlab::Mat5Reader::MatrixData","NMatrix/IO/Matlab/Mat5Reader/MatrixData.html#method-i-write_packed","(packedio, options)","<p><strong>Arguments</strong> :\n<p>++ -&gt;\n\n<p><strong>Returns</strong> : -\n"],["write_packed","NMatrix::IO::Matlab::Mat5Reader::Tag","NMatrix/IO/Matlab/Mat5Reader/Tag.html#method-i-write_packed","(packedio, options)","<p>TODO: TEST WRITE.\n"],["yale_a","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_a","()","<p>Get the A array of a Yale matrix (which stores the diagonal and the LU\nportions of the matrix).\n"],["yale_d","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_d","()","<p>Get the diagonal (“D”) portion of the A array of a Yale matrix.\n"],["yale_ia","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_ia","()","<p>Get the IA portion of the IJA array of a Yale matrix. This gives the start\nand end positions of rows …\n"],["yale_ija","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_ija","()","<p>Get the IJA array of a Yale matrix.\n"],["yale_ja","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_ja","()","<p>Get the JA portion of the IJA array of a Yale matrix. This gives the column\nindices for entries in corresponding …\n"],["yale_lu","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_lu","()","<p>Get the non-diagonal (“LU”) portion of the A array of a Yale matrix.\n"],["yale_size","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_size","()","<p>Get the size of a Yale matrix (the number of elements actually stored).\n<p>For capacity (the maximum number …\n"],["zeroes","NMatrix","NMatrix.html#method-c-zeroes","(*params)",""],["zeroes","NVector","NVector.html#method-c-zeroes","(size, dtype = :float64)",""],["zeros","NMatrix","NMatrix.html#method-c-zeros","(*params)","<p>Creates a new matrix of zeros with the dimensions supplied as parameters.\n<p><strong>Arguments</strong> :\n<p><code>stype</code> -&gt; (optional) ...\n"],["zeros","NVector","NVector.html#method-c-zeros","(size, dtype = :float64)","<p>Creates a new matrix of zeros with the dimensions supplied as parameters.\n<p><strong>Arguments</strong> :\n<p><code>size</code> -&gt; Array ...\n"],["History","","History_txt.html","","<p>0.0.1 / 2012-04-10\n<p>1 major enhancement\n<p>Initial alpha release\n"],["README","","README_rdoc.html","","<p>NMatrix\n<p>Fast Numerical Linear Algebra Library for Ruby\n<p>sciruby.com\n"],["binary_format","","ext/nmatrix/binary_format_txt.html","","<p>This is the proposed binary format for saving and loading NMatrix objects.\n<p>Order is little-endian.\n<p>List …\n"]]}}