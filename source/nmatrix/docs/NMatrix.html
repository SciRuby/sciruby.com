<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class NMatrix - RDoc Documentation</title>

<link href="./fonts.css" rel="stylesheet">
<link href="./rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
</script>

<script src="./js/jquery.js"></script>
<script src="./js/navigation.js"></script>
<script src="./js/search_index.js"></script>
<script src="./js/search.js"></script>
<script src="./js/searcher.js"></script>
<script src="./js/darkfish.js"></script>


<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="./index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="./table_of_contents.html#pages">Pages</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    <div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  
  <p class="link"><a href="Object.html">Object</a>
  
</div>

    <div id="includes-section" class="nav-section">
  <h3>Included Modules</h3>

  <ul class="link-list">
  
  
    <li><span class="include">Enumerable</span>
  
  
  </ul>
</div>

    
    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li ><a href="#method-c-guess_dtype">::guess_dtype</a>
    
    <li ><a href="#method-c-min_dtype">::min_dtype</a>
    
    <li ><a href="#method-c-new">::new</a>
    
    <li ><a href="#method-c-read">::read</a>
    
    <li ><a href="#method-c-upcast">::upcast</a>
    
    <li ><a href="#method-i-3D-3D">#==</a>
    
    <li ><a href="#method-i-5B-5D">#[]</a>
    
    <li ><a href="#method-i-5B-5D-3D">#[]=</a>
    
    <li ><a href="#method-i-abs">#abs</a>
    
    <li ><a href="#method-i-abs_dtype">#abs_dtype</a>
    
    <li ><a href="#method-i-absolute_sum">#absolute_sum</a>
    
    <li ><a href="#method-i-asum">#asum</a>
    
    <li ><a href="#method-i-binned_sorted_indices">#binned_sorted_indices</a>
    
    <li ><a href="#method-i-capacity">#capacity</a>
    
    <li ><a href="#method-i-cast">#cast</a>
    
    <li ><a href="#method-i-cast_full">#cast_full</a>
    
    <li ><a href="#method-i-clone_structure">#clone_structure</a>
    
    <li ><a href="#method-i-col">#col</a>
    
    <li ><a href="#method-i-cols">#cols</a>
    
    <li ><a href="#method-i-column">#column</a>
    
    <li ><a href="#method-i-complex_conjugate">#complex_conjugate</a>
    
    <li ><a href="#method-i-complex_conjugate-21">#complex_conjugate!</a>
    
    <li ><a href="#method-i-concat">#concat</a>
    
    <li ><a href="#method-i-conjugate_transpose">#conjugate_transpose</a>
    
    <li ><a href="#method-i-data_pointer">#data_pointer</a>
    
    <li ><a href="#method-i-dconcat">#dconcat</a>
    
    <li ><a href="#method-i-default_value">#default_value</a>
    
    <li ><a href="#method-i-dense-3F">#dense?</a>
    
    <li ><a href="#method-i-det">#det</a>
    
    <li ><a href="#method-i-det_exact">#det_exact</a>
    
    <li ><a href="#method-i-diagonal">#diagonal</a>
    
    <li ><a href="#method-i-dim">#dim</a>
    
    <li ><a href="#method-i-dimensions">#dimensions</a>
    
    <li ><a href="#method-i-dot">#dot</a>
    
    <li ><a href="#method-i-dtype">#dtype</a>
    
    <li ><a href="#method-i-dtype_for_floor_or_ceil">#dtype_for_floor_or_ceil</a>
    
    <li ><a href="#method-i-each">#each</a>
    
    <li ><a href="#method-i-each_along_dim">#each_along_dim</a>
    
    <li ><a href="#method-i-each_column">#each_column</a>
    
    <li ><a href="#method-i-each_layer">#each_layer</a>
    
    <li ><a href="#method-i-each_ordered_stored_with_indices">#each_ordered_stored_with_indices</a>
    
    <li ><a href="#method-i-each_rank">#each_rank</a>
    
    <li ><a href="#method-i-each_row">#each_row</a>
    
    <li ><a href="#method-i-each_stored_with_index">#each_stored_with_index</a>
    
    <li ><a href="#method-i-each_stored_with_indices">#each_stored_with_indices</a>
    
    <li ><a href="#method-i-each_with_indices">#each_with_indices</a>
    
    <li ><a href="#method-i-effective_dim">#effective_dim</a>
    
    <li ><a href="#method-i-effective_dimensions">#effective_dimensions</a>
    
    <li ><a href="#method-i-eye">#eye</a>
    
    <li ><a href="#method-i-factorize_cholesky">#factorize_cholesky</a>
    
    <li ><a href="#method-i-factorize_lu">#factorize_lu</a>
    
    <li ><a href="#method-i-flat_map">#flat_map</a>
    
    <li ><a href="#method-i-gesdd">#gesdd</a>
    
    <li ><a href="#method-i-gesdd-21">#gesdd!</a>
    
    <li ><a href="#method-i-gesvd">#gesvd</a>
    
    <li ><a href="#method-i-gesvd-21">#gesvd!</a>
    
    <li ><a href="#method-i-getrf">#getrf</a>
    
    <li ><a href="#method-i-getrf-21">#getrf!</a>
    
    <li ><a href="#method-i-hconcat">#hconcat</a>
    
    <li ><a href="#method-i-hermitian-3F">#hermitian?</a>
    
    <li ><a href="#method-i-initialize_copy">#initialize_copy</a>
    
    <li ><a href="#method-i-inject_along_dim">#inject_along_dim</a>
    
    <li ><a href="#method-i-inject_rank">#inject_rank</a>
    
    <li ><a href="#method-i-integer_dtype-3F">#integer_dtype?</a>
    
    <li ><a href="#method-i-inverse">#inverse</a>
    
    <li ><a href="#method-i-invert">#invert</a>
    
    <li ><a href="#method-i-invert-21">#invert!</a>
    
    <li ><a href="#method-i-is_ref-3F">#is_ref?</a>
    
    <li ><a href="#method-i-laswp">#laswp</a>
    
    <li ><a href="#method-i-laswp-21">#laswp!</a>
    
    <li ><a href="#method-i-layer">#layer</a>
    
    <li ><a href="#method-i-list-3F">#list?</a>
    
    <li ><a href="#method-i-load_matlab_file">#load_matlab_file</a>
    
    <li ><a href="#method-i-load_pcd_file">#load_pcd_file</a>
    
    <li ><a href="#method-i-log">#log</a>
    
    <li ><a href="#method-i-lower_triangle">#lower_triangle</a>
    
    <li ><a href="#method-i-lower_triangle-21">#lower_triangle!</a>
    
    <li ><a href="#method-i-map">#map</a>
    
    <li ><a href="#method-i-map-21">#map!</a>
    
    <li ><a href="#method-i-map_stored">#map_stored</a>
    
    <li ><a href="#method-i-max">#max</a>
    
    <li ><a href="#method-i-mean">#mean</a>
    
    <li ><a href="#method-i-min">#min</a>
    
    <li ><a href="#method-i-norm2">#norm2</a>
    
    <li ><a href="#method-i-nrm2">#nrm2</a>
    
    <li ><a href="#method-i-nvector-3F">#nvector?</a>
    
    <li ><a href="#method-i-offset">#offset</a>
    
    <li ><a href="#method-i-ones">#ones</a>
    
    <li ><a href="#method-i-ones_like">#ones_like</a>
    
    <li ><a href="#method-i-permute_columns">#permute_columns</a>
    
    <li ><a href="#method-i-permute_columns-21">#permute_columns!</a>
    
    <li ><a href="#method-i-potrf-21">#potrf!</a>
    
    <li ><a href="#method-i-potrf_lower-21">#potrf_lower!</a>
    
    <li ><a href="#method-i-potrf_upper-21">#potrf_upper!</a>
    
    <li ><a href="#method-i-random">#random</a>
    
    <li ><a href="#method-i-rank">#rank</a>
    
    <li ><a href="#method-i-reduce_along_dim">#reduce_along_dim</a>
    
    <li ><a href="#method-i-reshape">#reshape</a>
    
    <li ><a href="#method-i-reshape-21">#reshape!</a>
    
    <li ><a href="#method-i-row">#row</a>
    
    <li ><a href="#method-i-rows">#rows</a>
    
    <li ><a href="#method-i-seq">#seq</a>
    
    <li ><a href="#method-i-shape">#shape</a>
    
    <li ><a href="#method-i-shuffle">#shuffle</a>
    
    <li ><a href="#method-i-shuffle-21">#shuffle!</a>
    
    <li ><a href="#method-i-size">#size</a>
    
    <li ><a href="#method-i-slice">#slice</a>
    
    <li ><a href="#method-i-sorted_indices">#sorted_indices</a>
    
    <li ><a href="#method-i-std">#std</a>
    
    <li ><a href="#method-i-stype">#stype</a>
    
    <li ><a href="#method-i-sum">#sum</a>
    
    <li ><a href="#method-i-supershape">#supershape</a>
    
    <li ><a href="#method-i-symmetric-3F">#symmetric?</a>
    
    <li ><a href="#method-i-to_a">#to_a</a>
    
    <li ><a href="#method-i-to_f">#to_f</a>
    
    <li ><a href="#method-i-to_flat_a">#to_flat_a</a>
    
    <li ><a href="#method-i-to_flat_array">#to_flat_array</a>
    
    <li ><a href="#method-i-to_h">#to_h</a>
    
    <li ><a href="#method-i-to_hash">#to_hash</a>
    
    <li ><a href="#method-i-transpose">#transpose</a>
    
    <li ><a href="#method-i-tril">#tril</a>
    
    <li ><a href="#method-i-tril-21">#tril!</a>
    
    <li ><a href="#method-i-triu">#triu</a>
    
    <li ><a href="#method-i-triu-21">#triu!</a>
    
    <li ><a href="#method-i-upper_triangle">#upper_triangle</a>
    
    <li ><a href="#method-i-upper_triangle-21">#upper_triangle!</a>
    
    <li ><a href="#method-i-variance">#variance</a>
    
    <li ><a href="#method-i-vconcat">#vconcat</a>
    
    <li ><a href="#method-i-vector-3F">#vector?</a>
    
    <li ><a href="#method-i-write">#write</a>
    
    <li ><a href="#method-i-yale-3F">#yale?</a>
    
    <li ><a href="#method-i-zeros">#zeros</a>
    
    <li ><a href="#method-i-zeros_like">#zeros_like</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-NMatrix">
  <h1 id="class-NMatrix" class="class">
    class NMatrix
  </h1>

  <section class="description">
    
<p><a href="NMatrix.html">NMatrix</a> is a multidimensional array with support
to both dense and sparse storage and 13 data types, including complex and
rational numbers, various integer and floating-point sizes and ruby
objects.</p>

  </section>

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    

    

    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

    
      <div id="method-c-guess_dtype" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">guess_dtype</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Guess the dtype given a Ruby VALUE and return it as a symbol.</p>

<p>Not to be confused with nm_dtype_guess, which returns an nm::dtype_t. (This
calls that.)</p>
          
          

          
          <div class="method-source-code" id="guess_dtype-source">
            <pre>static VALUE nm_guess_dtype(VALUE self, VALUE v) {
  return ID2SYM(rb_intern(DTYPE_NAMES[nm_dtype_guess(v)]));
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-min_dtype" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">min_dtype</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Get the minimum allowable dtype for a Ruby VALUE and return it as a symbol.</p>
          
          

          
          <div class="method-source-code" id="min_dtype-source">
            <pre>static VALUE nm_min_dtype(VALUE self, VALUE v) {
  return ID2SYM(rb_intern(DTYPE_NAMES[nm_dtype_min(v)]));
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-new" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            new(shape) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            new(shape, initial_value) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            new(shape, initial_array) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            new(shape, initial_value, options) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            new(shape, initial_array, options) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Create a new <a href="NMatrix.html">NMatrix</a>.</p>

<p>The only mandatory argument is shape, which may be a positive integer or an
array of positive integers.</p>

<p>It is recommended that you supply an initialization value or array of
values. Without one, Yale and List matrices will be initialized to 0; and
dense matrices will be undefined.</p>

<p>Additional options may be provided using keyword arguments. The keywords
are +:dtype, <code>:stype</code>, <code>:capacity</code>, and
<code>:default</code>. Only Yale uses a capacity argument, which is used to
reserve the initial size of its storage vectors. List and Yale both accept
a default value (which itself defaults to 0). This default is taken from
the initial value if such a value is given; it is more likely to be
required when an initial array is provided.</p>

<p>The storage type, or stype, is used to specify whether we want a
<code>:dense</code>, <code>:list</code>, or <code>:yale</code> matrix;
dense is the default.</p>

<p>The data type, or dtype, can be one of: :byte, :int8, :int16, :int32,
:int64, :float32, :float64, :complex64, :complex128, :rational128, or
:object. The constructor will attempt to guess it from the initial
value/array/default provided, if any. Otherwise, the default is :object,
which stores any type of Ruby object.</p>

<p>In addition to the above, there is a legacy constructor from the alpha
version. To use that version, you must be providing exactly four arguments.
It is now deprecated.</p>

<p>There is one additional constructor for advanced users, which takes seven
arguments and is only for creating Yale matrices with known IA, JA, and A
arrays. This is used primarily internally for IO, e.g., reading Matlab
matrices, which are stored in old Yale (not our Yale) format. But be
careful; there are no overflow warnings. All of these constructors are
defined for power-users. Everyone else should probably resort to the
shortcut functions defined in shortcuts.rb.</p>
          
          

          
          <div class="method-source-code" id="new-source">
            <pre>static VALUE nm_init(int argc, VALUE* argv, VALUE nm) {
  NM_CONSERVATIVE(nm_register_value(nm));
  NM_CONSERVATIVE(nm_register_values(argv, argc));

  if (argc &lt;= 3) { // Call the new constructor unless all four arguments are given (or the 7-arg version is given)
    NM_CONSERVATIVE(nm_unregister_values(argv, argc));
    NM_CONSERVATIVE(nm_unregister_value(nm));
        return nm_init_new_version(argc, argv, nm);
  }

  /* First, determine stype (dense by default) */
  nm::stype_t stype;
  size_t  offset = 0;

  if (!SYMBOL_P(argv[0]) &amp;&amp; TYPE(argv[0]) != T_STRING) {
    stype = nm::DENSE_STORE;

  } else {
    // 0: String or Symbol
    stype  = interpret_stype(argv[0]);
    offset = 1;
  }

  // If there are 7 arguments and Yale, refer to a different init function with fewer sanity checks.
  if (argc == 7) {
    if (stype == nm::YALE_STORE) {
      NM_CONSERVATIVE(nm_unregister_values(argv, argc));
      NM_CONSERVATIVE(nm_unregister_value(nm));
      return nm_init_yale_from_old_yale(argv[1], argv[2], argv[3], argv[4], argv[5], argv[6], nm);

    } else {
      NM_CONSERVATIVE(nm_unregister_values(argv, argc));
      NM_CONSERVATIVE(nm_unregister_value(nm));
      rb_raise(rb_eArgError, &quot;Expected 2-4 arguments (or 7 for internal Yale creation)&quot;);
    }
  }

  // 1: Array or Fixnum
  size_t dim;
  size_t* shape = interpret_shape(argv[offset], &amp;dim);

  // 2-3: dtype
  nm::dtype_t dtype = interpret_dtype(argc-1-offset, argv+offset+1, stype);

  size_t init_cap = 0, init_val_len = 0;
  void* init_val  = NULL;
  if (!SYMBOL_P(argv[1+offset]) || TYPE(argv[1+offset]) == T_ARRAY) {
        // Initial value provided (could also be initial capacity, if yale).

    if (stype == nm::YALE_STORE &amp;&amp; NM_RUBYVAL_IS_NUMERIC(argv[1+offset])) {
      init_cap = FIX2UINT(argv[1+offset]);

    } else {
        // 4: initial value / dtype
      init_val = interpret_initial_value(argv[1+offset], dtype);

      if (TYPE(argv[1+offset]) == T_ARRAY)      init_val_len = RARRAY_LEN(argv[1+offset]);
      else                                  init_val_len = 1;
    }

  } else {
        // DType is RUBYOBJ.

    if (stype == nm::DENSE_STORE) {
        /*
         * No need to initialize dense with any kind of default value unless it&#39;s
         * an RUBYOBJ matrix.
         */
      if (dtype == nm::RUBYOBJ) {
        // Pretend [nil] was passed for RUBYOBJ.
        init_val = NM_ALLOC(VALUE);
        *(VALUE*)init_val = Qnil;

        init_val_len = 1;

      } else {
        init_val = NULL;
      }
    } else if (stype == nm::LIST_STORE) {
      init_val = NM_ALLOC_N(char, DTYPE_SIZES[dtype]);
      std::memset(init_val, 0, DTYPE_SIZES[dtype]);
    }
  }

  if (dtype == nm::RUBYOBJ) {
    nm_register_values(reinterpret_cast&lt;VALUE*&gt;(init_val), init_val_len);
  }

  // TODO: Update to allow an array as the initial value.
  NMATRIX* nmatrix;
  UnwrapNMatrix(nm, nmatrix);

  nmatrix-&gt;stype = stype;

  switch (stype) {
    case nm::DENSE_STORE:
      nmatrix-&gt;storage = (STORAGE*)nm_dense_storage_create(dtype, shape, dim, init_val, init_val_len);
      break;

    case nm::LIST_STORE:
      nmatrix-&gt;storage = (STORAGE*)nm_list_storage_create(dtype, shape, dim, init_val);
      break;

    case nm::YALE_STORE:
      nmatrix-&gt;storage = (STORAGE*)nm_yale_storage_create(dtype, shape, dim, init_cap);
      nm_yale_storage_init((YALE_STORAGE*)(nmatrix-&gt;storage), NULL);
      break;
  }

  if (dtype == nm::RUBYOBJ) {
    nm_unregister_values(reinterpret_cast&lt;VALUE*&gt;(init_val), init_val_len);
  }

  NM_CONSERVATIVE(nm_unregister_values(argv, argc));
  NM_CONSERVATIVE(nm_unregister_value(nm));

  return nm;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-read" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">read</span><span
            class="method-args">(p1, p2 = v2)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Binary file reader for <a href="NMatrix.html">NMatrix</a> standard format.
file should be a path, which we aren&#39;t going to check very carefully
(in other words, this function should generally be called from a Ruby
helper method).</p>

<p>Note that currently, this function will by default refuse to read files
that are newer than your version of <a href="NMatrix.html">NMatrix</a>. To
force an override, set the second argument to anything other than nil.</p>

<p>Returns an <a href="NMatrix.html">NMatrix</a> Ruby object.</p>
          
          

          
          <div class="method-source-code" id="read-source">
            <pre>static VALUE nm_read(int argc, VALUE* argv, VALUE self) {
  using std::ifstream;

  NM_CONSERVATIVE(nm_register_values(argv, argc));
  NM_CONSERVATIVE(nm_register_value(self));

  VALUE file, force_;

  // Read the arguments
  rb_scan_args(argc, argv, &quot;11&quot;, &amp;file, &amp;force_);
  bool force   = (force_ != Qnil &amp;&amp; force_ != Qfalse);


  if (!RB_FILE_EXISTS(file)) { // FIXME: Errno::ENOENT
    NM_CONSERVATIVE(nm_unregister_values(argv, argc));
    NM_CONSERVATIVE(nm_unregister_value(self));
    rb_raise(rb_get_errno_exc(&quot;ENOENT&quot;), &quot;%s&quot;, RSTRING_PTR(file));
  }

  // Open a file stream
  ifstream f(RSTRING_PTR(file), std::ios::in | std::ios::binary);

  uint16_t major, minor, release;
  get_version_info(major, minor, release); // compare to NMatrix version

  uint16_t fmajor, fminor, frelease, null16;

  // READ FIRST 64-BIT BLOCK
  f.read(reinterpret_cast&lt;char*&gt;(&amp;fmajor),   sizeof(uint16_t));
  f.read(reinterpret_cast&lt;char*&gt;(&amp;fminor),   sizeof(uint16_t));
  f.read(reinterpret_cast&lt;char*&gt;(&amp;frelease), sizeof(uint16_t));
  f.read(reinterpret_cast&lt;char*&gt;(&amp;null16),   sizeof(uint16_t));

  int ver  = major * 10000 + minor * 100 + release,
      fver = fmajor * 10000 + fminor * 100 + release;
  if (fver &gt; ver &amp;&amp; force == false) {
    NM_CONSERVATIVE(nm_unregister_values(argv, argc));
    NM_CONSERVATIVE(nm_unregister_value(self));
    rb_raise(rb_eIOError, &quot;File was created in newer version of NMatrix than current (%u.%u.%u)&quot;, fmajor, fminor, frelease);
  }
  if (null16 != 0) rb_warn(&quot;nm_read: Expected zero padding was not zero (0)\n&quot;);

  uint8_t dt, st, it, sm;
  uint16_t dim;

  // READ SECOND 64-BIT BLOCK
  f.read(reinterpret_cast&lt;char*&gt;(&amp;dt), sizeof(uint8_t));
  f.read(reinterpret_cast&lt;char*&gt;(&amp;st), sizeof(uint8_t));
  f.read(reinterpret_cast&lt;char*&gt;(&amp;it), sizeof(uint8_t)); // FIXME: should tell how few bytes indices are stored as
  f.read(reinterpret_cast&lt;char*&gt;(&amp;sm), sizeof(uint8_t));
  f.read(reinterpret_cast&lt;char*&gt;(&amp;null16), sizeof(uint16_t));
  f.read(reinterpret_cast&lt;char*&gt;(&amp;dim), sizeof(uint16_t));

  if (null16 != 0) rb_warn(&quot;nm_read: Expected zero padding was not zero (1)&quot;);
  nm::stype_t stype = static_cast&lt;nm::stype_t&gt;(st);
  nm::dtype_t dtype = static_cast&lt;nm::dtype_t&gt;(dt);
  nm::symm_t  symm  = static_cast&lt;nm::symm_t&gt;(sm);
  //nm::itype_t itype = static_cast&lt;nm::itype_t&gt;(it);

  // READ NEXT FEW 64-BIT BLOCKS
  size_t* shape = NM_ALLOC_N(size_t, dim);
  read_padded_shape(f, dim, shape);

  STORAGE* s;
  if (stype == nm::DENSE_STORE) {
    s = nm_dense_storage_create(dtype, shape, dim, NULL, 0);
    nm_register_storage(stype, s);

    read_padded_dense_elements(f, reinterpret_cast&lt;DENSE_STORAGE*&gt;(s), symm, dtype);

  } else if (stype == nm::YALE_STORE) {
    uint32_t ndnz, length;

    // READ YALE-SPECIFIC 64-BIT BLOCK
    f.read(reinterpret_cast&lt;char*&gt;(&amp;ndnz),     sizeof(uint32_t));
    f.read(reinterpret_cast&lt;char*&gt;(&amp;length),   sizeof(uint32_t));

    s = nm_yale_storage_create(dtype, shape, dim, length); // set length as init capacity

    nm_register_storage(stype, s);

    read_padded_yale_elements(f, reinterpret_cast&lt;YALE_STORAGE*&gt;(s), length, symm, dtype);
  } else {
    NM_CONSERVATIVE(nm_unregister_values(argv, argc));
    NM_CONSERVATIVE(nm_unregister_value(self));
    rb_raise(nm_eStorageTypeError, &quot;please convert to yale or dense before saving&quot;);
  }

  NMATRIX* nm = nm_create(stype, s);

  // Return the appropriate matrix object (Ruby VALUE)
  // FIXME: This should probably return CLASS_OF(self) instead of cNMatrix, but I don&#39;t know how that works for
  // FIXME: class methods.
  nm_register_nmatrix(nm);
  VALUE to_return = Data_Wrap_Struct(cNMatrix, nm_mark, nm_delete, nm);

  nm_unregister_nmatrix(nm);
  NM_CONSERVATIVE(nm_unregister_values(argv, argc));
  NM_CONSERVATIVE(nm_unregister_value(self));
  nm_unregister_storage(stype, s);

  switch(stype) {
  case nm::DENSE_STORE:
  case nm::YALE_STORE:
    return to_return;
  default: // this case never occurs (due to earlier rb_raise)
    return Qnil;
  }

}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-upcast" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            upcast(first_dtype, second_dtype) &rarr; Symbol
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Given a binary operation between types t1 and t2, what type will be
returned?</p>

<p>This is a singleton method on <a href="NMatrix.html">NMatrix</a>, e.g., <a
href="NMatrix.html#method-c-upcast">::upcast</a>(:int32, :int64)</p>
          
          

          
          <div class="method-source-code" id="upcast-source">
            <pre>static VALUE nm_upcast(VALUE self, VALUE t1, VALUE t2) {
  nm::dtype_t d1    = nm_dtype_from_rbsymbol(t1),
              d2    = nm_dtype_from_rbsymbol(t2);

  return ID2SYM(rb_intern( DTYPE_NAMES[ Upcast[d1][d2] ] ));
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

    
      <div id="method-i-3D-3D" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">==</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Equality operator. Returns a single true or false value indicating whether
the matrices are equivalent.</p>

<p>For elementwise, use =~ instead.</p>

<p>This method will raise an exception if dimensions do not match.</p>

<p>When stypes differ, this function calls a protected Ruby method.</p>
          
          

          
          <div class="method-source-code" id="3D-3D-source">
            <pre>static VALUE nm_eqeq(VALUE left, VALUE right) {
  NM_CONSERVATIVE(nm_register_value(left));
  NM_CONSERVATIVE(nm_register_value(right));

  NMATRIX *l, *r;

  CheckNMatrixType(left);
  CheckNMatrixType(right);

  UnwrapNMatrix(left, l);
  UnwrapNMatrix(right, r);

  bool result = false;

  if (l-&gt;stype != r-&gt;stype) { // DIFFERENT STYPES

    if (l-&gt;stype == nm::DENSE_STORE)
      result = rb_funcall(left, rb_intern(&quot;dense_eql_sparse?&quot;), 1, right);
    else if (r-&gt;stype == nm::DENSE_STORE)
      result = rb_funcall(right, rb_intern(&quot;dense_eql_sparse?&quot;), 1, left);
    else
      result = rb_funcall(left, rb_intern(&quot;sparse_eql_sparse?&quot;), 1, right);

  } else {

    switch(l-&gt;stype) {       // SAME STYPES
    case nm::DENSE_STORE:
      result = nm_dense_storage_eqeq(l-&gt;storage, r-&gt;storage);
      break;
    case nm::LIST_STORE:
      result = nm_list_storage_eqeq(l-&gt;storage, r-&gt;storage);
      break;
    case nm::YALE_STORE:
      result = nm_yale_storage_eqeq(l-&gt;storage, r-&gt;storage);
      break;
    }
  }

  NM_CONSERVATIVE(nm_unregister_value(left));
  NM_CONSERVATIVE(nm_unregister_value(right));

  return result ? Qtrue : Qfalse;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-5B-5D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            matrix[indices] &rarr; ...
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Access the contents of an <a href="NMatrix.html">NMatrix</a> at given
coordinates by reference.</p>

<pre class="ruby"><span class="ruby-identifier">n</span>[<span class="ruby-value">3</span>,<span class="ruby-value">3</span>]  <span class="ruby-comment"># =&gt; 5.0</span>
<span class="ruby-identifier">n</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>,<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>] <span class="ruby-comment">#=&gt; matrix [2,2]</span>
</pre>
          
          

          
          <div class="method-source-code" id="5B-5D-source">
            <pre>static VALUE nm_mref(int argc, VALUE* argv, VALUE self) {
  static void* (*ttable[nm::NUM_STYPES])(const STORAGE*, SLICE*) = {
    nm_dense_storage_ref,
    nm_list_storage_ref,
    nm_yale_storage_ref
  };
  nm::stype_t stype = NM_STYPE(self);
  return nm_xslice(argc, argv, ttable[stype], nm_delete_ref, self);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-5B-5D-3D" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">[]=</span><span
            class="method-args">(*args)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Modify the contents of an <a href="NMatrix.html">NMatrix</a> in the given
cell</p>

<pre>n[3,3] = 5.0</pre>

<p>Also returns the new contents, so you can chain:</p>

<pre>n[3,3] = n[2,3] = 5.0</pre>
          
          

          
          <div class="method-source-code" id="5B-5D-3D-source">
            <pre>static VALUE nm_mset(int argc, VALUE* argv, VALUE self) {

  size_t dim = NM_DIM(self); // last arg is the value

  VALUE to_return = Qnil;

  if ((size_t)(argc) &gt; NM_DIM(self)+1) {
    rb_raise(rb_eArgError, &quot;wrong number of arguments (%d for %lu)&quot;, argc, effective_dim(NM_STORAGE(self))+1);
  } else {
    NM_CONSERVATIVE(nm_register_value(self));
    NM_CONSERVATIVE(nm_register_values(argv, argc));

    SLICE* slice = get_slice(dim, argc-1, argv, NM_STORAGE(self)-&gt;shape);

    static void (*ttable[nm::NUM_STYPES])(VALUE, SLICE*, VALUE) = {
      nm_dense_storage_set,
      nm_list_storage_set,
      nm_yale_storage_set
    };

    ttable[NM_STYPE(self)](self, slice, argv[argc-1]);

    free_slice(slice);

    to_return = argv[argc-1];

    NM_CONSERVATIVE(nm_unregister_value(self));
    NM_CONSERVATIVE(nm_unregister_values(argv, argc));
  }

  return to_return;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-abs" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            abs &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Maps all values in a matrix to their absolute values.</p>
          
          

          
          <div class="method-source-code" id="abs-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 499</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">abs</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dense</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">__dense_map__</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">v</span>.<span class="ruby-identifier">abs</span> }
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:list</span>
    <span class="ruby-comment"># FIXME: Need __list_map_stored__, but this will do for now.</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">__list_map_merged_stored__</span>(<span class="ruby-keyword">nil</span>, <span class="ruby-keyword">nil</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">v</span>,<span class="ruby-identifier">dummy</span><span class="ruby-operator">|</span> <span class="ruby-identifier">v</span>.<span class="ruby-identifier">abs</span> }
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">__yale_map_stored__</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">v</span>.<span class="ruby-identifier">abs</span> }
  <span class="ruby-keyword">end</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span>, <span class="ruby-identifier">abs_dtype</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-abs_dtype" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            abs_dtype &rarr; Symbol
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the dtype of the result of a call to <a
href="NMatrix.html#method-i-abs">abs</a>. In most cases, this is the same
as dtype; it should only differ for :complex64 (where it&#39;s :float32)
and :complex128 (:float64).</p>
          
          

          
          <div class="method-source-code" id="abs_dtype-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 483</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">abs_dtype</span>
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:complex64</span>
    <span class="ruby-value">:float32</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:complex128</span>
    <span class="ruby-value">:float64</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-absolute_sum" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">absolute_sum</span><span
            class="method-args">(incx=1, n=nil)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-asum">asum</a>
        </div>
        
      </div>

    
      <div id="method-i-asum" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            absolute_sum &rarr; Numeric
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <h2 id="method-i-asum-label-Arguments">Arguments<span><a href="#method-i-asum-label-Arguments">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<pre>- +incx+ -&gt; the skip size (defaults to 1, no skip)
- +n+ -&gt; the number of elements to include</pre>

<p>Return the sum of the contents of the vector. This is the BLAS asum
routine.</p>
          
          

          
          <div class="method-source-code" id="asum-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 520</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">asum</span> <span class="ruby-identifier">incx</span>=<span class="ruby-value">1</span>, <span class="ruby-identifier">n</span>=<span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">method_missing</span>(<span class="ruby-value">:asum</span>, <span class="ruby-identifier">incx</span>, <span class="ruby-identifier">n</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">vector?</span>
  <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">BLAS</span><span class="ruby-operator">::</span><span class="ruby-identifier">asum</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">incx</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">/</span> <span class="ruby-identifier">incx</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-absolute_sum">absolute_sum</a>
        </div>
        

        
      </div>

    
      <div id="method-i-binned_sorted_indices" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            binned_sorted_indices &rarr; Array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an array of arrays of indices ordered by value sorted. Functions
basically like <code>sorted_indices</code>, but groups indices together for
those values that are the same.</p>
          
          

          
          <div class="method-source-code" id="binned_sorted_indices-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 783</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">binned_sorted_indices</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">method_missing</span>(<span class="ruby-value">:sorted_indices</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">vector?</span>
  <span class="ruby-identifier">ary</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">to_flat_array</span>
  <span class="ruby-identifier">ary2</span> = []
  <span class="ruby-identifier">last_bin</span> = <span class="ruby-identifier">ary</span>.<span class="ruby-identifier">each_index</span>.<span class="ruby-identifier">sort_by</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> [<span class="ruby-identifier">ary</span>[<span class="ruby-identifier">i</span>]] }.<span class="ruby-identifier">inject</span>([]) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">result</span>, <span class="ruby-identifier">element</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">result</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">ary</span>[<span class="ruby-identifier">result</span>[<span class="ruby-value">-1</span>]] <span class="ruby-operator">==</span> <span class="ruby-identifier">ary</span>[<span class="ruby-identifier">element</span>]
      <span class="ruby-identifier">result</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">element</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">ary2</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">result</span>
      [<span class="ruby-identifier">element</span>]
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">ary2</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">last_bin</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">last_bin</span>.<span class="ruby-identifier">empty?</span>
  <span class="ruby-identifier">ary2</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-capacity" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">capacity</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Find the capacity of an <a href="NMatrix.html">NMatrix</a>. The capacity
only differs from the size for Yale matrices, which occasionally allocate
more space than they need. For list and dense, capacity gives the number of
elements in the matrix.</p>

<p>If you call this on a slice, it may behave unpredictably. Most likely
it&#39;ll just return the original matrix&#39;s capacity.</p>
          
          

          
          <div class="method-source-code" id="capacity-source">
            <pre>static VALUE nm_capacity(VALUE self) {
  NM_CONSERVATIVE(nm_register_value(self));
  VALUE cap;

  switch(NM_STYPE(self)) {
  case nm::YALE_STORE:
    cap = UINT2NUM(reinterpret_cast&lt;YALE_STORAGE*&gt;(NM_STORAGE_YALE(self)-&gt;src)-&gt;capacity);
    break;

  case nm::DENSE_STORE:
    cap = UINT2NUM(nm_storage_count_max_elements( NM_STORAGE_DENSE(self) ));
    break;

  case nm::LIST_STORE:
    cap = UINT2NUM(nm_list_storage_count_elements( NM_STORAGE_LIST(self) ));
    break;

  default:
    NM_CONSERVATIVE(nm_unregister_value(self));
    rb_raise(nm_eStorageTypeError, &quot;unrecognized stype in nm_capacity()&quot;);
  }

  NM_CONSERVATIVE(nm_unregister_value(self));
  return cap;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-cast" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            cast(stype, dtype, default) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            cast(stype, dtype) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            cast(stype) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            cast(options) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>This is a user-friendly helper for calling <a
href="NMatrix.html#method-i-cast_full">cast_full</a>. The easiest way to
call this function is using an options hash, e.g.,</p>

<pre class="ruby"><span class="ruby-identifier">n</span>.<span class="ruby-identifier">cast</span>(:<span class="ruby-identifier">stype</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">yale</span>, :<span class="ruby-identifier">dtype</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">int64</span>, :<span class="ruby-identifier">default</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">false</span>)
</pre>

<p>For list and yale, :default sets the “default value” or “init” of the
matrix. List allows a bit more freedom since non-zeros are permitted. For
yale, unpredictable behavior may result if the value is not false, nil, or
some version of 0. Dense discards :default.</p>

<p>dtype and stype are inferred from the matrix upon which <a
href="NMatrix.html#method-i-cast">cast</a> is called – so you only really
need to provide one. You can actually call this function with no arguments,
in which case it functions like clone.</p>

<p>If your dtype is :object and you are converting from :dense to a sparse
type, it is recommended that you provide a :default, as 0 may behave
differently from its Float, Rational, or Complex equivalent. If no option
is given, Fixnum 0 will be used.</p>
          
          

          
          <div class="method-source-code" id="cast-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 153</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">cast</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">params</span>)
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">params</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">params</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Hash</span>))
    <span class="ruby-identifier">opts</span> = {
        <span class="ruby-value">:stype</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span>,
        <span class="ruby-value">:dtype</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>,
        <span class="ruby-value">:default</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dense</span> <span class="ruby-operator">?</span> <span class="ruby-value">0</span> <span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">default_value</span>
    }.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">params</span>[<span class="ruby-value">0</span>])

    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">cast_full</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:stype</span>], <span class="ruby-identifier">opts</span>[<span class="ruby-value">:dtype</span>], <span class="ruby-identifier">opts</span>[<span class="ruby-value">:default</span>])
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">params</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">params</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
    <span class="ruby-identifier">params</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">params</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
    <span class="ruby-comment">#HACK: the default value can cause an exception if dtype is not complex</span>
    <span class="ruby-comment">#and default_value is. (The ruby C code apparently won&#39;t convert these.)</span>
    <span class="ruby-comment">#Perhaps this should be fixed in the C code (in rubyval_to_cval).</span>
    <span class="ruby-identifier">default_value</span> = <span class="ruby-identifier">maybe_get_noncomplex_default_value</span>(<span class="ruby-identifier">params</span>[<span class="ruby-value">1</span>])
    <span class="ruby-identifier">params</span> <span class="ruby-operator">&lt;&lt;</span> (<span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dense</span> <span class="ruby-operator">?</span> <span class="ruby-value">0</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">default_value</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">params</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">==</span> <span class="ruby-value">2</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">cast_full</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">params</span>)
  <span class="ruby-keyword">end</span>

<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-cast_full" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            cast_full(stype) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            cast_full(stype, dtype, sparse_basis) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Copy constructor for changing dtypes and stypes.</p>
          
          

          
          <div class="method-source-code" id="cast_full-source">
            <pre>VALUE nm_cast(VALUE self, VALUE new_stype_symbol, VALUE new_dtype_symbol, VALUE init) {
  NM_CONSERVATIVE(nm_register_value(self));
  NM_CONSERVATIVE(nm_register_value(init));

  nm::dtype_t new_dtype = nm_dtype_from_rbsymbol(new_dtype_symbol);
  nm::stype_t new_stype = nm_stype_from_rbsymbol(new_stype_symbol);

  CheckNMatrixType(self);
  NMATRIX *rhs;

  UnwrapNMatrix( self, rhs );

  void* init_ptr = NM_ALLOCA_N(char, DTYPE_SIZES[new_dtype]);
  rubyval_to_cval(init, new_dtype, init_ptr);

  NMATRIX* m = nm_cast_with_ctype_args(rhs, new_stype, new_dtype, init_ptr);
  nm_register_nmatrix(m);

  VALUE to_return = Data_Wrap_Struct(CLASS_OF(self), nm_mark, nm_delete, m);

  nm_unregister_nmatrix(m);
  NM_CONSERVATIVE(nm_unregister_value(self));
  NM_CONSERVATIVE(nm_unregister_value(init));
  return to_return;

}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-clone_structure" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            clone_structure &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>This function is like clone, but it only copies the structure and the
default value. None of the other values are copied. It takes an optional
capacity argument. This is mostly only useful for dense, where you may not
want to initialize; for other types, you should probably use
<code>zeros_like</code>.</p>
          
          

          
          <div class="method-source-code" id="clone_structure-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 831</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">clone_structure</span>(<span class="ruby-identifier">capacity</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">opts</span> = {<span class="ruby-identifier">stype</span><span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span>, <span class="ruby-identifier">default</span><span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">default_value</span>, <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>}
  <span class="ruby-identifier">opts</span> = {<span class="ruby-identifier">capacity</span><span class="ruby-operator">:</span> <span class="ruby-identifier">capacity</span>}.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>) <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">yale?</span>
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">opts</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-col" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">col</span><span
            class="method-args">(column_number, get_by = :copy)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-column">column</a>
        </div>
        
      </div>

    
      <div id="method-i-cols" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            cols &rarr; Integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>This shortcut use <a href="NMatrix.html#method-i-shape">shape</a> to return
the number of columns (the second dimension) of the matrix.</p>
          
          

          
          <div class="method-source-code" id="cols-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 194</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">cols</span>
  <span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>]
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-column" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            column(column_number) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            column(column_number, get_by) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the column specified. Uses slicing by copy as default.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>column_number</code> -&gt; Integer.</p>
</li><li>
<p><code>get_by</code> -&gt; Type of slicing to use, <code>:copy</code> or
<code>:reference</code>.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>A <a href="NMatrix.html">NMatrix</a> representing the requested column as a
column vector.</p>
</li></ul>
</li></ul>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-identifier">m</span> = <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2</span>, [<span class="ruby-value">1</span>, <span class="ruby-value">4</span>, <span class="ruby-value">9</span>, <span class="ruby-value">14</span>], :<span class="ruby-identifier">int32</span>) <span class="ruby-comment"># =&gt;  1   4</span>
                                                <span class="ruby-value">9</span>  <span class="ruby-value">14</span>

<span class="ruby-identifier">m</span>.<span class="ruby-identifier">column</span>(<span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt;   4</span>
                  <span class="ruby-value">14</span>
</pre>
          
          

          
          <div class="method-source-code" id="column-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 385</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">column</span>(<span class="ruby-identifier">column_number</span>, <span class="ruby-identifier">get_by</span> = <span class="ruby-value">:copy</span>)
  <span class="ruby-identifier">rank</span>(<span class="ruby-value">1</span>, <span class="ruby-identifier">column_number</span>, <span class="ruby-identifier">get_by</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-col">col</a>
        </div>
        

        
      </div>

    
      <div id="method-i-complex_conjugate" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            complex_conjugate &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Transform the matrix (non-in-place) to its complex conjugate. Only works on
complex matrices.</p>
          
          

          
          <div class="method-source-code" id="complex_conjugate-source">
            <pre>static VALUE nm_complex_conjugate(VALUE self) {
  VALUE copy;
  return nm_complex_conjugate_bang(nm_init_copy(copy,self));
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-complex_conjugate-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            complex_conjugate_bang &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Transform the matrix (in-place) to its complex conjugate. Only works on
complex matrices.</p>

<p>Bang should imply that no copy is being made, even temporarily.</p>
          
          

          
          <div class="method-source-code" id="complex_conjugate-21-source">
            <pre>static VALUE nm_complex_conjugate_bang(VALUE self) {

  NMATRIX* m;
  void* elem;
  size_t size, p;

  UnwrapNMatrix(self, m);

  if (m-&gt;stype == nm::DENSE_STORE) {

    size = nm_storage_count_max_elements(NM_STORAGE(self));
    elem = NM_STORAGE_DENSE(self)-&gt;elements;

  } else if (m-&gt;stype == nm::YALE_STORE) {

    size = nm_yale_storage_get_size(NM_STORAGE_YALE(self));
    elem = NM_STORAGE_YALE(self)-&gt;a;

  } else {
    rb_raise(rb_eNotImpError, &quot;please cast to yale or dense (complex) first&quot;);
  }

  // Walk through and negate the imaginary component
  if (NM_DTYPE(self) == nm::COMPLEX64) {

    for (p = 0; p &lt; size; ++p) {
      reinterpret_cast&lt;nm::Complex64*&gt;(elem)[p].i = -reinterpret_cast&lt;nm::Complex64*&gt;(elem)[p].i;
    }

  } else if (NM_DTYPE(self) == nm::COMPLEX128) {

    for (p = 0; p &lt; size; ++p) {
      reinterpret_cast&lt;nm::Complex128*&gt;(elem)[p].i = -reinterpret_cast&lt;nm::Complex128*&gt;(elem)[p].i;
    }

  }
  return self;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-concat" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            concat(*m2) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            concat(*m2, rank) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            hconcat(*m2) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            vconcat(*m2) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            dconcat(*m3) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Joins two matrices together into a new larger matrix. Attempts to determine
which direction to concatenate on by looking for the first common element
of the matrix <code>shape</code> in reverse. In other words, concatenating
two columns together without supplying <code>rank</code> will glue them
into an n x 2 matrix.</p>

<p>You can also use hconcat, vconcat, and dconcat for the first three ranks.
concat performs an hconcat when no rank argument is provided.</p>

<p>The two matrices must have the same <code>dim</code>.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>matrices</code> -&gt; one or more matrices</p>
</li><li>
<p><code>rank</code> -&gt; Fixnum (for rank); alternatively, may use :row,
:column, or</p>
</li></ul>

<p>:layer for 0, 1, 2, respectively</p>
</li></ul>
          
          

          
          <div class="method-source-code" id="concat-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 532</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">concat</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">matrices</span>)
  <span class="ruby-identifier">rank</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">rank</span> = <span class="ruby-identifier">matrices</span>.<span class="ruby-identifier">pop</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">matrices</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">NMatrix</span>)

  <span class="ruby-comment"># Find the first matching dimension and concatenate along that (unless rank is specified)</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">rank</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-identifier">rank</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span><span class="ruby-operator">-</span><span class="ruby-value">1</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>.<span class="ruby-identifier">reverse_each</span>.<span class="ruby-identifier">with_index</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">s</span>,<span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">matrices</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">m</span><span class="ruby-operator">|</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-identifier">i</span>] <span class="ruby-operator">!=</span> <span class="ruby-identifier">s</span>
          <span class="ruby-identifier">rank</span> <span class="ruby-operator">-=</span> <span class="ruby-value">1</span>
          <span class="ruby-keyword">break</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">rank</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Symbol</span>) <span class="ruby-comment"># Convert to numeric</span>
    <span class="ruby-identifier">rank</span> = {<span class="ruby-value">:row</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>, <span class="ruby-value">:column</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>, <span class="ruby-value">:col</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>, <span class="ruby-value">:lay</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">2</span>, <span class="ruby-value">:layer</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">2</span>}[<span class="ruby-identifier">rank</span>]
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Need to figure out the new shape.</span>
  <span class="ruby-identifier">new_shape</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>.<span class="ruby-identifier">dup</span>
  <span class="ruby-identifier">new_shape</span>[<span class="ruby-identifier">rank</span>] = <span class="ruby-identifier">matrices</span>.<span class="ruby-identifier">inject</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-identifier">rank</span>]) { <span class="ruby-operator">|</span><span class="ruby-identifier">total</span>,<span class="ruby-identifier">m</span><span class="ruby-operator">|</span> <span class="ruby-identifier">total</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">m</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-identifier">rank</span>] }

  <span class="ruby-comment"># Now figure out the options for constructing the concatenated matrix.</span>
  <span class="ruby-identifier">opts</span> = {<span class="ruby-identifier">stype</span><span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span>, <span class="ruby-identifier">default</span><span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">default_value</span>, <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>}
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">yale?</span>
    <span class="ruby-comment"># We can generally predict the new capacity for Yale. Subtract out the number of rows</span>
    <span class="ruby-comment"># for each matrix being concatenated, and then add in the number of rows for the new</span>
    <span class="ruby-comment"># shape. That takes care of the diagonal. The rest of the capacity is represented by</span>
    <span class="ruby-comment"># the non-diagonal non-default values.</span>
    <span class="ruby-identifier">new_cap</span> = <span class="ruby-identifier">matrices</span>.<span class="ruby-identifier">inject</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">capacity</span> <span class="ruby-operator">-</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">total</span>,<span class="ruby-identifier">m</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">total</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">m</span>.<span class="ruby-identifier">capacity</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">m</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]
    <span class="ruby-keyword">end</span> <span class="ruby-operator">-</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">+</span> <span class="ruby-identifier">new_shape</span>[<span class="ruby-value">0</span>]
    <span class="ruby-identifier">opts</span> = {<span class="ruby-identifier">capacity</span><span class="ruby-operator">:</span> <span class="ruby-identifier">new_cap</span>}.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Do the actual construction.</span>
  <span class="ruby-identifier">n</span> = <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">new_shape</span>, <span class="ruby-identifier">opts</span>)

  <span class="ruby-comment"># Figure out where to start and stop the concatenation. We&#39;ll use NMatrices instead of</span>
  <span class="ruby-comment"># Arrays because then we can do elementwise addition.</span>
  <span class="ruby-identifier">ranges</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>.<span class="ruby-identifier">map</span>.<span class="ruby-identifier">with_index</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">s</span>,<span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-identifier">i</span>] }

  <span class="ruby-identifier">matrices</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-keyword">self</span>)
  <span class="ruby-identifier">matrices</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">m</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">n</span>[<span class="ruby-operator">*</span><span class="ruby-identifier">ranges</span>] = <span class="ruby-identifier">m</span>

    <span class="ruby-comment"># move over by the requisite amount</span>
    <span class="ruby-identifier">ranges</span>[<span class="ruby-identifier">rank</span>]  = (<span class="ruby-identifier">ranges</span>[<span class="ruby-identifier">rank</span>].<span class="ruby-identifier">first</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">m</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-identifier">rank</span>])<span class="ruby-operator">...</span>(<span class="ruby-identifier">ranges</span>[<span class="ruby-identifier">rank</span>].<span class="ruby-identifier">last</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">m</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-identifier">rank</span>])
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">n</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-conjugate_transpose" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            conjugate_transpose &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calculate the conjugate transpose of a matrix. If your dtype is already
complex, this should only require one copy (for the transpose).</p>
<ul><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>The conjugate transpose of the matrix as a copy.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="conjugate_transpose-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 338</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">conjugate_transpose</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">transpose</span>.<span class="ruby-identifier">complex_conjugate!</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-data_pointer" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">data_pointer</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns the pointer to the matrix storage&#39;s data. This is useful
primarily when you are using FFI with <a href="NMatrix.html">NMatrix</a> –
say, for example, you want to pass a float* to some function, and your <a
href="NMatrix.html">NMatrix</a> is a :float32 :dense matrix. Then you can
call this function and get that pointer directly instead of copying the
data.</p>
          
          

          
          <div class="method-source-code" id="data_pointer-source">
            <pre>static VALUE nm_data_pointer(VALUE self) {
  //if (NM_DTYPE(self) == nm::LIST_STORE)
  //  rb_warn(&quot;pointer requested for list storage, which may be meaningless&quot;);

  // This is actually pretty easy, since all of the storage types have their elements positioned in the same place
  // relative to one another. So yes, believe it or not, this should work just as well for Yale or list storage as for
  // dense.
  return INT2FIX(NM_STORAGE_DENSE(self)-&gt;elements);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-dconcat" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">dconcat</span><span
            class="method-args">(*matrices)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Depth concatenation with <code>matrices</code>.</p>
          
          

          
          <div class="method-source-code" id="dconcat-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 597</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">dconcat</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">matrices</span>)
  <span class="ruby-identifier">concat</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">matrices</span>, <span class="ruby-value">:layer</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-default_value" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            default_value &rarr; ...
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the default value for the matrix. For dense, this is undefined and will
return Qnil. For list, it is user-defined. For yale, it&#39;s going to be
some variation on zero, but may be Qfalse or Qnil.</p>
          
          

          
          <div class="method-source-code" id="default_value-source">
            <pre>static VALUE nm_default_value(VALUE self) {
  switch(NM_STYPE(self)) {
  case nm::YALE_STORE:
    return nm_yale_default_value(self);
  case nm::LIST_STORE:
    return nm_list_default_value(self);
  case nm::DENSE_STORE:
  default:
    return Qnil;
  }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-dense-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            dense? &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Determine if <code>m</code> is a dense matrix.</p>
          
          

          
          <div class="method-source-code" id="dense-3F-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">dense?</span>; <span class="ruby-keyword">return</span> <span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dense</span>; <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-det" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            det &rarr; determinant
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calculate the determinant by way of LU decomposition. This is accomplished
using clapack_getrf, and then by summing the diagonal elements. There is a
risk of underflow/overflow.</p>

<p>There are probably also more efficient ways to calculate the determinant.
This method requires making a copy of the matrix, since clapack_getrf
modifies its input.</p>

<p>For smaller matrices, you may be able to use <code>#det_exact</code>.</p>

<p>This function is guaranteed to return the same type of data in the matrix
upon which it is called. In other words, if you call it on a rational
matrix, you&#39;ll get a rational number back.</p>

<p>Integer matrices are converted to rational matrices for the purposes of
performing the calculation, as xGETRF can&#39;t work on integer matrices.</p>
<ul><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>The determinant of the matrix. It&#39;s the same type as the matrix&#39;s
dtype.</p>
</li></ul>
</li><li>
<p><strong>Raises</strong> :</p>
<ul><li>
<p><code>NotImplementedError</code> -&gt; Must be used in 2D matrices.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="det-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 287</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">det</span>
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">NotImplementedError</span>, <span class="ruby-string">&quot;determinant can be calculated only for 2D matrices&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span> <span class="ruby-operator">==</span> <span class="ruby-value">2</span>

  <span class="ruby-comment"># Cast to a dtype for which getrf is implemented</span>
  <span class="ruby-identifier">new_dtype</span> = [<span class="ruby-value">:byte</span>,<span class="ruby-value">:int8</span>,<span class="ruby-value">:int16</span>,<span class="ruby-value">:int32</span>,<span class="ruby-value">:int64</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>) <span class="ruby-operator">?</span> <span class="ruby-value">:rational128</span> <span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>
  <span class="ruby-identifier">copy</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-value">:dense</span>, <span class="ruby-identifier">new_dtype</span>)

  <span class="ruby-comment"># Need to know the number of permutations. We&#39;ll add up the diagonals of</span>
  <span class="ruby-comment"># the factorized matrix.</span>
  <span class="ruby-identifier">pivot</span> = <span class="ruby-identifier">copy</span>.<span class="ruby-identifier">getrf!</span>

  <span class="ruby-identifier">prod</span> = <span class="ruby-identifier">pivot</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">%</span> <span class="ruby-value">2</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span> <span class="ruby-operator">?</span> <span class="ruby-value">-1</span> <span class="ruby-operator">:</span> <span class="ruby-value">1</span> <span class="ruby-comment"># odd permutations =&gt; negative</span>
  [<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>],<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>]].<span class="ruby-identifier">min</span>.<span class="ruby-identifier">times</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">prod</span> <span class="ruby-operator">*=</span> <span class="ruby-identifier">copy</span>[<span class="ruby-identifier">i</span>,<span class="ruby-identifier">i</span>]
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Convert back to an integer if necessary</span>
  <span class="ruby-identifier">new_dtype</span> <span class="ruby-operator">!=</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">prod</span>.<span class="ruby-identifier">to_i</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">prod</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-det_exact" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">det_exact</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Calculate the exact determinant of a dense matrix.</p>

<p>Returns nil for dense matrices which are not square or number of dimensions
other than 2.</p>

<p>Note: Currently only implemented for 2x2 and 3x3 matrices.</p>
          
          

          
          <div class="method-source-code" id="det_exact-source">
            <pre>static VALUE nm_det_exact(VALUE self) {

  if (NM_STYPE(self) != nm::DENSE_STORE) {
    rb_raise(rb_eNotImpError, &quot;can only calculate exact determinant for dense matrices&quot;);
    return Qnil;
  }
  if (NM_DIM(self) != 2 || NM_SHAPE0(self) != NM_SHAPE1(self)) {
    rb_raise(nm_eShapeError, &quot;matrices must be square to have a determinant defined&quot;);
    return Qnil;
  }

  NM_CONSERVATIVE(nm_register_value(self));

  // Calculate the determinant and then assign it to the return value
  void* result = NM_ALLOCA_N(char, DTYPE_SIZES[NM_DTYPE(self)]);
  nm::dtype_t dtype = NM_DTYPE(self);
  nm_math_det_exact(NM_SHAPE0(self), NM_STORAGE_DENSE(self)-&gt;elements, NM_SHAPE0(self), NM_DTYPE(self), result);

  if (dtype == nm::RUBYOBJ) {
    nm_register_values(reinterpret_cast&lt;VALUE*&gt;(result), 1);
  }
  VALUE to_return = rubyobj_from_cval(result, NM_DTYPE(self)).rval;
  if (dtype == nm::RUBYOBJ) {
    nm_unregister_values(reinterpret_cast&lt;VALUE*&gt;(result), 1);
  }
  NM_CONSERVATIVE(nm_unregister_value(self));

  return to_return;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-diagonal" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            diagonals(array) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            diagonals(array, dtype: dtype, stype: stype) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a matrix filled with specified diagonals.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>entries</code> -&gt; <a href="Array.html">Array</a> containing input
values for diagonal matrix</p>
</li><li>
<p><code>options</code> -&gt; (optional) Hash with options for
NMatrix#initialize</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p><a href="NMatrix.html">NMatrix</a> filled with specified diagonal values.</p>
</li></ul>
</li></ul>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">diagonal</span>([<span class="ruby-value">1.0</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>,<span class="ruby-value">4</span>]) <span class="ruby-comment"># =&gt; 1.0 0.0 0.0 0.0</span>
                                   <span class="ruby-value">0.0</span> <span class="ruby-value">2.0</span> <span class="ruby-value">0.0</span> <span class="ruby-value">0.0</span>
                                   <span class="ruby-value">0.0</span> <span class="ruby-value">0.0</span> <span class="ruby-value">3.0</span> <span class="ruby-value">0.0</span>
                                   <span class="ruby-value">0.0</span> <span class="ruby-value">0.0</span> <span class="ruby-value">0.0</span> <span class="ruby-value">4.0</span>

<span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">diagonal</span>([<span class="ruby-value">1</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>,<span class="ruby-value">4</span>], <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">int32</span>) <span class="ruby-comment"># =&gt; 1 0 0 0</span>
                                                <span class="ruby-value">0</span> <span class="ruby-value">2</span> <span class="ruby-value">0</span> <span class="ruby-value">0</span>
                                                <span class="ruby-value">0</span> <span class="ruby-value">0</span> <span class="ruby-value">3</span> <span class="ruby-value">0</span>
                                                <span class="ruby-value">0</span> <span class="ruby-value">0</span> <span class="ruby-value">0</span> <span class="ruby-value">4</span>
</pre>
          
          

          
          <div class="method-source-code" id="diagonal-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 266</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">diagonal</span>(<span class="ruby-identifier">entries</span>, <span class="ruby-identifier">opts</span>={})
  <span class="ruby-identifier">m</span> = <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">zeros</span>(<span class="ruby-identifier">entries</span>.<span class="ruby-identifier">size</span>,
                    {<span class="ruby-value">:dtype</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">guess_dtype</span>(<span class="ruby-identifier">entries</span>[<span class="ruby-value">0</span>]), <span class="ruby-value">:capacity</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">entries</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>}.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>)
                   )
  <span class="ruby-identifier">entries</span>.<span class="ruby-identifier">each_with_index</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">n</span>, <span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">m</span>[<span class="ruby-identifier">i</span>,<span class="ruby-identifier">i</span>] = <span class="ruby-identifier">n</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">m</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-dim" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">dim</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-dimensions">dimensions</a>
        </div>
        
      </div>

    
      <div id="method-i-dimensions" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            dim &rarr; Integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the number of dimensions of a matrix.</p>

<p>In other words, if you set your matrix to be 3x4, the dim is 2. If the
matrix was initialized as 3x4x3, the dim is 3.</p>

<p>Use <a href="NMatrix.html#method-i-effective_dim">effective_dim</a> to get
the dimension of an <a href="NMatrix.html">NMatrix</a> which acts as a
vector (e.g., a column or row).</p>
          
          

          
          <div class="method-source-code" id="dimensions-source">
            <pre>static VALUE nm_dim(VALUE self) {
  return INT2FIX(NM_STORAGE(self)-&gt;dim);
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-dim">dim</a>
        </div>
        

        
      </div>

    
      <div id="method-i-dot" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">dot</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Matrix multiply (dot product): against another matrix or a vector.</p>

<p>For elementwise, use * instead.</p>

<p>The two matrices must be of the same stype (for now). If dtype differs, an
upcast will occur.</p>
          
          

          
          <div class="method-source-code" id="dot-source">
            <pre>static VALUE nm_multiply(VALUE left_v, VALUE right_v) {
  NM_CONSERVATIVE(nm_register_value(left_v));
  NM_CONSERVATIVE(nm_register_value(right_v));

  NMATRIX *left, *right;

  UnwrapNMatrix( left_v, left );

  if (NM_RUBYVAL_IS_NUMERIC(right_v)) {
    NM_CONSERVATIVE(nm_unregister_value(left_v));
    NM_CONSERVATIVE(nm_unregister_value(right_v));
    return matrix_multiply_scalar(left, right_v);
  }

  else if (TYPE(right_v) == T_ARRAY) {
    NM_CONSERVATIVE(nm_unregister_value(left_v));
    NM_CONSERVATIVE(nm_unregister_value(right_v));
    rb_raise(rb_eNotImpError, &quot;please convert array to nx1 or 1xn NMatrix first&quot;);
  }

  else { // both are matrices (probably)
    CheckNMatrixType(right_v);
    UnwrapNMatrix( right_v, right );

    // work like vector dot product for 1dim
    if (left-&gt;storage-&gt;dim == 1 &amp;&amp; right-&gt;storage-&gt;dim == 1) {
      if (left-&gt;storage-&gt;shape[0] != right-&gt;storage-&gt;shape[0]) {
        NM_CONSERVATIVE(nm_unregister_value(left_v));
        NM_CONSERVATIVE(nm_unregister_value(right_v));
        rb_raise(rb_eArgError, &quot;The left- and right-hand sides of the operation must have the same dimensionality.&quot;);
      } else {
        VALUE result = elementwise_op(nm::EW_MUL, left_v, right_v);
        VALUE to_return = rb_funcall(result, rb_intern(&quot;sum&quot;),0);
        NM_CONSERVATIVE(nm_unregister_value(left_v));
        NM_CONSERVATIVE(nm_unregister_value(right_v));
        return to_return;
      }
    }

    if (left-&gt;storage-&gt;shape[1] != right-&gt;storage-&gt;shape[0]) {
      NM_CONSERVATIVE(nm_unregister_value(left_v));
      NM_CONSERVATIVE(nm_unregister_value(right_v));
      rb_raise(rb_eArgError, &quot;incompatible dimensions&quot;);
    }

    if (left-&gt;stype != right-&gt;stype) {
      NM_CONSERVATIVE(nm_unregister_value(left_v));
      NM_CONSERVATIVE(nm_unregister_value(right_v));
      rb_raise(rb_eNotImpError, &quot;matrices must have same stype&quot;);
    }

    NM_CONSERVATIVE(nm_unregister_value(left_v));
    NM_CONSERVATIVE(nm_unregister_value(right_v));
    return matrix_multiply(left, right);

  }

  NM_CONSERVATIVE(nm_unregister_value(left_v));
  NM_CONSERVATIVE(nm_unregister_value(right_v));

  return Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-dtype" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            dtype &rarr; Symbol
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the data type (dtype) of a matrix, e.g., :byte, :int8, :int16, :int32,
:int64, :float32, :float64, :complex64, :complex128, :rational32,
:rational64, :rational128, or :object (the last is a Ruby object).</p>
          
          

          
          <div class="method-source-code" id="dtype-source">
            <pre>static VALUE nm_dtype(VALUE self) {
  ID dtype = rb_intern(DTYPE_NAMES[NM_DTYPE(self)]);
  return ID2SYM(dtype);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-each" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each &rarr; Enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Enumerate through the matrix. @see Enumerable#each</p>

<p>For dense, this actually calls a specialized each iterator (in C). For yale
and list, it relies upon <a
href="NMatrix.html#method-i-each_with_indices">each_with_indices</a> (which
is about as fast as reasonably possible for C code).</p>
          
          

          
          <div class="method-source-code" id="each-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/enumerate.rb, line 40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">each</span> <span class="ruby-operator">&amp;</span><span class="ruby-identifier">bl</span>
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dense</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">__dense_each__</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">bl</span>)
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">block_given?</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">each_with_indices</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">bl</span>)
  <span class="ruby-keyword">else</span> <span class="ruby-comment"># Handle case where no block is given</span>
    <span class="ruby-constant">Enumerator</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">yielder</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">self</span>.<span class="ruby-identifier">each_with_indices</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">params</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">yielder</span>.<span class="ruby-identifier">yield</span> <span class="ruby-identifier">params</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-each_along_dim" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">each_along_dim</span><span
            class="method-args">(dimen=0, get_by=:reference)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-each_rank">each_rank</a>
        </div>
        
      </div>

    
      <div id="method-i-each_column" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each_column { |column| block } &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Iterate through each column, referencing it as an <a
href="NMatrix.html">NMatrix</a> slice.</p>
          
          

          
          <div class="method-source-code" id="each_column-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/enumerate.rb, line 144</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">each_column</span>(<span class="ruby-identifier">get_by</span>=<span class="ruby-value">:reference</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">enum_for</span>(<span class="ruby-value">:each_column</span>, <span class="ruby-identifier">get_by</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block_given?</span>
  (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>]).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">j</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">yield</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">column</span>(<span class="ruby-identifier">j</span>, <span class="ruby-identifier">get_by</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-each_layer" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each_layer -&gt; { |column| block } &rarr; ...
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Iterate through each layer, referencing it as an <a
href="NMatrix.html">NMatrix</a> slice.</p>

<p>Note: If you have a 3-dimensional matrix, the first dimension contains
rows, the second contains columns, and the third contains layers.</p>
          
          

          
          <div class="method-source-code" id="each_layer-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/enumerate.rb, line 160</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">each_layer</span>(<span class="ruby-identifier">get_by</span>=<span class="ruby-value">:reference</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">enum_for</span>(<span class="ruby-value">:each_layer</span>, <span class="ruby-identifier">get_by</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block_given?</span>
  (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">2</span>]).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">k</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">yield</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">layer</span>(<span class="ruby-identifier">k</span>, <span class="ruby-identifier">get_by</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-each_ordered_stored_with_indices" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each_ordered_stored_with_indices &rarr; Enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Very similar to <a
href="NMatrix.html#method-i-each_stored_with_indices">each_stored_with_indices</a>.
The key difference is that it enforces matrix ordering rather than storage
ordering, which only matters if your matrix is Yale.</p>
          
          

          
          <div class="method-source-code" id="each_ordered_stored_with_indices-source">
            <pre>static VALUE nm_each_ordered_stored_with_indices(VALUE nmatrix) {
  NM_CONSERVATIVE(nm_register_value(nmatrix));
  VALUE to_return = Qnil;

  switch(NM_STYPE(nmatrix)) {
  case nm::YALE_STORE:
    to_return = nm_yale_each_ordered_stored_with_indices(nmatrix);
    break;
  case nm::DENSE_STORE:
    to_return = nm_dense_each_with_indices(nmatrix);
    break;
  case nm::LIST_STORE:
    to_return = nm_list_each_with_indices(nmatrix, true);
    break;
  default:
    NM_CONSERVATIVE(nm_unregister_value(nmatrix));
    rb_raise(nm_eDataTypeError, &quot;Not a proper storage type&quot;);
  }

  NM_CONSERVATIVE(nm_unregister_value(nmatrix));
  return to_return;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-each_rank" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each_rank() &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            each_rank() { |rank| block } &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            each_rank(dimen) &rarr; Enumerator
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            each_rank(dimen) { |rank| block } &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Generic for @each_row, @each_col</p>

<p>Iterate through each rank by reference.</p>

<p>@param [Fixnum] dimen the rank being iterated over.</p>
          
          

          
          <div class="method-source-code" id="each_rank-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/enumerate.rb, line 117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">each_rank</span>(<span class="ruby-identifier">dimen</span>=<span class="ruby-value">0</span>, <span class="ruby-identifier">get_by</span>=<span class="ruby-value">:reference</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">enum_for</span>(<span class="ruby-value">:each_rank</span>, <span class="ruby-identifier">dimen</span>, <span class="ruby-identifier">get_by</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block_given?</span>
  (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-identifier">dimen</span>]).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">idx</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">yield</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">rank</span>(<span class="ruby-identifier">dimen</span>, <span class="ruby-identifier">idx</span>, <span class="ruby-identifier">get_by</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-each_along_dim">each_along_dim</a>
        </div>
        

        
      </div>

    
      <div id="method-i-each_row" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each_row { |row| block } &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Iterate through each row, referencing it as an <a
href="NMatrix.html">NMatrix</a> slice.</p>
          
          

          
          <div class="method-source-code" id="each_row-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/enumerate.rb, line 131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">each_row</span>(<span class="ruby-identifier">get_by</span>=<span class="ruby-value">:reference</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">enum_for</span>(<span class="ruby-value">:each_row</span>, <span class="ruby-identifier">get_by</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block_given?</span>
  (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">yield</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">row</span>(<span class="ruby-identifier">i</span>, <span class="ruby-identifier">get_by</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-each_stored_with_index" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each_stored_with_index &rarr; Enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Allow iteration across a vector NMatrix&#39;s stored values. See also
@each_stored_with_indices</p>
          
          

          
          <div class="method-source-code" id="each_stored_with_index-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/enumerate.rb, line 175</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">each_stored_with_index</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">NotImplementedError</span>, <span class="ruby-string">&quot;only works for dim 2 vectors&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-value">2</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">enum_for</span>(<span class="ruby-value">:each_stored_with_index</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block_given?</span>

  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">each_stored_with_indices</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">v</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">j</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
      <span class="ruby-keyword">yield</span>(<span class="ruby-identifier">v</span>,<span class="ruby-identifier">j</span>)
    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>] <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
      <span class="ruby-keyword">yield</span>(<span class="ruby-identifier">v</span>,<span class="ruby-identifier">i</span>)
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">method_missing</span>(<span class="ruby-value">:each_stored_with_index</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-each_stored_with_indices" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each_stored_with_indices &rarr; Enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Iterate over the stored entries of any matrix. For dense and yale, this
iterates over non-zero entries; for list, this iterates over non-default
entries. Yields dim+1 values for each entry: i, j, …, and the entry itself.</p>
          
          

          
          <div class="method-source-code" id="each_stored_with_indices-source">
            <pre>static VALUE nm_each_stored_with_indices(VALUE nmatrix) {
  NM_CONSERVATIVE(nm_register_value(nmatrix));
  VALUE to_return = Qnil;

  switch(NM_STYPE(nmatrix)) {
  case nm::YALE_STORE:
    to_return = nm_yale_each_stored_with_indices(nmatrix);
    break;
  case nm::DENSE_STORE:
    to_return = nm_dense_each_with_indices(nmatrix);
    break;
  case nm::LIST_STORE:
    to_return = nm_list_each_with_indices(nmatrix, true);
    break;
  default:
    NM_CONSERVATIVE(nm_unregister_value(nmatrix));
    rb_raise(nm_eDataTypeError, &quot;Not a proper storage type&quot;);
  }

  NM_CONSERVATIVE(nm_unregister_value(nmatrix));
  return to_return;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-each_with_indices" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each_with_indices &rarr; Enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Iterate over all entries of any matrix in standard storage order (as with
<a href="NMatrix.html#method-i-each">each</a>), and include the indices.</p>
          
          

          
          <div class="method-source-code" id="each_with_indices-source">
            <pre>static VALUE nm_each_with_indices(VALUE nmatrix) {
  NM_CONSERVATIVE(nm_register_value(nmatrix));
  VALUE to_return = Qnil;

  switch(NM_STYPE(nmatrix)) {
  case nm::YALE_STORE:
    to_return = nm_yale_each_with_indices(nmatrix);
    break;
  case nm::DENSE_STORE:
    to_return = nm_dense_each_with_indices(nmatrix);
    break;
  case nm::LIST_STORE:
    to_return = nm_list_each_with_indices(nmatrix, false);
    break;
  default:
    NM_CONSERVATIVE(nm_unregister_value(nmatrix));
    rb_raise(nm_eDataTypeError, &quot;Not a proper storage type&quot;);
  }

  NM_CONSERVATIVE(nm_unregister_value(nmatrix));
  return to_return;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-effective_dim" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">effective_dim</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-effective_dimensions">effective_dimensions</a>
        </div>
        
      </div>

    
      <div id="method-i-effective_dimensions" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            effective_dim &rarr; Fixnum
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the number of dimensions that don&#39;t have length 1. Guaranteed
to be less than or equal to <a href="NMatrix.html#method-i-dim">dim</a>.</p>
          
          

          
          <div class="method-source-code" id="effective_dimensions-source">
            <pre>static VALUE nm_effective_dim(VALUE self) {
  return INT2FIX(effective_dim(NM_STORAGE(self)));
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-effective_dim">effective_dim</a>
        </div>
        

        
      </div>

    
      <div id="method-i-eye" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            eye(shape) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            eye(shape, dtype: dtype) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            eye(shape, stype: stype, dtype: dtype) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates an identity matrix (square matrix rank 2).</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>size</code> -&gt; <a href="Array.html">Array</a> (or integer for
square matrix) specifying the dimensions.</p>
</li><li>
<p><code>dtype</code> -&gt; (optional) Default is <code>:float64</code></p>
</li><li>
<p><code>stype</code> -&gt; (optional) Default is <code>:dense</code>.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>An identity matrix.</p>
</li></ul>
</li></ul>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">eye</span>(<span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt;   1.0   0.0   0.0</span>
                      <span class="ruby-value">0.0</span>   <span class="ruby-value">1.0</span>   <span class="ruby-value">0.0</span>
                      <span class="ruby-value">0.0</span>   <span class="ruby-value">0.0</span>   <span class="ruby-value">1.0</span>

<span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">eye</span>(<span class="ruby-value">3</span>, <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">int32</span>) <span class="ruby-comment"># =&gt;   1   0   0</span>
                                     <span class="ruby-value">0</span>   <span class="ruby-value">1</span>   <span class="ruby-value">0</span>
                                     <span class="ruby-value">0</span>   <span class="ruby-value">0</span>   <span class="ruby-value">1</span>

<span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">eye</span>(<span class="ruby-value">2</span>, <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">int32</span>, <span class="ruby-identifier">stype</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">yale</span>) <span class="ruby-comment"># =&gt;   1   0</span>
                                                   <span class="ruby-value">0</span>   <span class="ruby-value">1</span>
</pre>
          
          

          
          <div class="method-source-code" id="eye-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 230</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">eye</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">opts</span>={})
  <span class="ruby-comment"># Fill the diagonal with 1&#39;s.</span>
  <span class="ruby-identifier">m</span> = <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">zeros</span>(<span class="ruby-identifier">shape</span>, {<span class="ruby-value">:dtype</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">:float64</span>}.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>))
  (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-identifier">m</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">m</span>[<span class="ruby-identifier">i</span>, <span class="ruby-identifier">i</span>] = <span class="ruby-value">1</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">m</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-factorize_cholesky" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            factorize_cholesky &rarr; ...
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Cholesky factorization of a matrix.</p>
          
          

          
          <div class="method-source-code" id="factorize_cholesky-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 157</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">factorize_cholesky</span>
  [<span class="ruby-keyword">self</span>.<span class="ruby-identifier">clone</span>.<span class="ruby-identifier">potrf_upper!</span>.<span class="ruby-identifier">triu!</span>,
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">clone</span>.<span class="ruby-identifier">potrf_lower!</span>.<span class="ruby-identifier">tril!</span>]
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-factorize_lu" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            factorize_lu &rarr; ...
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>LU factorization of a matrix.</p>

<p>FIXME: For some reason, getrf seems to require that the matrix be
transposed first – and then you have to transpose the FIXME: result again.
Ideally, this would be an in-place factorize instead, and would be called
nm_factorize_lu_bang.</p>
          
          

          
          <div class="method-source-code" id="factorize_lu-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 171</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">factorize_lu</span>
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">NotImplementedError</span>, <span class="ruby-string">&quot;only implemented for dense storage&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dense</span>
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">NotImplementedError</span>, <span class="ruby-string">&quot;matrix is not 2-dimensional&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dimensions</span> <span class="ruby-operator">==</span> <span class="ruby-value">2</span>

  <span class="ruby-identifier">t</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">transpose</span>
  <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">LAPACK</span><span class="ruby-operator">::</span><span class="ruby-identifier">clapack_getrf</span>(<span class="ruby-value">:row</span>, <span class="ruby-identifier">t</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">t</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">t</span>, <span class="ruby-identifier">t</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>])
  <span class="ruby-identifier">t</span>.<span class="ruby-identifier">transpose</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-flat_map" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">flat_map</span><span
            class="method-args">(&bl)</span>
          
        </div>
        

        <div class="method-description">
          
          <p>call-seq:</p>

<pre class="ruby"><span class="ruby-identifier">flat_map</span> <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Enumerator</span>
<span class="ruby-identifier">flat_map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">elem</span><span class="ruby-operator">|</span> <span class="ruby-identifier">block</span> } <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Array</span>
</pre>

<p>Maps using Enumerator (returns an <a href="Array.html">Array</a> or an
Enumerator)</p>
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-map">map</a>
        </div>
        
      </div>

    
      <div id="method-i-gesdd" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            gesdd &rarr; [u, sigma, v_transpose]
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            gesdd &rarr; [u, sigma, v_conjugate_transpose] # complex
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Compute the singular value decomposition of a matrix using LAPACK&#39;s
GESDD function. This uses a divide-and-conquer strategy. See also <a
href="NMatrix.html#method-i-gesvd">gesvd</a>.</p>

<p>Optionally accepts a <code>workspace_size</code> parameter, which will be
honored only if it is larger than what LAPACK requires.</p>
          
          

          
          <div class="method-source-code" id="gesdd-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 237</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">gesdd</span>(<span class="ruby-identifier">workspace_size</span>=<span class="ruby-value">1</span>)
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">clone</span>.<span class="ruby-identifier">gesdd!</span>(<span class="ruby-identifier">workspace_size</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-gesdd-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            gesdd! &rarr; [u, sigma, v_transpose]
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            gesdd! &rarr; [u, sigma, v_conjugate_transpose] # complex
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Compute the singular value decomposition of a matrix using LAPACK&#39;s
GESDD function. This uses a divide-and-conquer strategy. This is
destructive, modifying the source <a href="NMatrix.html">NMatrix</a>.  See
also <a href="NMatrix.html#method-i-gesvd">gesvd</a>.</p>

<p>Optionally accepts a <code>workspace_size</code> parameter, which will be
honored only if it is larger than what LAPACK requires.</p>
          
          

          
          <div class="method-source-code" id="gesdd-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 222</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">gesdd!</span>(<span class="ruby-identifier">workspace_size</span>=<span class="ruby-value">1</span>)
  <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">LAPACK</span><span class="ruby-operator">::</span><span class="ruby-identifier">gesdd</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">workspace_size</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-gesvd" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            gesvd &rarr; [u, sigma, v_transpose]
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            gesvd &rarr; [u, sigma, v_conjugate_transpose] # complex
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Compute the singular value decomposition of a matrix using LAPACK&#39;s
GESVD function.</p>

<p>Optionally accepts a <code>workspace_size</code> parameter, which will be
honored only if it is larger than what LAPACK requires.</p>
          
          

          
          <div class="method-source-code" id="gesvd-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 205</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">gesvd</span>(<span class="ruby-identifier">workspace_size</span>=<span class="ruby-value">1</span>)
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">clone</span>.<span class="ruby-identifier">gesvd!</span>(<span class="ruby-identifier">workspace_size</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-gesvd-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            gesvd! &rarr; [u, sigma, v_transpose]
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            gesvd! &rarr; [u, sigma, v_conjugate_transpose] # complex
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Compute the singular value decomposition of a matrix using LAPACK&#39;s
GESVD function. This is destructive, modifying the source <a
href="NMatrix.html">NMatrix</a>.  See also <a
href="NMatrix.html#method-i-gesdd">gesdd</a>.</p>

<p>Optionally accepts a <code>workspace_size</code> parameter, which will be
honored only if it is larger than what LAPACK requires.</p>
          
          

          
          <div class="method-source-code" id="gesvd-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 191</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">gesvd!</span>(<span class="ruby-identifier">workspace_size</span>=<span class="ruby-value">1</span>)
  <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">LAPACK</span><span class="ruby-operator">::</span><span class="ruby-identifier">gesvd</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">workspace_size</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-getrf" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            getrf &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>In-place version of <a href="NMatrix.html#method-i-getrf-21">getrf!</a>.
Returns the new matrix, which contains L and U matrices.</p>
<ul><li>
<p><strong>Raises</strong> :</p>
<ul><li>
<p><code>StorageTypeError</code> -&gt; ATLAS functions only work on dense
matrices.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="getrf-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 116</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">getrf</span>
  <span class="ruby-identifier">a</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">clone</span>
  <span class="ruby-identifier">a</span>.<span class="ruby-identifier">getrf!</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">a</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-getrf-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            getrf! &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>LU factorization of a general M-by-N matrix <code>A</code> using partial
pivoting with row interchanges. Only works in dense matrices.</p>
<ul><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>The IPIV vector. The L and U matrices are stored in A.</p>
</li></ul>
</li><li>
<p><strong>Raises</strong> :</p>
<ul><li>
<p><code>StorageTypeError</code> -&gt; ATLAS functions only work on dense
matrices.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="getrf-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">getrf!</span>
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">StorageTypeError</span>, <span class="ruby-string">&quot;ATLAS functions only work on dense matrices&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dense?</span>
  <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">LAPACK</span><span class="ruby-operator">::</span><span class="ruby-identifier">clapack_getrf</span>(<span class="ruby-value">:row</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>], <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>], <span class="ruby-keyword">self</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>])
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-hconcat" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">hconcat</span><span
            class="method-args">(*matrices)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Horizontal concatenation with <code>matrices</code>.</p>
          
          

          
          <div class="method-source-code" id="hconcat-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 587</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">hconcat</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">matrices</span>)
  <span class="ruby-identifier">concat</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">matrices</span>, <span class="ruby-value">:column</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-hermitian-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            hermitian? &rarr; Boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Is this matrix hermitian?</p>

<p>Definition: <a
href="http://en.wikipedia.org/wiki/Hermitian_matrix">en.wikipedia.org/wiki/Hermitian_matrix</a></p>

<p>For non-complex matrices, this function should return the same result as
symmetric?.</p>
          
          

          
          <div class="method-source-code" id="hermitian-3F-source">
            <pre>static VALUE nm_hermitian(VALUE self) {
  return is_symmetric(self, true);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-initialize_copy" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">initialize_copy</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Copy constructor for no change of dtype or stype (used for <a
href="NMatrix.html#method-i-initialize_copy">initialize_copy</a> hook).</p>
          
          

          
          <div class="method-source-code" id="initialize_copy-source">
            <pre>static VALUE nm_init_copy(VALUE copy, VALUE original) {
  NM_CONSERVATIVE(nm_register_value(copy));
  NM_CONSERVATIVE(nm_register_value(original));

  NMATRIX *lhs, *rhs;

  CheckNMatrixType(original);

  if (copy == original) {
    NM_CONSERVATIVE(nm_unregister_value(copy));
    NM_CONSERVATIVE(nm_unregister_value(original));
    return copy;
  }

  UnwrapNMatrix( original, rhs );
  UnwrapNMatrix( copy,     lhs );

  lhs-&gt;stype = rhs-&gt;stype;

  // Copy the storage
  CAST_TABLE(ttable);
  lhs-&gt;storage = ttable[lhs-&gt;stype][rhs-&gt;stype](rhs-&gt;storage, rhs-&gt;storage-&gt;dtype, NULL);

  NM_CONSERVATIVE(nm_unregister_value(copy));
  NM_CONSERVATIVE(nm_unregister_value(original));

  return copy;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-inject_along_dim" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">inject_along_dim</span><span
            class="method-args">(dimen=0, initial=nil, dtype=nil)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-inject_rank">inject_rank</a>
        </div>
        
      </div>

    
      <div id="method-i-inject_rank" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            inject_rank() &rarr; Enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            inject_rank(dimen) &rarr; Enumerator
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            inject_rank(dimen, initial) &rarr; Enumerator
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            inject_rank(dimen, initial, dtype) &rarr; Enumerator
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            inject_rank() { |elem| block } &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            inject_rank(dimen) { |elem| block } &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            inject_rank(dimen, initial) { |elem| block } &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            inject_rank(dimen, initial, dtype) { |elem| block } &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Reduces an <a href="NMatrix.html">NMatrix</a> using a supplied block over a
specified dimension. The block should behave the same way as for
Enumerable#reduce.</p>

<p>@param [Integer] dimen the dimension being reduced @param [Numeric] initial
the initial value for the reduction</p>

<pre>(i.e. the usual parameter to Enumerable#reduce).  Supply nil or do not
supply this argument to have it follow the usual Enumerable#reduce
behavior of using the first element as the initial value.</pre>

<p>@param [Symbol] dtype if non-nil/false, forces the accumulated result to
have this dtype @return [NMatrix] an <a href="NMatrix.html">NMatrix</a>
with the same number of dimensions as the</p>

<pre>input, but with the input dimension now having size 1.  Each element
is the result of the reduction at that position along the specified
dimension.</pre>
          
          

          
          <div class="method-source-code" id="inject_rank-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/enumerate.rb, line 217</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">inject_rank</span>(<span class="ruby-identifier">dimen</span>=<span class="ruby-value">0</span>, <span class="ruby-identifier">initial</span>=<span class="ruby-keyword">nil</span>, <span class="ruby-identifier">dtype</span>=<span class="ruby-keyword">nil</span>)

  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">RangeError</span>, <span class="ruby-node">&quot;requested dimension (#{dimen}) does not exist (shape: #{shape})&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">dimen</span> <span class="ruby-operator">&gt;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span>

  <span class="ruby-keyword">return</span> <span class="ruby-identifier">enum_for</span>(<span class="ruby-value">:inject_rank</span>, <span class="ruby-identifier">dimen</span>, <span class="ruby-identifier">initial</span>, <span class="ruby-identifier">dtype</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block_given?</span>

  <span class="ruby-identifier">new_shape</span> = <span class="ruby-identifier">shape</span>
  <span class="ruby-identifier">new_shape</span>[<span class="ruby-identifier">dimen</span>] = <span class="ruby-value">1</span>

  <span class="ruby-identifier">first_as_acc</span> = <span class="ruby-keyword">false</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">initial</span> <span class="ruby-keyword">then</span>
    <span class="ruby-identifier">acc</span> = <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">new_shape</span>, <span class="ruby-identifier">initial</span>, <span class="ruby-value">:dtype</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">dtype</span> <span class="ruby-operator">||</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>, <span class="ruby-identifier">stype</span><span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">each_rank</span>(<span class="ruby-identifier">dimen</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">sub_mat</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">acc</span> = (<span class="ruby-identifier">sub_mat</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">NMatrix</span>) <span class="ruby-keyword">and</span> <span class="ruby-operator">!</span><span class="ruby-identifier">dtype</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">dtype</span> <span class="ruby-operator">!=</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">sub_mat</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span>, <span class="ruby-identifier">dtype</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">sub_mat</span>
      <span class="ruby-keyword">break</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">first_as_acc</span> = <span class="ruby-keyword">true</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">each_rank</span>(<span class="ruby-identifier">dimen</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">sub_mat</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">first_as_acc</span>
      <span class="ruby-identifier">first_as_acc</span> = <span class="ruby-keyword">false</span>
      <span class="ruby-keyword">next</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">acc</span> = <span class="ruby-keyword">yield</span>(<span class="ruby-identifier">acc</span>, <span class="ruby-identifier">sub_mat</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">acc</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-reduce_along_dim">reduce_along_dim</a>, <a href="NMatrix.html#method-i-inject_along_dim">inject_along_dim</a>
        </div>
        

        
      </div>

    
      <div id="method-i-integer_dtype-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            integer_dtype?() &rarr; Boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Checks if dtype is an integer type</p>
          
          

          
          <div class="method-source-code" id="integer_dtype-3F-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 243</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">integer_dtype?</span>
  [<span class="ruby-value">:byte</span>, <span class="ruby-value">:int8</span>, <span class="ruby-value">:int16</span>, <span class="ruby-value">:int32</span>, <span class="ruby-value">:int64</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-inverse" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">inverse</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-invert">invert</a>
        </div>
        
      </div>

    
      <div id="method-i-invert" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            invert &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Make a copy of the matrix, then invert it (requires LAPACK for matrices
larger than 3x3).</p>
<ul><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>A dense <a href="NMatrix.html">NMatrix</a>.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="invert-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">invert</span>
  <span class="ruby-keyword">if</span> <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">has_clapack?</span>
    <span class="ruby-keyword">begin</span>
      <span class="ruby-keyword">self</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-value">:dense</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>).<span class="ruby-identifier">invert!</span> <span class="ruby-comment"># call CLAPACK version</span>
    <span class="ruby-keyword">rescue</span> <span class="ruby-constant">NotImplementedError</span> <span class="ruby-comment"># probably a rational matrix</span>
      <span class="ruby-identifier">inverse</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">clone_structure</span>
      <span class="ruby-identifier">__inverse_exact__</span>(<span class="ruby-identifier">inverse</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">integer_dtype?</span> <span class="ruby-comment"># FIXME: This check is probably too slow.</span>
    <span class="ruby-identifier">rational_self</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-value">:rational128</span>)
    <span class="ruby-identifier">inverse</span>       = <span class="ruby-identifier">rational_self</span>.<span class="ruby-identifier">clone_structure</span>
    <span class="ruby-identifier">rational_self</span>.<span class="ruby-identifier">__inverse_exact__</span>(<span class="ruby-identifier">inverse</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">inverse</span>       = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">clone_structure</span>
    <span class="ruby-identifier">__inverse_exact__</span>(<span class="ruby-identifier">inverse</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-inverse">inverse</a>
        </div>
        

        
      </div>

    
      <div id="method-i-invert-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            invert! &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Use LAPACK to calculate the inverse of the matrix (in-place). Only works on
dense matrices.</p>

<p>Note: If you don&#39;t have LAPACK, e.g., on a Mac, this may not work yet.
Use invert instead (which still probably won&#39;t work if your matrix is
larger than 3x3).</p>
          
          

          
          <div class="method-source-code" id="invert-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">invert!</span>
  <span class="ruby-comment"># Get the pivot array; factor the matrix</span>
  <span class="ruby-identifier">pivot</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">getrf!</span>

  <span class="ruby-comment"># Now calculate the inverse using the pivot array</span>
  <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">LAPACK</span><span class="ruby-operator">::</span><span class="ruby-identifier">clapack_getri</span>(<span class="ruby-value">:row</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>], <span class="ruby-keyword">self</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">pivot</span>)

  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-is_ref-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">is_ref?</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Check to determine whether matrix is a reference to another matrix.</p>
          
          

          
          <div class="method-source-code" id="is_ref-3F-source">
            <pre>static VALUE nm_is_ref(VALUE self) {
  if (NM_SRC(self) == NM_STORAGE(self)) return Qfalse;
  return Qtrue;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-laswp" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            laswp(ary) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Permute the columns of a dense matrix using LASWP according to the order
given in an <a href="Array.html">Array</a> <code>ary</code>. Not yet
implemented for yale or list.</p>
          
          

          
          <div class="method-source-code" id="laswp-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 256</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">laswp</span>(<span class="ruby-identifier">ary</span>)
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">clone</span>.<span class="ruby-identifier">laswp!</span>(<span class="ruby-identifier">ary</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-permute_columns">permute_columns</a>
        </div>
        

        
      </div>

    
      <div id="method-i-laswp-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            laswp!(ary) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>In-place permute the columns of a dense matrix using LASWP according to the
order given in an <a href="Array.html">Array</a> <code>ary</code>. Not yet
implemented for yale or list.</p>
          
          

          
          <div class="method-source-code" id="laswp-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 246</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">laswp!</span>(<span class="ruby-identifier">ary</span>)
  <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">LAPACK</span><span class="ruby-operator">::</span><span class="ruby-identifier">laswp</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">ary</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-permute_columns-21">permute_columns!</a>
        </div>
        

        
      </div>

    
      <div id="method-i-layer" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            layer(layer_number) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            row(layer_number, get_by) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>layer_number</code> -&gt; Integer.</p>
</li><li>
<p><code>get_by</code> -&gt; Type of slicing to use, <code>:copy</code> or
<code>:reference</code>.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>A <a href="NMatrix.html">NMatrix</a> representing the requested layer as a
layer vector.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="layer-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 723</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">layer</span>(<span class="ruby-identifier">layer_number</span>, <span class="ruby-identifier">get_by</span> = <span class="ruby-value">:copy</span>)
  <span class="ruby-identifier">rank</span>(<span class="ruby-value">2</span>, <span class="ruby-identifier">layer_number</span>, <span class="ruby-identifier">get_by</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-list-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            list? &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Determine if <code>m</code> is a list-of-lists matrix.</p>
          
          

          
          <div class="method-source-code" id="list-3F-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">list?</span>;  <span class="ruby-keyword">return</span> <span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:list</span>; <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-load_matlab_file" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            load_matlab_file(path) &rarr; Mat5Reader
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>file_path</code> -&gt; The path to a version 5 .mat file.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>A Mat5Reader object.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="load_matlab_file-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">load_matlab_file</span>(<span class="ruby-identifier">file_path</span>)
  <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">IO</span><span class="ruby-operator">::</span><span class="ruby-constant">Mat5Reader</span>.<span class="ruby-identifier">new</span>(<span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-identifier">file_path</span>, <span class="ruby-string">&#39;rb&#39;</span>)).<span class="ruby-identifier">to_ruby</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-load_pcd_file" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            load_pcd_file(path) &rarr; PointCloudReader::MetaReader
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>file_path</code> -&gt; The path to a PCL PCD file.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>A PointCloudReader::MetaReader object with the matrix stored in its
<code>matrix</code> property</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="load_pcd_file-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 79</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">load_pcd_file</span>(<span class="ruby-identifier">file_path</span>)
  <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">IO</span><span class="ruby-operator">::</span><span class="ruby-constant">PointCloudReader</span><span class="ruby-operator">::</span><span class="ruby-constant">MetaReader</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">file_path</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-log" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">log</span><span
            class="method-args">(*args)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="log-source">
            <pre>static VALUE nm_unary_log(int argc, VALUE* argv, VALUE self) {
  NM_CONSERVATIVE(nm_register_values(argv, argc));
  const double default_log_base = exp(1.0);
  NMATRIX* left;
  UnwrapNMatrix(self, left);
  std::string sym;

  switch(left-&gt;stype) {
  case nm::DENSE_STORE:
    sym = &quot;__dense_unary_log__&quot;;
    break;
  case nm::YALE_STORE:
    sym = &quot;__yale_unary_log__&quot;;
    break;
  case nm::LIST_STORE:
    sym = &quot;__list_unary_log__&quot;;
    break;
  }
  NM_CONSERVATIVE(nm_unregister_values(argv, argc));
  if (argc &gt; 0) { //supplied a base
    return rb_funcall(self, rb_intern(sym.c_str()), 1, argv[0]);
  }
  return rb_funcall(self, rb_intern(sym.c_str()), 1, nm::RubyObject(default_log_base).rval);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-lower_triangle" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            lower_triangle &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            lower_triangle(k) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            tril &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            tril(k) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the lower triangular portion of a matrix. This is analogous to the
<code>tril</code> method in MATLAB.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>k</code> -&gt; Integer. How many extra diagonals to include in the
lower triangular portion.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="lower_triangle-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 670</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">lower_triangle</span>(<span class="ruby-identifier">k</span> = <span class="ruby-value">0</span>)
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">NotImplementedError</span>, <span class="ruby-string">&quot;only implemented for 2D matrices&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">2</span>

  <span class="ruby-identifier">t</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">clone_structure</span>
  (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">k</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]
      <span class="ruby-identifier">t</span>[<span class="ruby-identifier">i</span>, <span class="ruby-value">:*</span>] = <span class="ruby-keyword">self</span>[<span class="ruby-identifier">i</span>, <span class="ruby-value">:*</span>]
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">t</span>[<span class="ruby-identifier">i</span>, (<span class="ruby-identifier">i</span><span class="ruby-operator">+</span><span class="ruby-identifier">k</span><span class="ruby-operator">+</span><span class="ruby-value">1</span>)<span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>]] = <span class="ruby-value">0</span>
      <span class="ruby-identifier">t</span>[<span class="ruby-identifier">i</span>, <span class="ruby-value">0</span><span class="ruby-operator">..</span>(<span class="ruby-identifier">i</span><span class="ruby-operator">+</span><span class="ruby-identifier">k</span>)] = <span class="ruby-keyword">self</span>[<span class="ruby-identifier">i</span>, <span class="ruby-value">0</span><span class="ruby-operator">..</span>(<span class="ruby-identifier">i</span><span class="ruby-operator">+</span><span class="ruby-identifier">k</span>)]
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">t</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-tril">tril</a>
        </div>
        

        
      </div>

    
      <div id="method-i-lower_triangle-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            lower_triangle! &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            lower_triangle!(k) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            tril! &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            tril!(k) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Deletes the upper triangular portion of the matrix (in-place) so only the
lower portion remains.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>k</code> -&gt; Integer. How many extra diagonals to include in the
deletion.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="lower_triangle-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 699</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">lower_triangle!</span>(<span class="ruby-identifier">k</span> = <span class="ruby-value">0</span>)
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">NotImplementedError</span>, <span class="ruby-string">&quot;only implemented for 2D matrices&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">2</span>

  (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">k</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]
      <span class="ruby-keyword">self</span>[<span class="ruby-identifier">i</span>, (<span class="ruby-identifier">i</span><span class="ruby-operator">+</span><span class="ruby-identifier">k</span><span class="ruby-operator">+</span><span class="ruby-value">1</span>)<span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>]] = <span class="ruby-value">0</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-tril-21">tril!</a>
        </div>
        

        
      </div>

    
      <div id="method-i-map" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            map &rarr; Enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            map { |elem| block } &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an <a href="NMatrix.html">NMatrix</a> if a block is given. For an
<a href="Array.html">Array</a>, use <a
href="NMatrix.html#method-i-flat_map">flat_map</a></p>

<p>Note that <a href="NMatrix.html#method-i-map">map</a> will always return an
:object matrix, because it has no way of knowing how to handle operations
on the different dtypes.</p>
          
          

          
          <div class="method-source-code" id="map-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/enumerate.rb, line 72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">map</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">bl</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">enum_for</span>(<span class="ruby-value">:map</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block_given?</span>
  <span class="ruby-identifier">cp</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-value">:object</span>)
  <span class="ruby-identifier">cp</span>.<span class="ruby-identifier">map!</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">bl</span>)
  <span class="ruby-identifier">cp</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-flat_map">flat_map</a>
        </div>
        

        
      </div>

    
      <div id="method-i-map-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            map! &rarr; Enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            map! { |elem| block } &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Maps in place. @see <a href="NMatrix.html#method-i-map">map</a></p>
          
          

          
          <div class="method-source-code" id="map-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/enumerate.rb, line 87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">map!</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">enum_for</span>(<span class="ruby-value">:map!</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block_given?</span>
  <span class="ruby-identifier">iterated</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">each_stored_with_indices</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">e</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">iterated</span> = <span class="ruby-keyword">true</span>
    <span class="ruby-keyword">self</span>[<span class="ruby-operator">*</span><span class="ruby-identifier">i</span>] = (<span class="ruby-keyword">yield</span> <span class="ruby-identifier">e</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-comment">#HACK: if there&#39;s a single element in a non-dense matrix, it won&#39;t iterate and</span>
  <span class="ruby-comment">#won&#39;t change the default value; this ensures that it does get changed.</span>
  <span class="ruby-keyword">unless</span> <span class="ruby-identifier">iterated</span> <span class="ruby-keyword">then</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">each_with_indices</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">e</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">self</span>[<span class="ruby-operator">*</span><span class="ruby-identifier">i</span>] = (<span class="ruby-keyword">yield</span> <span class="ruby-identifier">e</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-map_stored" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            map_stored &rarr; Enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Iterate over the stored entries of any matrix. For dense and yale, this
iterates over non-zero entries; for list, this iterates over non-default
entries. Yields dim+1 values for each entry: i, j, …, and the entry itself.</p>
          
          

          
          <div class="method-source-code" id="map_stored-source">
            <pre>static VALUE nm_map_stored(VALUE nmatrix) {
  NM_CONSERVATIVE(nm_register_value(nmatrix));
  VALUE to_return = Qnil;

  switch(NM_STYPE(nmatrix)) {
  case nm::YALE_STORE:
    to_return = nm_yale_map_stored(nmatrix);
    break;
  case nm::DENSE_STORE:
    to_return = nm_dense_map(nmatrix);
    break;
  case nm::LIST_STORE:
    to_return = nm_list_map_stored(nmatrix, Qnil);
    break;
  default:
    NM_CONSERVATIVE(nm_unregister_value(nmatrix));
    rb_raise(nm_eDataTypeError, &quot;Not a proper storage type&quot;);
  }

  NM_CONSERVATIVE(nm_unregister_value(nmatrix));
  return to_return;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-max" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            max() &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            max(dimen) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calculates the maximum along the specified dimension.</p>

<p>@see <a href="NMatrix.html#method-i-inject_rank">inject_rank</a></p>
          
          

          
          <div class="method-source-code" id="max-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 427</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">max</span>(<span class="ruby-identifier">dimen</span>=<span class="ruby-value">0</span>)
  <span class="ruby-identifier">inject_rank</span>(<span class="ruby-identifier">dimen</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">max</span>, <span class="ruby-identifier">sub_mat</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">max</span>.<span class="ruby-identifier">is_a?</span> <span class="ruby-constant">NMatrix</span> <span class="ruby-keyword">then</span>
      <span class="ruby-identifier">max</span> <span class="ruby-operator">*</span> (<span class="ruby-identifier">max</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-identifier">sub_mat</span>).<span class="ruby-identifier">cast</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>) <span class="ruby-operator">+</span> ((<span class="ruby-identifier">max</span>)<span class="ruby-operator">*</span><span class="ruby-value">0.0</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">max</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">sub_mat</span>).<span class="ruby-identifier">cast</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>)) <span class="ruby-operator">*</span> <span class="ruby-identifier">sub_mat</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">max</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-identifier">sub_mat</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">max</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">sub_mat</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-mean" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            mean() &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            mean(dimen) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calculates the mean along the specified dimension.</p>

<p>This will force integer types to float64 dtype.</p>

<p>@see <a href="NMatrix.html#method-i-inject_rank">inject_rank</a></p>
          
          

          
          <div class="method-source-code" id="mean-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 374</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">mean</span>(<span class="ruby-identifier">dimen</span>=<span class="ruby-value">0</span>)
  <span class="ruby-identifier">reduce_dtype</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">integer_dtype?</span> <span class="ruby-keyword">then</span>
    <span class="ruby-identifier">reduce_dtype</span> = <span class="ruby-value">:float64</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">inject_rank</span>(<span class="ruby-identifier">dimen</span>, <span class="ruby-value">0.0</span>, <span class="ruby-identifier">reduce_dtype</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">mean</span>, <span class="ruby-identifier">sub_mat</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">mean</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">sub_mat</span>
  <span class="ruby-keyword">end</span> <span class="ruby-operator">/</span> <span class="ruby-identifier">shape</span>[<span class="ruby-identifier">dimen</span>]
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-min" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            min() &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            min(dimen) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calculates the minimum along the specified dimension.</p>

<p>@see <a href="NMatrix.html#method-i-inject_rank">inject_rank</a></p>
          
          

          
          <div class="method-source-code" id="min-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 408</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">min</span>(<span class="ruby-identifier">dimen</span>=<span class="ruby-value">0</span>)
  <span class="ruby-identifier">inject_rank</span>(<span class="ruby-identifier">dimen</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">min</span>, <span class="ruby-identifier">sub_mat</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">min</span>.<span class="ruby-identifier">is_a?</span> <span class="ruby-constant">NMatrix</span> <span class="ruby-keyword">then</span>
      <span class="ruby-identifier">min</span> <span class="ruby-operator">*</span> (<span class="ruby-identifier">min</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">sub_mat</span>).<span class="ruby-identifier">cast</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>) <span class="ruby-operator">+</span> ((<span class="ruby-identifier">min</span>)<span class="ruby-operator">*</span><span class="ruby-value">0.0</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">min</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">sub_mat</span>).<span class="ruby-identifier">cast</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>)) <span class="ruby-operator">*</span> <span class="ruby-identifier">sub_mat</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">min</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">sub_mat</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">min</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">sub_mat</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-norm2" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">norm2</span><span
            class="method-args">(incx=1, n=nil)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-nrm2">nrm2</a>
        </div>
        
      </div>

    
      <div id="method-i-nrm2" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            norm2 &rarr; Numeric
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <h2 id="method-i-nrm2-label-Arguments">Arguments<span><a href="#method-i-nrm2-label-Arguments">&para;</a> <a href="#documentation">&uarr;</a></span></h2>

<pre>- +incx+ -&gt; the skip size (defaults to 1, no skip)
- +n+ -&gt; the number of elements to include</pre>

<p>Return the 2-norm of the vector. This is the BLAS nrm2 routine.</p>
          
          

          
          <div class="method-source-code" id="nrm2-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 535</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">nrm2</span> <span class="ruby-identifier">incx</span>=<span class="ruby-value">1</span>, <span class="ruby-identifier">n</span>=<span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">method_missing</span>(<span class="ruby-value">:nrm2</span>, <span class="ruby-identifier">incx</span>, <span class="ruby-identifier">n</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">vector?</span>
  <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">BLAS</span><span class="ruby-operator">::</span><span class="ruby-identifier">nrm2</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">incx</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">/</span> <span class="ruby-identifier">incx</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-norm2">norm2</a>
        </div>
        

        
      </div>

    
      <div id="method-i-nvector-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            nvector? &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Shortcut function for determining whether the effective dimension is less
than the dimension. Useful when we take slices of n-dimensional matrices
where n &gt; 2.</p>
          
          

          
          <div class="method-source-code" id="nvector-3F-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 298</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">nvector?</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">effective_dim</span> <span class="ruby-operator">&lt;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-offset" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            offset &rarr; Array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the offset (slice position) of a matrix. Typically all zeros, unless
you have a reference slice.</p>
          
          

          
          <div class="method-source-code" id="offset-source">
            <pre>static VALUE nm_offset(VALUE self) {
  NM_CONSERVATIVE(nm_register_value(self));
  STORAGE* s   = NM_STORAGE(self);

  // Copy elements into a VALUE array and then use those to create a Ruby array with rb_ary_new4.
  VALUE* offset = NM_ALLOCA_N(VALUE, s-&gt;dim);
  nm_register_values(offset, s-&gt;dim);
  for (size_t index = 0; index &lt; s-&gt;dim; ++index)
    offset[index] = INT2FIX(s-&gt;offset[index]);

  nm_unregister_values(offset, s-&gt;dim);
  NM_CONSERVATIVE(nm_unregister_value(self));
  return rb_ary_new4(s-&gt;dim, offset);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-ones" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            ones(shape) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            ones(shape, dtype: dtype, stype: stype) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a matrix filled with ones.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>shape</code> -&gt; <a href="Array.html">Array</a> (or integer for
square matrix) specifying the shape.</p>
</li><li>
<p><code>opts</code> -&gt; (optional) Hash of options from NMatrix#initialize</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p><a href="NMatrix.html">NMatrix</a> filled with ones.</p>
</li></ul>
</li></ul>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">ones</span>([<span class="ruby-value">1</span>, <span class="ruby-value">3</span>]) <span class="ruby-comment"># =&gt;  1.0   1.0   1.0</span>

<span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">ones</span>([<span class="ruby-value">2</span>, <span class="ruby-value">3</span>], <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">int32</span>) <span class="ruby-comment"># =&gt;  1  1  1</span>
                                          <span class="ruby-value">1</span>  <span class="ruby-value">1</span>  <span class="ruby-value">1</span>
</pre>
          
          

          
          <div class="method-source-code" id="ones-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 172</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">ones</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">opts</span>={})
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-value">1</span>, {<span class="ruby-value">:dtype</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">:float64</span>, <span class="ruby-value">:default</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>}.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>))
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-ones_like" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            ones_like(nm) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a new matrix of ones with the same dtype and shape as the provided
matrix.</p>

<p>@param [NMatrix] nm the nmatrix whose dtype and shape will be used @return
[NMatrix] a new nmatrix filled with ones.</p>
          
          

          
          <div class="method-source-code" id="ones_like-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 185</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">ones_like</span>(<span class="ruby-identifier">nm</span>)
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">ones</span>(<span class="ruby-identifier">nm</span>.<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-identifier">nm</span>.<span class="ruby-identifier">dtype</span>, <span class="ruby-identifier">stype</span><span class="ruby-operator">:</span> <span class="ruby-identifier">nm</span>.<span class="ruby-identifier">stype</span>, <span class="ruby-identifier">capacity</span><span class="ruby-operator">:</span> <span class="ruby-identifier">nm</span>.<span class="ruby-identifier">capacity</span>, <span class="ruby-identifier">default</span><span class="ruby-operator">:</span> <span class="ruby-value">1</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-permute_columns" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">permute_columns</span><span
            class="method-args">(ary)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-laswp">laswp</a>
        </div>
        
      </div>

    
      <div id="method-i-permute_columns-21" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">permute_columns!</span><span
            class="method-args">(ary)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-laswp-21">laswp!</a>
        </div>
        
      </div>

    
      <div id="method-i-potrf-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            potrf!(upper_or_lower) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Cholesky factorization of a symmetric positive-definite matrix – or, if
complex, a Hermitian positive-definite matrix <code>A</code>. This uses the
ATLAS function clapack_potrf, so the result will be written in either the
upper or lower triangular portion of the matrix upon which it is called.</p>
<ul><li>
<p><strong>Returns</strong> : the triangular portion specified by the
parameter</p>
</li><li>
<p><strong>Raises</strong> :</p>
<ul><li>
<p><code>StorageTypeError</code> -&gt; ATLAS functions only work on dense
matrices.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="potrf-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 137</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">potrf!</span>(<span class="ruby-identifier">which</span>)
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">StorageTypeError</span>, <span class="ruby-string">&quot;ATLAS functions only work on dense matrices&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dense?</span>
  <span class="ruby-comment"># FIXME: Surely there&#39;s an easy way to calculate one of these from the other. Do we really need to run twice?</span>
  <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">LAPACK</span><span class="ruby-operator">::</span><span class="ruby-identifier">clapack_potrf</span>(<span class="ruby-value">:row</span>, <span class="ruby-identifier">which</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>], <span class="ruby-keyword">self</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>])
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-potrf_lower-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">potrf_lower!</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="potrf_lower-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">potrf_lower!</span>
  <span class="ruby-identifier">potrf!</span> <span class="ruby-value">:lower</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-potrf_upper-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">potrf_upper!</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="potrf_upper-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 143</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">potrf_upper!</span>
  <span class="ruby-identifier">potrf!</span> <span class="ruby-value">:upper</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-random" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            random(shape) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a <code>:dense</code> <a href="NMatrix.html">NMatrix</a> with
random numbers between 0 and 1 generated by +Random::rand+. The parameter
is the dimension of the matrix.</p>

<p>If you use an integer dtype, make sure to specify :scale as a parameter, or
you&#39;ll only get a matrix of 0s. You may not currently generate random
numbers for a rational matrix.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>shape</code> -&gt; <a href="Array.html">Array</a> (or integer for
square matrix) specifying the dimensions.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p><a href="NMatrix.html">NMatrix</a> filled with random values.</p>
</li></ul>
</li></ul>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">random</span>([<span class="ruby-value">2</span>, <span class="ruby-value">2</span>]) <span class="ruby-comment"># =&gt; 0.4859439730644226   0.1783195585012436</span>
                            <span class="ruby-value">0.23193766176700592</span>  <span class="ruby-value">0.4503345191478729</span>

<span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">random</span>([<span class="ruby-value">2</span>, <span class="ruby-value">2</span>], :<span class="ruby-identifier">dtype</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">byte</span>, :<span class="ruby-identifier">scale</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">255</span>) <span class="ruby-comment"># =&gt; [ [252, 108] [44, 12] ]</span>
</pre>
          
          

          
          <div class="method-source-code" id="random-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 302</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">random</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">opts</span>={})
  <span class="ruby-identifier">scale</span> = <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:scale</span>) <span class="ruby-operator">||</span> <span class="ruby-value">1.0</span>

  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">NotImplementedError</span>, <span class="ruby-string">&quot;does not support rational random number generation&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:dtype</span>].<span class="ruby-identifier">to_s</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp">/^rational/</span>

  <span class="ruby-identifier">rng</span> = <span class="ruby-constant">Random</span>.<span class="ruby-identifier">new</span>

  <span class="ruby-identifier">random_values</span> = []


  <span class="ruby-comment"># Construct the values of the final matrix based on the dimension.</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:dtype</span>] <span class="ruby-operator">==</span> <span class="ruby-value">:complex64</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:dtype</span>] <span class="ruby-operator">==</span> <span class="ruby-value">:complex128</span>
    <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">size</span>(<span class="ruby-identifier">shape</span>).<span class="ruby-identifier">times</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">random_values</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">Complex</span>(<span class="ruby-identifier">rng</span>.<span class="ruby-identifier">rand</span>(<span class="ruby-identifier">scale</span>), <span class="ruby-identifier">rng</span>.<span class="ruby-identifier">rand</span>(<span class="ruby-identifier">scale</span>)) }
  <span class="ruby-keyword">else</span>
    <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">size</span>(<span class="ruby-identifier">shape</span>).<span class="ruby-identifier">times</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">random_values</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">rng</span>.<span class="ruby-identifier">rand</span>(<span class="ruby-identifier">scale</span>) }
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">random_values</span>, {<span class="ruby-value">:dtype</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">:float64</span>, <span class="ruby-value">:stype</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">:dense</span>}.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>))
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-rank" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            rank(dimension, row_or_column_number) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            rank(dimension, row_or_column_number, :reference) &rarr; NMatrix reference slice
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the rank (e.g., row, column, or layer) specified, using slicing by
copy as default.</p>

<p>See @row (dimension = 0), @column (dimension = 1)</p>
          
          

          
          <div class="method-source-code" id="rank-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 350</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">rank</span>(<span class="ruby-identifier">shape_idx</span>, <span class="ruby-identifier">rank_idx</span>, <span class="ruby-identifier">meth</span> = <span class="ruby-value">:copy</span>)

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">shape_idx</span> <span class="ruby-operator">&gt;</span> (<span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span><span class="ruby-operator">-</span><span class="ruby-value">1</span>)
    <span class="ruby-identifier">raise</span>(<span class="ruby-constant">RangeError</span>, <span class="ruby-node">&quot;#rank call was out of bounds&quot;</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">params</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span>)
  <span class="ruby-identifier">params</span>.<span class="ruby-identifier">each</span>.<span class="ruby-identifier">with_index</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">v</span>,<span class="ruby-identifier">d</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">params</span>[<span class="ruby-identifier">d</span>] = <span class="ruby-identifier">d</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">shape_idx</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">rank_idx</span> <span class="ruby-operator">:</span> <span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-identifier">d</span>]
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">meth</span> <span class="ruby-operator">==</span> <span class="ruby-value">:reference</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">self</span>[<span class="ruby-operator">*</span><span class="ruby-identifier">params</span>] <span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">slice</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">params</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-reduce_along_dim" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">reduce_along_dim</span><span
            class="method-args">(dimen=0, initial=nil, dtype=nil)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-inject_rank">inject_rank</a>
        </div>
        
      </div>

    
      <div id="method-i-reshape" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            reshape(new_shape) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Clone a matrix, changing the shape in the process. Note that this function
does not do a resize; the product of the new and old shapes&#39; components
must be equal.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>new_shape</code> -&gt; <a href="Array.html">Array</a> of positive
Fixnums.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>A copy with a different shape.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="reshape-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 419</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">reshape</span> <span class="ruby-identifier">new_shape</span>,<span class="ruby-operator">*</span><span class="ruby-identifier">shapes</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">new_shape</span>.<span class="ruby-identifier">is_a?</span><span class="ruby-constant">Fixnum</span>
    <span class="ruby-identifier">newer_shape</span> =  [<span class="ruby-identifier">new_shape</span>]<span class="ruby-operator">+</span><span class="ruby-identifier">shapes</span>
  <span class="ruby-keyword">else</span>  <span class="ruby-comment"># new_shape is an Array</span>
    <span class="ruby-identifier">newer_shape</span> = <span class="ruby-identifier">new_shape</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">t</span> = <span class="ruby-identifier">reshape_clone_structure</span>(<span class="ruby-identifier">newer_shape</span>)
  <span class="ruby-identifier">left_params</span>  = [<span class="ruby-value">:*</span>]<span class="ruby-operator">*</span><span class="ruby-identifier">newer_shape</span>.<span class="ruby-identifier">size</span>
  <span class="ruby-identifier">puts</span>(<span class="ruby-identifier">left_params</span>)
  <span class="ruby-identifier">right_params</span> = [<span class="ruby-value">:*</span>]<span class="ruby-operator">*</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>.<span class="ruby-identifier">size</span>
  <span class="ruby-identifier">t</span>[<span class="ruby-operator">*</span><span class="ruby-identifier">left_params</span>] = <span class="ruby-keyword">self</span>[<span class="ruby-operator">*</span><span class="ruby-identifier">right_params</span>]
  <span class="ruby-identifier">t</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-reshape-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            reshape!(new_shape) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            reshape! new_shape  &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Reshapes the matrix (in-place) to the desired shape. Note that this
function does not do a resize; the product of the new and old shapes&#39;
components must be equal.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>new_shape</code> -&gt; <a href="Array.html">Array</a> of positive
Fixnums.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="reshape-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 445</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">reshape!</span> <span class="ruby-identifier">new_shape</span>,<span class="ruby-operator">*</span><span class="ruby-identifier">shapes</span>
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">is_ref?</span>
    <span class="ruby-identifier">raise</span>(<span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&quot;This operation cannot be performed on reference slices&quot;</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">new_shape</span>.<span class="ruby-identifier">is_a?</span><span class="ruby-constant">Fixnum</span>
      <span class="ruby-identifier">shape</span> =  [<span class="ruby-identifier">new_shape</span>]<span class="ruby-operator">+</span><span class="ruby-identifier">shapes</span>
    <span class="ruby-keyword">else</span>  <span class="ruby-comment"># new_shape is an Array</span>
      <span class="ruby-identifier">shape</span> = <span class="ruby-identifier">new_shape</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">reshape_bang</span>(<span class="ruby-identifier">shape</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-row" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            row(row_number) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            row(row_number, get_by) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>row_number</code> -&gt; Integer.</p>
</li><li>
<p><code>get_by</code> -&gt; Type of slicing to use, <code>:copy</code> or
<code>:reference</code>.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>An <a href="NMatrix.html">NMatrix</a> representing the requested row as a
row vector.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="row-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 402</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">row</span>(<span class="ruby-identifier">row_number</span>, <span class="ruby-identifier">get_by</span> = <span class="ruby-value">:copy</span>)
  <span class="ruby-identifier">rank</span>(<span class="ruby-value">0</span>, <span class="ruby-identifier">row_number</span>, <span class="ruby-identifier">get_by</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-rows" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            rows &rarr; Integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>This shortcut use <a href="NMatrix.html#method-i-shape">shape</a> to return
the number of rows (the first dimension) of the matrix.</p>
          
          

          
          <div class="method-source-code" id="rows-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 183</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">rows</span>
  <span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-seq" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            seq(shape) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            seq(shape, options) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            bindgen(shape) &rarr; NMatrix of :byte
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            indgen(shape) &rarr; NMatrix of :int64
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            findgen(shape) &rarr; NMatrix of :float32
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            dindgen(shape) &rarr; NMatrix of :float64
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            cindgen(shape) &rarr; NMatrix of :complex64
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            zindgen(shape) &rarr; NMatrix of :complex128
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            rindgen(shape) &rarr; NMatrix of :rational128
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            rbindgen(shape) &rarr; NMatrix of :object
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a matrix filled with a sequence of integers starting at zero.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>shape</code> -&gt; <a href="Array.html">Array</a> (or integer for
square matrix) specifying the dimensions.</p>
</li><li>
<p><code>options</code> -&gt; (optional) Options permissible for
NMatrix#initialize</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p><a href="NMatrix.html">NMatrix</a> filled with values 0 through
<code>size</code>.</p>
</li></ul>
</li></ul>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">seq</span>(<span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt;   0   1</span>
              <span class="ruby-value">2</span>   <span class="ruby-value">3</span>

<span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">seq</span>([<span class="ruby-value">3</span>, <span class="ruby-value">3</span>], <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">float32</span>) <span class="ruby-comment"># =&gt;  0.0  1.0  2.0</span>
                                    <span class="ruby-value">3.0</span>  <span class="ruby-value">4.0</span>  <span class="ruby-value">5.0</span>
                                    <span class="ruby-value">6.0</span>  <span class="ruby-value">7.0</span>  <span class="ruby-value">8.0</span>
</pre>
          
          

          
          <div class="method-source-code" id="seq-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 353</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">seq</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">options</span>={})

  <span class="ruby-comment"># Construct the values of the final matrix based on the dimension.</span>
  <span class="ruby-identifier">values</span> = (<span class="ruby-value">0</span> <span class="ruby-operator">...</span> <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">size</span>(<span class="ruby-identifier">shape</span>)).<span class="ruby-identifier">to_a</span>

  <span class="ruby-comment"># It&#39;ll produce :int32, except if a dtype is provided.</span>
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">values</span>, {<span class="ruby-value">:stype</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">:dense</span>}.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">options</span>))
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-shape" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            shape &rarr; Array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the shape (dimensions) of a matrix.</p>
          
          

          
          <div class="method-source-code" id="shape-source">
            <pre>static VALUE nm_shape(VALUE self) {
  NM_CONSERVATIVE(nm_register_value(self));
  STORAGE* s   = NM_STORAGE(self);

  // Copy elements into a VALUE array and then use those to create a Ruby array with rb_ary_new4.
  VALUE* shape = NM_ALLOCA_N(VALUE, s-&gt;dim);
  nm_register_values(shape, s-&gt;dim);
  for (size_t index = 0; index &lt; s-&gt;dim; ++index)
    shape[index] = INT2FIX(s-&gt;shape[index]);

  nm_unregister_values(shape, s-&gt;dim);
  NM_CONSERVATIVE(nm_unregister_value(self));
  return rb_ary_new4(s-&gt;dim, shape);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-shuffle" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            shuffle &rarr; ...
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            shuffle(rng) &rarr; ...
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Re-arranges the contents of an <a href="NVector.html">NVector</a>.</p>

<p>TODO: Write more efficient version for Yale, list. TODO: Generalize for
more dimensions.</p>
          
          

          
          <div class="method-source-code" id="shuffle-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 756</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">shuffle</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
  <span class="ruby-identifier">method_missing</span>(<span class="ruby-value">:shuffle!</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>) <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">effective_dim</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>
  <span class="ruby-identifier">t</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">clone</span>
  <span class="ruby-identifier">t</span>.<span class="ruby-identifier">shuffle!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-shuffle-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            shuffle! &rarr; ...
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            shuffle!(random: rng) &rarr; ...
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Re-arranges the contents of an <a href="NVector.html">NVector</a>.</p>

<p>TODO: Write more efficient version for Yale, list. TODO: Generalize for
more dimensions.</p>
          
          

          
          <div class="method-source-code" id="shuffle-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 738</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">shuffle!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
  <span class="ruby-identifier">method_missing</span>(<span class="ruby-value">:shuffle!</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>) <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">effective_dim</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>
  <span class="ruby-identifier">ary</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">to_flat_a</span>
  <span class="ruby-identifier">ary</span>.<span class="ruby-identifier">shuffle!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
  <span class="ruby-identifier">ary</span>.<span class="ruby-identifier">each</span>.<span class="ruby-identifier">with_index</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">v</span>,<span class="ruby-identifier">idx</span><span class="ruby-operator">|</span> <span class="ruby-keyword">self</span>[<span class="ruby-identifier">idx</span>] = <span class="ruby-identifier">v</span> }
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-size" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">size</span><span
            class="method-args">(shape)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Calculate the size of an <a href="NMatrix.html">NMatrix</a> of a given
shape.</p>
          
          

          
          <div class="method-source-code" id="size-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">size</span>(<span class="ruby-identifier">shape</span>)
  <span class="ruby-identifier">shape</span> = [<span class="ruby-identifier">shape</span>,<span class="ruby-identifier">shape</span>] <span class="ruby-keyword">unless</span> <span class="ruby-identifier">shape</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>)
  (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-identifier">shape</span>.<span class="ruby-identifier">size</span>).<span class="ruby-identifier">inject</span>(<span class="ruby-value">1</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span>,<span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">*</span> <span class="ruby-identifier">shape</span>[<span class="ruby-identifier">i</span>] }
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-slice" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            slice &rarr; ...
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Access the contents of an <a href="NMatrix.html">NMatrix</a> at given
coordinates, using copying.</p>

<pre class="ruby"><span class="ruby-identifier">n</span>.<span class="ruby-identifier">slice</span>(<span class="ruby-value">3</span>,<span class="ruby-value">3</span>)  <span class="ruby-comment"># =&gt; 5.0</span>
<span class="ruby-identifier">n</span>.<span class="ruby-identifier">slice</span>(<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>,<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>) <span class="ruby-comment">#=&gt; matrix [2,2]</span>
</pre>
          
          

          
          <div class="method-source-code" id="slice-source">
            <pre>static VALUE nm_mget(int argc, VALUE* argv, VALUE self) {
  static void* (*ttable[nm::NUM_STYPES])(const STORAGE*, SLICE*) = {
    nm_dense_storage_get,
    nm_list_storage_get,
    nm_yale_storage_get
  };
  nm::stype_t stype = NM_STYPE(self);
  return nm_xslice(argc, argv, ttable[stype], nm_delete, self);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-sorted_indices" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            sorted_indices &rarr; Array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an array of the indices ordered by value sorted.</p>
          
          

          
          <div class="method-source-code" id="sorted_indices-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 769</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">sorted_indices</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">method_missing</span>(<span class="ruby-value">:sorted_indices</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">vector?</span>
  <span class="ruby-identifier">ary</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">to_flat_array</span>
  <span class="ruby-identifier">ary</span>.<span class="ruby-identifier">each_index</span>.<span class="ruby-identifier">sort_by</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ary</span>[<span class="ruby-identifier">i</span>] }  <span class="ruby-comment"># from: http://stackoverflow.com/a/17841159/170300</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-std" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            std() &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            std(dimen) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calculates the sample standard deviation along the specified dimension.</p>

<p>This will force integer types to float64 dtype.</p>

<p>@see <a href="NMatrix.html#method-i-inject_rank">inject_rank</a></p>
          
          

          
          <div class="method-source-code" id="std-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 472</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">std</span>(<span class="ruby-identifier">dimen</span>=<span class="ruby-value">0</span>)
  <span class="ruby-identifier">variance</span>(<span class="ruby-identifier">dimen</span>).<span class="ruby-identifier">sqrt</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-stype" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            stype &rarr; Symbol
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the storage type (stype) of a matrix, e.g., :yale, :dense, or :list.</p>
          
          

          
          <div class="method-source-code" id="stype-source">
            <pre>static VALUE nm_stype(VALUE self) {
  NM_CONSERVATIVE(nm_register_value(self));
  VALUE stype = ID2SYM(rb_intern(STYPE_NAMES[NM_STYPE(self)]));
  NM_CONSERVATIVE(nm_unregister_value(self));
  return stype;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-sum" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            sum() &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            sum(dimen) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calculates the sum along the specified dimension.</p>

<p>@see <a href="NMatrix.html#method-i-inject_rank">inject_rank</a></p>
          
          

          
          <div class="method-source-code" id="sum-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 392</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">sum</span>(<span class="ruby-identifier">dimen</span>=<span class="ruby-value">0</span>)
  <span class="ruby-identifier">inject_rank</span>(<span class="ruby-identifier">dimen</span>, <span class="ruby-value">0.0</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">sum</span>, <span class="ruby-identifier">sub_mat</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">sum</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">sub_mat</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-supershape" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            supershape &rarr; Array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the shape of a slice&#39;s parent.</p>
          
          

          
          <div class="method-source-code" id="supershape-source">
            <pre>static VALUE nm_supershape(VALUE self) {

  STORAGE* s   = NM_STORAGE(self);
  if (s-&gt;src == s) {
    return nm_shape(self); // easy case (not a slice)
  }
  else s = s-&gt;src;

  NM_CONSERVATIVE(nm_register_value(self));

  VALUE* shape = NM_ALLOCA_N(VALUE, s-&gt;dim);
  nm_register_values(shape, s-&gt;dim);
  for (size_t index = 0; index &lt; s-&gt;dim; ++index)
    shape[index] = INT2FIX(s-&gt;shape[index]);

  nm_unregister_values(shape, s-&gt;dim);
  NM_CONSERVATIVE(nm_unregister_value(self));
  return rb_ary_new4(s-&gt;dim, shape);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-symmetric-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            symmetric? &rarr; Boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Is this matrix symmetric?</p>
          
          

          
          <div class="method-source-code" id="symmetric-3F-source">
            <pre>static VALUE nm_symmetric(VALUE self) {
  return is_symmetric(self, false);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-to_a" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            to_a &rarr; Array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Converts an <a href="NMatrix.html">NMatrix</a> to an array of arrays, or an
<a href="NMatrix.html">NMatrix</a> of effective dimension 1 to an array.</p>

<p>Does not yet work for dimensions &gt; 2</p>
          
          

          
          <div class="method-source-code" id="to_a-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 320</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">to_a</span>(<span class="ruby-identifier">dimen</span>=<span class="ruby-keyword">nil</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span> <span class="ruby-operator">==</span> <span class="ruby-value">2</span>

    <span class="ruby-keyword">return</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">to_flat_a</span> <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-value">1</span>

    <span class="ruby-identifier">ary</span> = []
    <span class="ruby-keyword">begin</span>
      <span class="ruby-keyword">self</span>.<span class="ruby-identifier">each_row</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">row</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">ary</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">row</span>.<span class="ruby-identifier">to_flat_a</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-comment">#rescue NotImplementedError # Oops. Try copying instead</span>
    <span class="ruby-comment">#  self.each_row(:copy) do |row|</span>
    <span class="ruby-comment">#    ary &lt;&lt; row.to_a.flatten</span>
    <span class="ruby-comment">#  end</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">ary</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">to_a_rec</span>(<span class="ruby-value">0</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-to_f" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            to_f &rarr; Float
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Converts an nmatrix with a single element (but any number of dimensions)</p>

<pre>to a float.</pre>

<p>Raises an IndexError if the matrix does not have just a single element.</p>
          
          

          
          <div class="method-source-code" id="to_f-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 257</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">to_f</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">IndexError</span>, <span class="ruby-string">&#39;to_f only valid for matrices with a single element&#39;</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">shape</span>.<span class="ruby-identifier">all?</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span> }
  <span class="ruby-keyword">self</span>[<span class="ruby-operator">*</span><span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">shape</span>.<span class="ruby-identifier">size</span>, <span class="ruby-value">0</span>)]
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-to_flat_a" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">to_flat_a</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-to_flat_array">to_flat_array</a>
        </div>
        
      </div>

    
      <div id="method-i-to_flat_array" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            to_flat_array &rarr; Array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            to_flat_a &rarr; Array
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Converts an <a href="NMatrix.html">NMatrix</a> to a one-dimensional Ruby <a
href="Array.html">Array</a>.</p>
          
          

          
          <div class="method-source-code" id="to_flat_array-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 269</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">to_flat_array</span>
  <span class="ruby-identifier">ary</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">size</span>)
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">each</span>.<span class="ruby-identifier">with_index</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">v</span>,<span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ary</span>[<span class="ruby-identifier">i</span>] = <span class="ruby-identifier">v</span> }
  <span class="ruby-identifier">ary</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-to_flat_a">to_flat_a</a>
        </div>
        

        
      </div>

    
      <div id="method-i-to_h" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">to_h</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-to_hash">to_hash</a>
        </div>
        
      </div>

    
      <div id="method-i-to_hash" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            to_hash &rarr; Hash
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Create a Ruby Hash from an <a href="NMatrix.html">NMatrix</a>.</p>
          
          

          
          <div class="method-source-code" id="to_hash-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 204</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">to_hash</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:yale</span>
    <span class="ruby-identifier">h</span> = {}
    <span class="ruby-identifier">each_stored_with_indices</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">val</span>,<span class="ruby-identifier">i</span>,<span class="ruby-identifier">j</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">next</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">val</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-comment"># Don&#39;t bother storing the diagonal zero values -- only non-zeros.</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">h</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">i</span>)
        <span class="ruby-identifier">h</span>[<span class="ruby-identifier">i</span>][<span class="ruby-identifier">j</span>] = <span class="ruby-identifier">val</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">h</span>[<span class="ruby-identifier">i</span>] = {<span class="ruby-identifier">j</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">val</span>}
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">h</span>
  <span class="ruby-keyword">else</span> <span class="ruby-comment"># dense and list should use a C internal function.</span>
    <span class="ruby-comment"># FIXME: Write a C internal to_h function.</span>
    <span class="ruby-identifier">m</span> = <span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dense</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-value">:list</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>) <span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>
    <span class="ruby-identifier">m</span>.<span class="ruby-identifier">__list_to_hash__</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-to_h">to_h</a>
        </div>
        

        
      </div>

    
      <div id="method-i-transpose" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            transpose &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            transpose(permutation) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Clone a matrix, transposing it in the process. If the matrix is
two-dimensional, the permutation is taken to be [1,0] automatically (switch
dimension 0 with dimension 1). If the matrix is n-dimensional, you must
provide a permutation of <code>0...n</code>.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>permutation</code> -&gt; Optional <a href="Array.html">Array</a>
giving a permutation.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>A copy of the matrix, but transposed.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="transpose-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 472</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">transpose</span>(<span class="ruby-identifier">permute</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
    <span class="ruby-keyword">return</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">clone</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span> <span class="ruby-operator">==</span> <span class="ruby-value">2</span>
    <span class="ruby-identifier">new_shape</span> = [<span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>], <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]]
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">permute</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-identifier">raise</span>(<span class="ruby-constant">ArgumentError</span>, <span class="ruby-node">&quot;need permutation array of size #{self.dim}&quot;</span>)
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">permute</span>.<span class="ruby-identifier">sort</span>.<span class="ruby-identifier">uniq</span> <span class="ruby-operator">!=</span> (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span>).<span class="ruby-identifier">to_a</span>
    <span class="ruby-identifier">raise</span>(<span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&quot;invalid permutation array&quot;</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-comment"># Figure out the new shape based on the permutation given as an argument.</span>
    <span class="ruby-identifier">new_shape</span> = <span class="ruby-identifier">permute</span>.<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">p</span><span class="ruby-operator">|</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-identifier">p</span>] }
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">2</span> <span class="ruby-comment"># FIXME: For dense, several of these are basically equivalent to reshape.</span>

    <span class="ruby-comment"># Make the new data structure.</span>
    <span class="ruby-identifier">t</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">reshape_clone_structure</span>(<span class="ruby-identifier">new_shape</span>)

    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">each_stored_with_indices</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">v</span>,<span class="ruby-operator">*</span><span class="ruby-identifier">indices</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">p_indices</span> = <span class="ruby-identifier">permute</span>.<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">p</span><span class="ruby-operator">|</span> <span class="ruby-identifier">indices</span>[<span class="ruby-identifier">p</span>] }
      <span class="ruby-identifier">t</span>[<span class="ruby-operator">*</span><span class="ruby-identifier">p_indices</span>] = <span class="ruby-identifier">v</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">t</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">list?</span> <span class="ruby-comment"># TODO: Need a C list transposition algorithm.</span>
    <span class="ruby-comment"># Make the new data structure.</span>
    <span class="ruby-identifier">t</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">reshape_clone_structure</span>(<span class="ruby-identifier">new_shape</span>)

    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">each_column</span>.<span class="ruby-identifier">with_index</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">col</span>,<span class="ruby-identifier">j</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">t</span>[<span class="ruby-identifier">j</span>,<span class="ruby-value">:*</span>] = <span class="ruby-identifier">col</span>.<span class="ruby-identifier">to_flat_array</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">t</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-comment"># Call C versions of Yale and List transpose, which do their own copies</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">clone_transpose</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-tril" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">tril</span><span
            class="method-args">(k = 0)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-lower_triangle">lower_triangle</a>
        </div>
        
      </div>

    
      <div id="method-i-tril-21" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">tril!</span><span
            class="method-args">(k = 0)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-lower_triangle-21">lower_triangle!</a>
        </div>
        
      </div>

    
      <div id="method-i-triu" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">triu</span><span
            class="method-args">(k = 0)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-upper_triangle">upper_triangle</a>
        </div>
        
      </div>

    
      <div id="method-i-triu-21" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">triu!</span><span
            class="method-args">(k = 0)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-upper_triangle-21">upper_triangle!</a>
        </div>
        
      </div>

    
      <div id="method-i-upper_triangle" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            upper_triangle &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            upper_triangle(k) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            triu &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            triu(k) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the upper triangular portion of a matrix. This is analogous to the
<code>triu</code> method in MATLAB.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>k</code> -&gt; Positive integer. How many extra diagonals to include
in the upper triangular portion.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="upper_triangle-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 615</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">upper_triangle</span>(<span class="ruby-identifier">k</span> = <span class="ruby-value">0</span>)
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">NotImplementedError</span>, <span class="ruby-string">&quot;only implemented for 2D matrices&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">2</span>

  <span class="ruby-identifier">t</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">clone_structure</span>
  (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">k</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">0</span>
      <span class="ruby-identifier">t</span>[<span class="ruby-identifier">i</span>, <span class="ruby-value">:*</span>] = <span class="ruby-keyword">self</span>[<span class="ruby-identifier">i</span>, <span class="ruby-value">:*</span>]
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">t</span>[<span class="ruby-identifier">i</span>, <span class="ruby-value">0</span><span class="ruby-operator">...</span>(<span class="ruby-identifier">i</span><span class="ruby-operator">-</span><span class="ruby-identifier">k</span>)]             = <span class="ruby-value">0</span>
      <span class="ruby-identifier">t</span>[<span class="ruby-identifier">i</span>, (<span class="ruby-identifier">i</span><span class="ruby-operator">-</span><span class="ruby-identifier">k</span>)<span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>]] = <span class="ruby-keyword">self</span>[<span class="ruby-identifier">i</span>, (<span class="ruby-identifier">i</span><span class="ruby-operator">-</span><span class="ruby-identifier">k</span>)<span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>]]
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">t</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-triu">triu</a>
        </div>
        

        
      </div>

    
      <div id="method-i-upper_triangle-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            upper_triangle! &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            upper_triangle!(k) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            triu! &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            triu!(k) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Deletes the lower triangular portion of the matrix (in-place) so only the
upper portion remains.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>k</code> -&gt; Integer. How many extra diagonals to include in the
deletion.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="upper_triangle-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 644</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">upper_triangle!</span>(<span class="ruby-identifier">k</span> = <span class="ruby-value">0</span>)
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">NotImplementedError</span>, <span class="ruby-string">&quot;only implemented for 2D matrices&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">2</span>

  (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">k</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>
      <span class="ruby-keyword">self</span>[<span class="ruby-identifier">i</span>, <span class="ruby-value">0</span><span class="ruby-operator">...</span>(<span class="ruby-identifier">i</span><span class="ruby-operator">-</span><span class="ruby-identifier">k</span>)] = <span class="ruby-value">0</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-triu-21">triu!</a>
        </div>
        

        
      </div>

    
      <div id="method-i-variance" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            variance() &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            variance(dimen) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calculates the sample variance along the specified dimension.</p>

<p>This will force integer types to float64 dtype.</p>

<p>@see <a href="NMatrix.html#method-i-inject_rank">inject_rank</a></p>
          
          

          
          <div class="method-source-code" id="variance-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 449</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">variance</span>(<span class="ruby-identifier">dimen</span>=<span class="ruby-value">0</span>)
  <span class="ruby-identifier">reduce_dtype</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">integer_dtype?</span> <span class="ruby-keyword">then</span>
    <span class="ruby-identifier">reduce_dtype</span> = <span class="ruby-value">:float64</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">m</span> = <span class="ruby-identifier">mean</span>(<span class="ruby-identifier">dimen</span>)
  <span class="ruby-identifier">inject_rank</span>(<span class="ruby-identifier">dimen</span>, <span class="ruby-value">0.0</span>, <span class="ruby-identifier">reduce_dtype</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">var</span>, <span class="ruby-identifier">sub_mat</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">var</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">m</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">sub_mat</span>)<span class="ruby-operator">*</span>(<span class="ruby-identifier">m</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">sub_mat</span>)<span class="ruby-operator">/</span>(<span class="ruby-identifier">shape</span>[<span class="ruby-identifier">dimen</span>]<span class="ruby-operator">-</span><span class="ruby-value">1</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-vconcat" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">vconcat</span><span
            class="method-args">(*matrices)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Vertical concatenation with <code>matrices</code>.</p>
          
          

          
          <div class="method-source-code" id="vconcat-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 592</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">vconcat</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">matrices</span>)
  <span class="ruby-identifier">concat</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">matrices</span>, <span class="ruby-value">:row</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-vector-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            vector? &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Shortcut function for determining whether the effective dimension is 1. See
also <a href="NMatrix.html#method-i-nvector-3F">nvector?</a></p>
          
          

          
          <div class="method-source-code" id="vector-3F-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 308</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">vector?</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">effective_dim</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-write" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">write</span><span
            class="method-args">(*args)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Binary file writer for <a href="NMatrix.html">NMatrix</a> standard format.
file should be a path, which we aren&#39;t going to check very carefully
(in other words, this function should generally be called from a Ruby
helper method). Function also takes a symmetry argument, which allows us to
specify that we only want to save the upper triangular portion of the
matrix (or if the matrix is a lower triangular matrix, only the lower
triangular portion). nil means regular storage.</p>
          
          

          
          <div class="method-source-code" id="write-source">
            <pre>static VALUE nm_write(int argc, VALUE* argv, VALUE self) {
  using std::ofstream;

  if (argc &lt; 1 || argc &gt; 2) {
    rb_raise(rb_eArgError, &quot;Expected one or two arguments&quot;);
  }

  NM_CONSERVATIVE(nm_register_values(argv, argc));
  NM_CONSERVATIVE(nm_register_value(self));

  VALUE file = argv[0],
        symm = argc == 1 ? Qnil : argv[1];

  NMATRIX* nmatrix;
  UnwrapNMatrix( self, nmatrix );

  nm::symm_t symm_ = interpret_symm(symm);

  if (nmatrix-&gt;storage-&gt;dtype == nm::RUBYOBJ) {
    NM_CONSERVATIVE(nm_unregister_values(argv, argc));
    NM_CONSERVATIVE(nm_unregister_value(self));
    rb_raise(rb_eNotImpError, &quot;Ruby Object writing is not implemented yet&quot;);
  }

  // Get the dtype, stype, itype, and symm and ensure they&#39;re the correct number of bytes.
  uint8_t st = static_cast&lt;uint8_t&gt;(nmatrix-&gt;stype),
          dt = static_cast&lt;uint8_t&gt;(nmatrix-&gt;storage-&gt;dtype),
          sm = static_cast&lt;uint8_t&gt;(symm_);
  uint16_t dim = nmatrix-&gt;storage-&gt;dim;

  //FIXME: Cast the matrix to the smallest possible index type. Write that in the place of IType.

  // Check arguments before starting to write.
  if (nmatrix-&gt;stype == nm::LIST_STORE) {
    NM_CONSERVATIVE(nm_unregister_values(argv, argc));
    NM_CONSERVATIVE(nm_unregister_value(self));
    rb_raise(nm_eStorageTypeError, &quot;cannot save list matrix; cast to yale or dense first&quot;);
  }
  if (symm_ != nm::NONSYMM) {
    NM_CONSERVATIVE(nm_unregister_values(argv, argc));
    NM_CONSERVATIVE(nm_unregister_value(self));

    if (dim != 2) rb_raise(rb_eArgError, &quot;symmetry/triangularity not defined for a non-2D matrix&quot;);
    if (nmatrix-&gt;storage-&gt;shape[0] != nmatrix-&gt;storage-&gt;shape[1])
      rb_raise(rb_eArgError, &quot;symmetry/triangularity not defined for a non-square matrix&quot;);
    if (symm_ == nm::HERM &amp;&amp;
          dt != static_cast&lt;uint8_t&gt;(nm::COMPLEX64) &amp;&amp; dt != static_cast&lt;uint8_t&gt;(nm::COMPLEX128) &amp;&amp; dt != static_cast&lt;uint8_t&gt;(nm::RUBYOBJ))
      rb_raise(rb_eArgError, &quot;cannot save a non-complex matrix as hermitian&quot;);
  }

  ofstream f(RSTRING_PTR(file), std::ios::out | std::ios::binary);

  // Get the NMatrix version information.
  uint16_t major, minor, release, null16 = 0;
  get_version_info(major, minor, release);

  // WRITE FIRST 64-BIT BLOCK
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;major),   sizeof(uint16_t));
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;minor),   sizeof(uint16_t));
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;release), sizeof(uint16_t));
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;null16),  sizeof(uint16_t));

  uint8_t ZERO = 0;
  // WRITE SECOND 64-BIT BLOCK
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;dt), sizeof(uint8_t));
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;st), sizeof(uint8_t));
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;ZERO),sizeof(uint8_t));
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;sm), sizeof(uint8_t));
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;null16), sizeof(uint16_t));
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;dim), sizeof(uint16_t));

  // Write shape (in 64-bit blocks)
  write_padded_shape(f, nmatrix-&gt;storage-&gt;dim, nmatrix-&gt;storage-&gt;shape);

  if (nmatrix-&gt;stype == nm::DENSE_STORE) {
    write_padded_dense_elements(f, reinterpret_cast&lt;DENSE_STORAGE*&gt;(nmatrix-&gt;storage), symm_, nmatrix-&gt;storage-&gt;dtype);
  } else if (nmatrix-&gt;stype == nm::YALE_STORE) {
    YALE_STORAGE* s = reinterpret_cast&lt;YALE_STORAGE*&gt;(nmatrix-&gt;storage);
    uint32_t ndnz   = s-&gt;ndnz,
             length = nm_yale_storage_get_size(s);
    f.write(reinterpret_cast&lt;const char*&gt;(&amp;ndnz),   sizeof(uint32_t));
    f.write(reinterpret_cast&lt;const char*&gt;(&amp;length), sizeof(uint32_t));

    write_padded_yale_elements(f, s, length, symm_, s-&gt;dtype);
  }

  f.close();

  NM_CONSERVATIVE(nm_unregister_values(argv, argc));
  NM_CONSERVATIVE(nm_unregister_value(self));

  return Qtrue;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-yale-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            yale? &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Determine if <code>m</code> is a Yale matrix.</p>
          
          

          
          <div class="method-source-code" id="yale-3F-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">yale?</span>;  <span class="ruby-keyword">return</span> <span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:yale</span>; <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-zeros" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            zeros(shape) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            zeros(shape, dtype: dtype) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            zeros(shape, dtype: dtype, stype: stype) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a new matrix of zeros with the dimensions supplied as parameters.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>shape</code> -&gt; <a href="Array.html">Array</a> (or integer for
square matrix) specifying the dimensions.</p>
</li><li>
<p><code>dtype</code> -&gt; (optional) Default is <code>:float64</code></p>
</li><li>
<p><code>stype</code> -&gt; (optional) Default is <code>:dense</code>.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p><a href="NMatrix.html">NMatrix</a> filled with zeros.</p>
</li></ul>
</li></ul>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">zeros</span>(<span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt;  0.0   0.0</span>
                       <span class="ruby-value">0.0</span>   <span class="ruby-value">0.0</span>

<span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">zeros</span>([<span class="ruby-value">2</span>, <span class="ruby-value">3</span>], <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">int32</span>) <span class="ruby-comment"># =&gt;  0  0  0</span>
                                           <span class="ruby-value">0</span>  <span class="ruby-value">0</span>  <span class="ruby-value">0</span>

<span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">zeros</span>([<span class="ruby-value">1</span>, <span class="ruby-value">5</span>], <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">int32</span>) <span class="ruby-comment"># =&gt;  0  0  0  0  0</span>
</pre>
          
          

          
          <div class="method-source-code" id="zeros-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">zeros</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">opts</span> = {})
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-value">0</span>, {<span class="ruby-value">:dtype</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">:float64</span>}.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>))
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-zeros_like" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            zeros_like(nm) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a new matrix of zeros with the same stype, dtype, and shape as the
provided matrix.</p>

<p>@param [NMatrix] nm the nmatrix whose stype, dtype, and shape will be used
@return [NMatrix] a new nmatrix filled with zeros.</p>
          
          

          
          <div class="method-source-code" id="zeros_like-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 198</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">zeros_like</span>(<span class="ruby-identifier">nm</span>)
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">zeros</span>(<span class="ruby-identifier">nm</span>.<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-identifier">nm</span>.<span class="ruby-identifier">dtype</span>, <span class="ruby-identifier">stype</span><span class="ruby-operator">:</span> <span class="ruby-identifier">nm</span>.<span class="ruby-identifier">stype</span>, <span class="ruby-identifier">capacity</span><span class="ruby-operator">:</span> <span class="ruby-identifier">nm</span>.<span class="ruby-identifier">capacity</span>, <span class="ruby-identifier">default</span><span class="ruby-operator">:</span> <span class="ruby-value">0</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
     <section id="protected-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Protected Instance Methods</h3>
       </header>

    
      <div id="method-i-dtype_for_floor_or_ceil" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">dtype_for_floor_or_ceil</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>These are for calculating the floor or ceil of matrix</p>
          
          

          
          <div class="method-source-code" id="dtype_for_floor_or_ceil-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 614</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">dtype_for_floor_or_ceil</span>
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">integer_dtype?</span> <span class="ruby-keyword">or</span> [<span class="ruby-value">:complex64</span>, <span class="ruby-value">:complex128</span>, <span class="ruby-value">:object</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>)
    <span class="ruby-identifier">return_dtype</span> = <span class="ruby-identifier">dtype</span>
  <span class="ruby-keyword">elsif</span> [<span class="ruby-value">:float32</span>, <span class="ruby-value">:float64</span>, <span class="ruby-value">:rational32</span>,<span class="ruby-value">:rational64</span>, <span class="ruby-value">:rational128</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>)
    <span class="ruby-identifier">return_dtype</span> = <span class="ruby-value">:int64</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">return_dtype</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://rdoc.rubyforge.org">RDoc</a> 4.1.1.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

