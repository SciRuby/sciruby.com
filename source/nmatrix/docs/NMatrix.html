<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">

<title>class NMatrix - RDoc Documentation</title>

<link type="text/css" media="screen" href="./rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
</script>

<script type="text/javascript" charset="utf-8" src="./js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/navigation.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/search_index.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/search.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/searcher.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/darkfish.js"></script>


<body id="top" class="class">
<nav id="metadata">
  <nav id="home-section" class="section">
  <h3 class="section-header">
    <a href="./index.html">Home</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </h3>
</nav>


  <nav id="search-section" class="section project-section" class="initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <h3 class="section-header">
      <input type="text" name="search" placeholder="Search" id="search-field"
             title="Type to search, Up and Down to navigate, Enter to load">
    </h3>
  </form>

  <ul id="search-results" class="initially-hidden"></ul>
</nav>


  

  <div id="file-metadata">
    <nav id="file-list-section" class="section">
  <h3 class="section-header">Defined In</h3>
  <ul>
    <li>ext/nmatrix/nmatrix.cpp
    <li>lib/nmatrix/blas.rb
    <li>lib/nmatrix/io/market.rb
    <li>lib/nmatrix/io/mat5_reader.rb
    <li>lib/nmatrix/io/mat_reader.rb
    <li>lib/nmatrix/lapack.rb
    <li>lib/nmatrix/nmatrix.rb
    <li>lib/nmatrix/shortcuts.rb
    <li>lib/nmatrix/version.rb
  </ul>
</nav>

    
  </div>

  <div id="class-metadata">
    
    <nav id="parent-class-section" class="section">
  <h3 class="section-header">Parent</h3>
  
  <p class="link"><a href="Object.html">Object</a>
  
</nav>

    
    
    <!-- Method Quickref -->
<nav id="method-list-section" class="section">
  <h3 class="section-header">Methods</h3>

  <ul class="link-list">
    
    <li ><a href="#method-c-bindgen">::bindgen</a>
    
    <li ><a href="#method-c-cindgen">::cindgen</a>
    
    <li ><a href="#method-c-eye">::eye</a>
    
    <li ><a href="#method-c-findgen">::findgen</a>
    
    <li ><a href="#method-c-identity">::identity</a>
    
    <li ><a href="#method-c-indgen">::indgen</a>
    
    <li ><a href="#method-c-itype_by_shape">::itype_by_shape</a>
    
    <li ><a href="#method-c-load_file">::load_file</a>
    
    <li ><a href="#method-c-new">::new</a>
    
    <li ><a href="#method-c-ones">::ones</a>
    
    <li ><a href="#method-c-random">::random</a>
    
    <li ><a href="#method-c-read">::read</a>
    
    <li ><a href="#method-c-seq">::seq</a>
    
    <li ><a href="#method-c-upcast">::upcast</a>
    
    <li ><a href="#method-c-zeroes">::zeroes</a>
    
    <li ><a href="#method-c-zeros">::zeros</a>
    
    <li ><a href="#method-i-3D-3D">#==</a>
    
    <li ><a href="#method-i-5B-5D">#[]</a>
    
    <li ><a href="#method-i-5B-5D-3D">#[]=</a>
    
    <li ><a href="#method-i-capacity">#capacity</a>
    
    <li ><a href="#method-i-cast">#cast</a>
    
    <li ><a href="#method-i-cols">#cols</a>
    
    <li ><a href="#method-i-column">#column</a>
    
    <li ><a href="#method-i-complex_conjugate">#complex_conjugate</a>
    
    <li ><a href="#method-i-complex_conjugate-21">#complex_conjugate!</a>
    
    <li ><a href="#method-i-conjugate_transpose">#conjugate_transpose</a>
    
    <li ><a href="#method-i-det">#det</a>
    
    <li ><a href="#method-i-det_exact">#det_exact</a>
    
    <li ><a href="#method-i-dim">#dim</a>
    
    <li ><a href="#method-i-dimensions">#dimensions</a>
    
    <li ><a href="#method-i-dot">#dot</a>
    
    <li ><a href="#method-i-dtype">#dtype</a>
    
    <li ><a href="#method-i-each">#each</a>
    
    <li ><a href="#method-i-each_stored_with_indices">#each_stored_with_indices</a>
    
    <li ><a href="#method-i-factorize_lu">#factorize_lu</a>
    
    <li ><a href="#method-i-getrf-21">#getrf!</a>
    
    <li ><a href="#method-i-hermitian-3F">#hermitian?</a>
    
    <li ><a href="#method-i-initialize_copy">#initialize_copy</a>
    
    <li ><a href="#method-i-inverse">#inverse</a>
    
    <li ><a href="#method-i-invert">#invert</a>
    
    <li ><a href="#method-i-invert-21">#invert!</a>
    
    <li ><a href="#method-i-is_ref-3F">#is_ref?</a>
    
    <li ><a href="#method-i-itype">#itype</a>
    
    <li ><a href="#method-i-rows">#rows</a>
    
    <li ><a href="#method-i-shape">#shape</a>
    
    <li ><a href="#method-i-slice">#slice</a>
    
    <li ><a href="#method-i-stype">#stype</a>
    
    <li ><a href="#method-i-symmetric-3F">#symmetric?</a>
    
    <li ><a href="#method-i-to_h">#to_h</a>
    
    <li ><a href="#method-i-to_hash">#to_hash</a>
    
    <li ><a href="#method-i-transpose">#transpose</a>
    
    <li ><a href="#method-i-write">#write</a>
    
  </ul>
</nav>

  </div>

  <div id="project-metadata">
    <nav id="fileindex-section" class="section project-section">
  <h3 class="section-header">Pages</h3>

  <ul>
  
    <li class="file"><a href="./History_txt.html">History</a>
  
    <li class="file"><a href="./README_rdoc.html">README</a>
  
    <li class="file"><a href="./ext/nmatrix/binary_format_txt.html">binary_format</a>
  
  </ul>
</nav>

    <nav id="classindex-section" class="section project-section">
  <h3 class="section-header">Class and Module Index</h3>

  <ul class="link-list">
  
    <li><a href="./Array.html">Array</a>
  
    <li><a href="./DataTypeError.html">DataTypeError</a>
  
    <li><a href="./N.html">N</a>
  
    <li><a href="./NMatrix.html">NMatrix</a>
  
    <li><a href="./NMatrix/BLAS.html">NMatrix::BLAS</a>
  
    <li><a href="./NMatrix/IO.html">NMatrix::IO</a>
  
    <li><a href="./NMatrix/IO/Market.html">NMatrix::IO::Market</a>
  
    <li><a href="./NMatrix/IO/Matlab.html">NMatrix::IO::Matlab</a>
  
    <li><a href="./NMatrix/IO/Matlab/Mat5Reader.html">NMatrix::IO::Matlab::Mat5Reader</a>
  
    <li><a href="./NMatrix/IO/Matlab/Mat5Reader/Compressed.html">NMatrix::IO::Matlab::Mat5Reader::Compressed</a>
  
    <li><a href="./NMatrix/IO/Matlab/Mat5Reader/Element.html">NMatrix::IO::Matlab::Mat5Reader::Element</a>
  
    <li><a href="./NMatrix/IO/Matlab/Mat5Reader/ElementDataIOError.html">NMatrix::IO::Matlab::Mat5Reader::ElementDataIOError</a>
  
    <li><a href="./NMatrix/IO/Matlab/Mat5Reader/Header.html">NMatrix::IO::Matlab::Mat5Reader::Header</a>
  
    <li><a href="./NMatrix/IO/Matlab/Mat5Reader/MatrixData.html">NMatrix::IO::Matlab::Mat5Reader::MatrixData</a>
  
    <li><a href="./NMatrix/IO/Matlab/Mat5Reader/RawElement.html">NMatrix::IO::Matlab::Mat5Reader::RawElement</a>
  
    <li><a href="./NMatrix/IO/Matlab/Mat5Reader/Tag.html">NMatrix::IO::Matlab::Mat5Reader::Tag</a>
  
    <li><a href="./NMatrix/IO/Matlab/MatReader.html">NMatrix::IO::Matlab::MatReader</a>
  
    <li><a href="./NMatrix/LAPACK.html">NMatrix::LAPACK</a>
  
    <li><a href="./NMatrix/YaleFunctions.html">NMatrix::YaleFunctions</a>
  
    <li><a href="./NVector.html">NVector</a>
  
    <li><a href="./Object.html">Object</a>
  
    <li><a href="./StorageTypeError.html">StorageTypeError</a>
  
  </ul>
</nav>

  </div>
</nav>

<div id="documentation">
  <h1 class="class">class NMatrix</h1>

  <div id="description" class="description">
    
  </div><!-- description -->

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    
    <!-- Constants -->
    <section id="constants-list" class="section">
      <h3 class="section-header">Constants</h3>
      <dl>
      
        <dt id="VERSION">VERSION
        
        <dd class="description">
        
      
      </dl>
    </section>
    

    

    <!-- Methods -->
    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Public Class Methods</h3>

    
      <div id="method-c-bindgen" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            bindgen(size) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a byte <a href="NMatrix.html">NMatrix</a>. Equivalent to
<code>seq(n, :byte)</code>.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>size</code> -&gt; Size of the sequence.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p><a href="NMatrix.html">NMatrix</a> with dtype <code>:byte</code>.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="bindgen-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 264</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">bindgen</span>(<span class="ruby-identifier">size</span>)
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">seq</span>(<span class="ruby-identifier">size</span>, <span class="ruby-value">:byte</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- bindgen-source -->
          
        </div>

        

        
      </div><!-- bindgen-method -->

    
      <div id="method-c-cindgen" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            cindgen(size) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an complex <a href="NMatrix.html">NMatrix</a>. Equivalent to
<code>seq(n, :complex64)</code>.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>size</code> -&gt; Size of the sequence.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p><a href="NMatrix.html">NMatrix</a> with dtype <code>:complex64</code>.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="cindgen-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 279</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">cindgen</span>(<span class="ruby-identifier">size</span>)
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">seq</span>(<span class="ruby-identifier">size</span>, <span class="ruby-value">:complex64</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- cindgen-source -->
          
        </div>

        

        
      </div><!-- cindgen-method -->

    
      <div id="method-c-eye" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            eye(size) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            eye(size, dtype) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            eye(stype, size, dtype) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates an identity matrix (square matrix rank 2).</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>stype</code> -&gt; (optional) Default is <code>:dense</code>.</p>
</li><li>
<p><code>size</code> -&gt; <a href="Array.html">Array</a> (or integer for
square matrix) specifying the dimensions.</p>
</li><li>
<p><code>dtype</code> -&gt; (optional) Default is <code>:float64</code></p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p><a href="NMatrix.html">NMatrix</a> filled with zeros.</p>
</li></ul>
</li></ul>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">eye</span>(<span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt;   1.0   0.0   0.0</span>
                      <span class="ruby-value">0.0</span>   <span class="ruby-value">1.0</span>   <span class="ruby-value">0.0</span>
                      <span class="ruby-value">0.0</span>   <span class="ruby-value">0.0</span>   <span class="ruby-value">1.0</span>

<span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">eye</span>(<span class="ruby-value">3</span>, :<span class="ruby-identifier">int32</span>) <span class="ruby-comment"># =&gt;   1   0   0</span>
                              <span class="ruby-value">0</span>   <span class="ruby-value">1</span>   <span class="ruby-value">0</span>
                              <span class="ruby-value">0</span>   <span class="ruby-value">0</span>   <span class="ruby-value">1</span>

<span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">eye</span>(:<span class="ruby-identifier">yale</span>, <span class="ruby-value">2</span>, :<span class="ruby-identifier">int32</span>) <span class="ruby-comment"># =&gt;   1   0</span>
                                     <span class="ruby-value">0</span>   <span class="ruby-value">1</span>
</pre>
          
          

          
          <div class="method-source-code" id="eye-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 128</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">eye</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">params</span>)
  <span class="ruby-identifier">dtype</span> = <span class="ruby-identifier">params</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Symbol</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">params</span>.<span class="ruby-identifier">pop</span> <span class="ruby-operator">:</span> <span class="ruby-value">:float64</span>
  <span class="ruby-identifier">stype</span> = <span class="ruby-identifier">params</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Symbol</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">params</span>.<span class="ruby-identifier">shift</span> <span class="ruby-operator">:</span> <span class="ruby-value">:dense</span>

  <span class="ruby-identifier">dim</span> = <span class="ruby-identifier">params</span>.<span class="ruby-identifier">first</span>
  
  <span class="ruby-comment"># Fill the diagonal with 1's.</span>
  <span class="ruby-identifier">m</span> = <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">zeros</span>(<span class="ruby-identifier">stype</span>, <span class="ruby-identifier">dim</span>, <span class="ruby-identifier">dtype</span>)
  (<span class="ruby-value">0</span> <span class="ruby-operator">..</span> (<span class="ruby-identifier">dim</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>)).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> 
    <span class="ruby-identifier">m</span>[<span class="ruby-identifier">i</span>, <span class="ruby-identifier">i</span>] = <span class="ruby-value">1</span>
  <span class="ruby-keyword">end</span>
  
  <span class="ruby-identifier">m</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- eye-source -->
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-c-identity">identity</a>
        </div>
        

        
      </div><!-- eye-method -->

    
      <div id="method-c-findgen" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            findgen(size) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a float <a href="NMatrix.html">NMatrix</a>. Equivalent to
<code>seq(n, :float32)</code>.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>size</code> -&gt; Size of the sequence.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p><a href="NMatrix.html">NMatrix</a> with dtype <code>:float32</code>.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="findgen-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 249</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">findgen</span>(<span class="ruby-identifier">size</span>)
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">seq</span>(<span class="ruby-identifier">size</span>, <span class="ruby-value">:float32</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- findgen-source -->
          
        </div>

        

        
      </div><!-- findgen-method -->

    
      <div id="method-c-identity" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">identity</span><span
            class="method-args">(*params)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-c-eye">eye</a>
        </div>
        
      </div><!-- identity-method -->

    
      <div id="method-c-indgen" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            indgen(size) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an integer <a href="NMatrix.html">NMatrix</a>. Equivalent to
<code>seq(n, :int32)</code>.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>size</code> -&gt; Size of the sequence.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p><a href="NMatrix.html">NMatrix</a> with dtype <code>:int32</code>.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="indgen-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 234</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">indgen</span>(<span class="ruby-identifier">size</span>)
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">seq</span>(<span class="ruby-identifier">size</span>, <span class="ruby-value">:int32</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- indgen-source -->
          
        </div>

        

        
      </div><!-- indgen-method -->

    
      <div id="method-c-itype_by_shape" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">itype_by_shape</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Get the index data type (dtype) of a matrix. Defined only for yale; others
return nil.</p>
          
          

          
          <div class="method-source-code" id="itype_by_shape-source">
            <pre>static VALUE nm_itype_by_shape(VALUE self, VALUE shape_arg) {

  size_t dim;
  size_t* shape = interpret_shape(shape_arg, &amp;dim);

  nm::itype_t itype = nm_yale_storage_itype_by_shape(shape);
  ID itype_id       = rb_intern(ITYPE_NAMES[itype]);

  return ID2SYM(itype_id);
}</pre>
          </div><!-- itype_by_shape-source -->
          
        </div>

        

        
      </div><!-- itype_by_shape-method -->

    
      <div id="method-c-load_file" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            load_file(path) &rarr; Mat5Reader
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>path</code> -&gt; The path to a version 5 .mat file.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>A Mat5Reader object.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="load_file-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 281</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">load_file</span>(<span class="ruby-identifier">file_path</span>)
        <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">IO</span><span class="ruby-operator">::</span><span class="ruby-constant">Mat5Reader</span>.<span class="ruby-identifier">new</span>(<span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-identifier">file_path</span>, <span class="ruby-string">'rb'</span>)).<span class="ruby-identifier">to_ruby</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- load_file-source -->
          
        </div>

        

        
      </div><!-- load_file-method -->

    
      <div id="method-c-new" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            new &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Create a new <a href="NMatrix.html">NMatrix</a>.</p>

<p>There are several ways to do this. At a minimum, dimensions and either a
dtype or initial values are needed, e.g.,</p>

<pre>NMatrix.new(3, :int64)       # square 3x3 dense matrix
NMatrix.new([3,4], :float32) # 3x4 matrix
NMatrix.new(3, 0)            # 3x3 dense matrix initialized to all zeros
NMatrix.new([3,3], [1,2,3])  # [[1,2,3],[1,2,3],[1,2,3]]</pre>

<p><a href="NMatrix.html">NMatrix</a> will try to guess the dtype from the
first value in the initial values array.</p>

<p>You can also provide the stype prior to the dimensions. However, non-dense
matrices cannot take initial values, and require a dtype (e.g., :int64):</p>

<pre>NMatrix.new(:yale, [4,3], :int64)
NMatrix.new(:list, 5, :rational128)</pre>

<p>For Yale, you can also give an initial size for the non-diagonal component
of the matrix:</p>

<pre>NMatrix.new(:yale, [4,3], 2, :int64)</pre>

<p>Finally, you can be extremely specific, and define a matrix very exactly:</p>

<pre>NMatrix.new(:dense, [2,2,2], [0,1,2,3,4,5,6,7], :int8)</pre>

<p>There is one additional constructor for advanced users, which takes seven
arguments and is only for creating Yale matrices with known IA, JA, and A
arrays. This is used primarily internally for <a
href="NMatrix/IO.html">IO</a>, e.g., reading Matlab matrices, which are
stored in old Yale format.</p>

<p>Just be careful! There are no overflow warnings in <a
href="NMatrix.html">NMatrix</a>.</p>
          
          

          
          <div class="method-source-code" id="new-source">
            <pre>static VALUE nm_init(int argc, VALUE* argv, VALUE nm) {

  if (argc &lt; 2) {
        rb_raise(rb_eArgError, &quot;Expected 2-4 arguments (or 7 for internal Yale creation)&quot;);
        return Qnil;
  }

  /* First, determine stype (dense by default) */
  nm::stype_t stype;
  size_t  offset = 0;

  if (!SYMBOL_P(argv[0]) &amp;&amp; TYPE(argv[0]) != T_STRING) {
    stype = nm::DENSE_STORE;
    
  } else {
        // 0: String or Symbol
    stype  = interpret_stype(argv[0]);
    offset = 1;
  }

  // If there are 7 arguments and Yale, refer to a different init function with fewer sanity checks.
  if (argc == 7) {
        if (stype == nm::YALE_STORE) {
                        return nm_init_yale_from_old_yale(argv[1], argv[2], argv[3], argv[4], argv[5], argv[6], nm);
                        
                } else {
                        rb_raise(rb_eArgError, &quot;Expected 2-4 arguments (or 7 for internal Yale creation)&quot;);
                }
  }
        
        // 1: Array or Fixnum
        size_t dim;
  size_t* shape = interpret_shape(argv[offset], &amp;dim);

  // 2-3: dtype
  nm::dtype_t dtype = interpret_dtype(argc-1-offset, argv+offset+1, stype);

  size_t init_cap = 0, init_val_len = 0;
  void* init_val  = NULL;
  if (NM_RUBYVAL_IS_NUMERIC(argv[1+offset]) || TYPE(argv[1+offset]) == T_ARRAY) {
        // Initial value provided (could also be initial capacity, if yale).
        
    if (stype == nm::YALE_STORE) {
      init_cap = FIX2UINT(argv[1+offset]);
      
    } else {
        // 4: initial value / dtype
      init_val = interpret_initial_value(argv[1+offset], dtype);
      
      if (TYPE(argv[1+offset]) == T_ARRAY)      init_val_len = RARRAY_LEN(argv[1+offset]);
      else                                  init_val_len = 1;
    }
    
  } else {
        // DType is RUBYOBJ.
        
    if (stype == nm::DENSE_STORE) {
        /*
         * No need to initialize dense with any kind of default value unless it's
         * an RUBYOBJ matrix.
         */
      if (dtype == nm::RUBYOBJ) {
        // Pretend [nil] was passed for RUBYOBJ.
        init_val = ALLOC(VALUE);
        *(VALUE*)init_val = Qnil;
        
        init_val_len = 1;
        
      } else {
        init_val = NULL;
      }
    } else if (stype == nm::LIST_STORE) {
        init_val = ALLOC_N(char, DTYPE_SIZES[dtype]);
      std::memset(init_val, 0, DTYPE_SIZES[dtype]);
    }
  }
        
  // TODO: Update to allow an array as the initial value.
        NMATRIX* nmatrix;
  UnwrapNMatrix(nm, nmatrix);

  nmatrix-&gt;stype = stype;
  
  switch (stype) {
        case nm::DENSE_STORE:
                nmatrix-&gt;storage = (STORAGE*)nm_dense_storage_create(dtype, shape, dim, init_val, init_val_len);
                break;
                
        case nm::LIST_STORE:
                nmatrix-&gt;storage = (STORAGE*)nm_list_storage_create(dtype, shape, dim, init_val);
                break;
                
        case nm::YALE_STORE:
                nmatrix-&gt;storage = (STORAGE*)nm_yale_storage_create(dtype, shape, dim, init_cap);
                nm_yale_storage_init((YALE_STORAGE*)(nmatrix-&gt;storage));
                break;
  }

  return nm;
}</pre>
          </div><!-- new-source -->
          
        </div>

        

        
      </div><!-- new-method -->

    
      <div id="method-c-ones" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            ones(size) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            ones(size, dtype) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a matrix filled with ones.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>size</code> -&gt; <a href="Array.html">Array</a> (or integer for
square matrix) specifying the dimensions.</p>
</li><li>
<p><code>dtype</code> -&gt; (optional) Default is <code>:float64</code></p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p><a href="NMatrix.html">NMatrix</a> filled with ones.</p>
</li></ul>
</li></ul>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">ones</span>([<span class="ruby-value">1</span>, <span class="ruby-value">3</span>]) <span class="ruby-comment"># =&gt;  1.0   1.0   1.0</span>

<span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">ones</span>([<span class="ruby-value">2</span>, <span class="ruby-value">3</span>], :<span class="ruby-identifier">int32</span>) <span class="ruby-comment"># =&gt;  1  1  1</span>
                                   <span class="ruby-value">1</span>  <span class="ruby-value">1</span>  <span class="ruby-value">1</span>
</pre>
          
          

          
          <div class="method-source-code" id="ones-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 93</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">ones</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">params</span>)
  <span class="ruby-identifier">dtype</span> = <span class="ruby-identifier">params</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Symbol</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">params</span>.<span class="ruby-identifier">pop</span> <span class="ruby-operator">:</span> <span class="ruby-value">:float64</span>
  <span class="ruby-identifier">dim</span> = <span class="ruby-identifier">params</span>.<span class="ruby-identifier">first</span>

  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">dim</span>, <span class="ruby-value">1</span>, <span class="ruby-identifier">dtype</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- ones-source -->
          
        </div>

        

        
      </div><!-- ones-method -->

    
      <div id="method-c-random" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            random(size) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a <code>:dense</code> <a href="NMatrix.html">NMatrix</a> with
random numbers between 0 and 1 generated by +Random::rand+. The parameter
is the dimension of the matrix.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>size</code> -&gt; <a href="Array.html">Array</a> (or integer for
square matrix) specifying the dimensions.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p><a href="NMatrix.html">NMatrix</a> filled with zeros.</p>
</li></ul>
</li></ul>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">random</span>([<span class="ruby-value">2</span>, <span class="ruby-value">2</span>]) <span class="ruby-comment"># =&gt; 0.4859439730644226   0.1783195585012436</span>
                            <span class="ruby-value">0.23193766176700592</span>  <span class="ruby-value">0.4503345191478729</span>
</pre>
          
          

          
          <div class="method-source-code" id="random-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 161</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">random</span>(<span class="ruby-identifier">size</span>)
  <span class="ruby-identifier">rng</span> = <span class="ruby-constant">Random</span>.<span class="ruby-identifier">new</span>

  <span class="ruby-identifier">random_values</span> = []
  
  <span class="ruby-comment"># Construct the values of the final matrix based on the dimension.</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">size</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Integer</span>)
    (<span class="ruby-identifier">size</span> <span class="ruby-operator">*</span> <span class="ruby-identifier">size</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>).<span class="ruby-identifier">times</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">random_values</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">rng</span>.<span class="ruby-identifier">rand</span> }
  <span class="ruby-keyword">else</span>
    <span class="ruby-comment"># Dimensions given by an array. Get the product of the array elements</span>
    <span class="ruby-comment"># and generate this number of random values.</span>
    <span class="ruby-identifier">size</span>.<span class="ruby-identifier">reduce</span>(<span class="ruby-value">1</span>, <span class="ruby-value">:*</span>).<span class="ruby-identifier">times</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">random_values</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">rng</span>.<span class="ruby-identifier">rand</span> }
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">:dense</span>, <span class="ruby-identifier">size</span>, <span class="ruby-identifier">random_values</span>, <span class="ruby-value">:float64</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- random-source -->
          
        </div>

        

        
      </div><!-- random-method -->

    
      <div id="method-c-read" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">read</span><span
            class="method-args">(*args)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Binary file reader for <a href="NMatrix.html">NMatrix</a> standard format.
file should be a path, which we arenâ€™t going to check very carefully (in
other words, this function should generally be called from a Ruby helper
method).</p>

<p>Note that currently, this function will by default refuse to read files
that are newer than your version of <a href="NMatrix.html">NMatrix</a>. To
force an override, set the second argument to anything other than nil.</p>

<p>Returns an <a href="NMatrix.html">NMatrix</a> Ruby object.</p>
          
          

          
          <div class="method-source-code" id="read-source">
            <pre>static VALUE nm_read(int argc, VALUE* argv, VALUE self) {
  using std::ifstream;

  // Read the arguments
  if (argc &lt; 1 || argc &gt; 2) {
    rb_raise(rb_eArgError, &quot;expected one or two arguments&quot;);
  }
  VALUE file   = argv[0];
  bool force   = argc == 1 ? false : argv[1];

  // Open a file stream
  ifstream f(RSTRING_PTR(file), std::ios::in | std::ios::binary);

  uint16_t major, minor, release;
  get_version_info(major, minor, release); // compare to NMatrix version

  uint16_t fmajor, fminor, frelease, null16;

  // READ FIRST 64-BIT BLOCK
  f.read(reinterpret_cast&lt;char*&gt;(&amp;fmajor),   sizeof(uint16_t));
  f.read(reinterpret_cast&lt;char*&gt;(&amp;fminor),   sizeof(uint16_t));
  f.read(reinterpret_cast&lt;char*&gt;(&amp;frelease), sizeof(uint16_t));
  f.read(reinterpret_cast&lt;char*&gt;(&amp;null16),   sizeof(uint16_t));

  int ver  = major * 10000 + minor * 100 + release,
      fver = fmajor * 10000 + fminor * 100 + release;
  if (fver &gt; ver &amp;&amp; force == false) {
    rb_raise(rb_eIOError, &quot;File was created in newer version of NMatrix than current&quot;);
  }
  if (null16 != 0) fprintf(stderr, &quot;Warning: Expected zero padding was not zero\n&quot;);

  uint8_t dt, st, it, sm;
  uint16_t dim;

  // READ SECOND 64-BIT BLOCK
  f.read(reinterpret_cast&lt;char*&gt;(&amp;dt), sizeof(uint8_t));
  f.read(reinterpret_cast&lt;char*&gt;(&amp;st), sizeof(uint8_t));
  f.read(reinterpret_cast&lt;char*&gt;(&amp;it), sizeof(uint8_t));
  f.read(reinterpret_cast&lt;char*&gt;(&amp;sm), sizeof(uint8_t));
  f.read(reinterpret_cast&lt;char*&gt;(&amp;null16), sizeof(uint16_t));
  f.read(reinterpret_cast&lt;char*&gt;(&amp;dim), sizeof(uint16_t));

  if (null16 != 0) fprintf(stderr, &quot;Warning: Expected zero padding was not zero\n&quot;);
  nm::stype_t stype = static_cast&lt;nm::stype_t&gt;(st);
  nm::dtype_t dtype = static_cast&lt;nm::dtype_t&gt;(dt);
  nm::symm_t  symm  = static_cast&lt;nm::symm_t&gt;(sm);
  nm::itype_t itype = static_cast&lt;nm::itype_t&gt;(it);

  // READ NEXT FEW 64-BIT BLOCKS
  size_t* shape = ALLOC_N(size_t, dim);
  read_padded_shape(f, dim, shape, itype);

  VALUE klass = dim == 1 ? cNVector : cNMatrix;

  STORAGE* s;
  if (stype == nm::DENSE_STORE) {
    s = nm_dense_storage_create(dtype, shape, dim, NULL, 0);

    read_padded_dense_elements(f, reinterpret_cast&lt;DENSE_STORAGE*&gt;(s), symm, dtype);

  } else if (stype == nm::YALE_STORE) {
    uint32_t ndnz, length;

    // READ YALE-SPECIFIC 64-BIT BLOCK
    f.read(reinterpret_cast&lt;char*&gt;(&amp;ndnz),     sizeof(uint32_t));
    f.read(reinterpret_cast&lt;char*&gt;(&amp;length),   sizeof(uint32_t));

    s = nm_yale_storage_create(dtype, shape, dim, length); // set length as init capacity

    read_padded_yale_elements(f, reinterpret_cast&lt;YALE_STORAGE*&gt;(s), length, symm, dtype, itype);
  } else {
    rb_raise(nm_eStorageTypeError, &quot;please convert to yale or dense before saving&quot;);
  }

  NMATRIX* nm = nm_create(stype, s);

  // Return the appropriate matrix object (Ruby VALUE)
  switch(stype) {
  case nm::DENSE_STORE:
    return Data_Wrap_Struct(klass, nm_dense_storage_mark, nm_delete, nm);
  case nm::YALE_STORE:
    return Data_Wrap_Struct(cNMatrix, nm_yale_storage_mark, nm_delete, nm);
  default:
    return Qnil;
  }

}</pre>
          </div><!-- read-source -->
          
        </div>

        

        
      </div><!-- read-method -->

    
      <div id="method-c-seq" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            seq(size) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            seq(size, dtype) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a matrix filled with a sequence of integers starting at zero.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>size</code> -&gt; <a href="Array.html">Array</a> (or integer for
square matrix) specifying the dimensions.</p>
</li><li>
<p><code>dtype</code> -&gt; (optional) Default is <code>:float64</code></p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p><a href="NMatrix.html">NMatrix</a> filled with zeros.</p>
</li></ul>
</li></ul>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">seq</span>(<span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt;   0   1</span>
              <span class="ruby-value">2</span>   <span class="ruby-value">3</span>

<span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">seq</span>([<span class="ruby-value">3</span>, <span class="ruby-value">3</span>], :<span class="ruby-identifier">float32</span>) <span class="ruby-comment"># =&gt;  0.0  1.0  2.0</span>
                                    <span class="ruby-value">3.0</span>  <span class="ruby-value">4.0</span>  <span class="ruby-value">5.0</span>
                                    <span class="ruby-value">6.0</span>  <span class="ruby-value">7.0</span>  <span class="ruby-value">8.0</span>
</pre>
          
          

          
          <div class="method-source-code" id="seq-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 200</span>
    <span class="ruby-keyword">def</span> <span class="ruby-identifier">seq</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">params</span>)
      <span class="ruby-identifier">dtype</span> = <span class="ruby-identifier">params</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Symbol</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">params</span>.<span class="ruby-identifier">pop</span> <span class="ruby-operator">:</span> <span class="ruby-keyword">nil</span>
      <span class="ruby-identifier">size</span> = <span class="ruby-identifier">params</span>.<span class="ruby-identifier">first</span>
      
      <span class="ruby-comment"># Must provide the dimension as an Integer for a square matrix or as an</span>
      <span class="ruby-comment"># 2 element array, e.g. [2,4].</span>
      <span class="ruby-keyword">unless</span> <span class="ruby-identifier">size</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Integer</span>) <span class="ruby-operator">||</span> (<span class="ruby-identifier">size</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">size</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">3</span>)
        <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&quot;seq() accepts only integers or 2-element arrays \
as dimension.&quot;</span>
      <span class="ruby-keyword">end</span>
      
      <span class="ruby-comment"># Construct the values of the final matrix based on the dimension.</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">size</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Integer</span>)
        <span class="ruby-identifier">values</span> = (<span class="ruby-value">0</span> <span class="ruby-operator">..</span> (<span class="ruby-identifier">size</span> <span class="ruby-operator">*</span> <span class="ruby-identifier">size</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>)).<span class="ruby-identifier">to_a</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-comment"># Dimensions given by a 2 element array.</span>
        <span class="ruby-identifier">values</span> = (<span class="ruby-value">0</span> <span class="ruby-operator">..</span> (<span class="ruby-identifier">size</span>.<span class="ruby-identifier">first</span> <span class="ruby-operator">*</span> <span class="ruby-identifier">size</span>.<span class="ruby-identifier">last</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>)).<span class="ruby-identifier">to_a</span>
      <span class="ruby-keyword">end</span>
      
      <span class="ruby-comment"># It'll produce :int32, except if a dtype is provided.</span>
      <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">:dense</span>, <span class="ruby-identifier">size</span>, <span class="ruby-identifier">values</span>, <span class="ruby-identifier">dtype</span>)
    <span class="ruby-keyword">end</span></pre>
          </div><!-- seq-source -->
          
        </div>

        

        
      </div><!-- seq-method -->

    
      <div id="method-c-upcast" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            upcast(first_dtype, second_dtype) &rarr;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Given a binary operation between types t1 and t2, what type will be
returned?</p>

<p>This is a singleton method on <a href="NMatrix.html">NMatrix</a>, e.g., <a
href="NMatrix.html#method-c-upcast">::upcast</a>(:int32, :int64)</p>
          
          

          
          <div class="method-source-code" id="upcast-source">
            <pre>static VALUE nm_upcast(VALUE self, VALUE t1, VALUE t2) {

  nm::dtype_t d1    = nm_dtype_from_rbsymbol(t1),
              d2    = nm_dtype_from_rbsymbol(t2);

  return ID2SYM(rb_intern( DTYPE_NAMES[ Upcast[d1][d2] ] ));
}</pre>
          </div><!-- upcast-source -->
          
        </div>

        

        
      </div><!-- upcast-method -->

    
      <div id="method-c-zeroes" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">zeroes</span><span
            class="method-args">(*params)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-c-zeros">zeros</a>
        </div>
        
      </div><!-- zeroes-method -->

    
      <div id="method-c-zeros" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            zeros(size) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            zeros(size, dtype) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            zeros(stype, size, dtype) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a new matrix of zeros with the dimensions supplied as parameters.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>stype</code> -&gt; (optional) Default is <code>:dense</code>.</p>
</li><li>
<p><code>size</code> -&gt; <a href="Array.html">Array</a> (or integer for
square matrix) specifying the dimensions.</p>
</li><li>
<p><code>dtype</code> -&gt; (optional) Default is <code>:float64</code></p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p><a href="NMatrix.html">NMatrix</a> filled with zeros.</p>
</li></ul>
</li></ul>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">zeros</span>(<span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt;  0.0   0.0   </span>
                       <span class="ruby-value">0.0</span>   <span class="ruby-value">0.0</span>

<span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">zeros</span>([<span class="ruby-value">2</span>, <span class="ruby-value">3</span>], :<span class="ruby-identifier">int32</span>) <span class="ruby-comment"># =&gt;  0  0  0</span>
                                    <span class="ruby-value">0</span>  <span class="ruby-value">0</span>  <span class="ruby-value">0</span>

<span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">zeros</span>(:<span class="ruby-identifier">list</span>, [<span class="ruby-value">1</span>, <span class="ruby-value">5</span>], :<span class="ruby-identifier">int32</span>) <span class="ruby-comment"># =&gt;  0  0  0  0  0</span>
</pre>
          
          

          
          <div class="method-source-code" id="zeros-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 64</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">zeros</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">params</span>)
  <span class="ruby-identifier">dtype</span> = <span class="ruby-identifier">params</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Symbol</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">params</span>.<span class="ruby-identifier">pop</span> <span class="ruby-operator">:</span> <span class="ruby-value">:float64</span>
  <span class="ruby-identifier">stype</span> = <span class="ruby-identifier">params</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Symbol</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">params</span>.<span class="ruby-identifier">shift</span> <span class="ruby-operator">:</span> <span class="ruby-value">:dense</span>
  <span class="ruby-identifier">dim</span> = <span class="ruby-identifier">params</span>.<span class="ruby-identifier">first</span>

  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">stype</span>, <span class="ruby-identifier">dim</span>, <span class="ruby-value">0</span>, <span class="ruby-identifier">dtype</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- zeros-source -->
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-c-zeroes">zeroes</a>
        </div>
        

        
      </div><!-- zeros-method -->

    
    </section><!-- public-class-method-details -->
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Public Instance Methods</h3>

    
      <div id="method-i-3D-3D" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">==</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Equality operator. Returns a single true or false value indicating whether
the matrices are equivalent.</p>

<p>For elementwise, use =~ instead.</p>

<p>This method will raise an exception if dimensions do not match.</p>
          
          

          
          <div class="method-source-code" id="3D-3D-source">
            <pre>static VALUE nm_eqeq(VALUE left, VALUE right) {
  NMATRIX *l, *r;

  CheckNMatrixType(left);
  CheckNMatrixType(right);

  UnwrapNMatrix(left, l);
  UnwrapNMatrix(right, r);

  if (l-&gt;stype != r-&gt;stype)
    rb_raise(rb_eNotImpError, &quot;comparison between different matrix stypes not yet implemented&quot;);

  bool result = false;

  switch(l-&gt;stype) {
  case nm::DENSE_STORE:
    result = nm_dense_storage_eqeq(l-&gt;storage, r-&gt;storage);
    break;
  case nm::LIST_STORE:
    result = nm_list_storage_eqeq(l-&gt;storage, r-&gt;storage);
    break;
  case nm::YALE_STORE:
    result = nm_yale_storage_eqeq(l-&gt;storage, r-&gt;storage);
    break;
  }

  return result ? Qtrue : Qfalse;
}</pre>
          </div><!-- 3D-3D-source -->
          
        </div>

        

        
      </div><!-- 3D-3D-method -->

    
      <div id="method-i-5B-5D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            matrix[indexes] &rarr; ...
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Access the contents of an <a href="NMatrix.html">NMatrix</a> at given
coordinates by reference.</p>

<pre class="ruby"><span class="ruby-identifier">n</span>[<span class="ruby-value">3</span>,<span class="ruby-value">3</span>]  <span class="ruby-comment"># =&gt; 5.0</span>
<span class="ruby-identifier">n</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>,<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>] <span class="ruby-comment">#=&gt; matrix [2,2]</span>
</pre>
          
          

          
          <div class="method-source-code" id="5B-5D-source">
            <pre>static VALUE nm_mref(int argc, VALUE* argv, VALUE self) {
  static void* (*ttable[nm::NUM_STYPES])(STORAGE*, SLICE*) = {
    nm_dense_storage_ref,
    nm_list_storage_ref,
    nm_yale_storage_ref
  };
  return nm_xslice(argc, argv, ttable[NM_STYPE(self)], nm_delete_ref, self);
}</pre>
          </div><!-- 5B-5D-source -->
          
        </div>

        

        
      </div><!-- 5B-5D-method -->

    
      <div id="method-i-5B-5D-3D" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">[]=</span><span
            class="method-args">(*args)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Modify the contents of an <a href="NMatrix.html">NMatrix</a> in the given
cell</p>

<pre>n[3,3] = 5.0</pre>

<p>Also returns the new contents, so you can chain:</p>

<pre>n[3,3] = n[2,3] = 5.0</pre>
          
          

          
          <div class="method-source-code" id="5B-5D-3D-source">
            <pre>static VALUE nm_mset(int argc, VALUE* argv, VALUE self) {
  size_t dim = argc - 1; // last arg is the value

  if (argc &lt;= 1) {
    rb_raise(rb_eArgError, &quot;Expected coordinates and r-value&quot;);

  } else if (NM_DIM(self) == dim) {

    SLICE* slice = get_slice(dim, argv, self);

    void* value = rubyobj_to_cval(argv[dim], NM_DTYPE(self));

    // FIXME: Can't use a function pointer table here currently because these functions have different
    // signatures (namely the return type).
    switch(NM_STYPE(self)) {
    case nm::DENSE_STORE:
      nm_dense_storage_set(NM_STORAGE(self), slice, value);
      break;
    case nm::LIST_STORE:
      // Remove if it's a zero, insert otherwise
      if (!std::memcmp(value, NM_STORAGE_LIST(self)-&gt;default_val, DTYPE_SIZES[NM_DTYPE(self)])) {
        free(value);
        value = nm_list_storage_remove(NM_STORAGE(self), slice);
        free(value);
      } else {
        nm_list_storage_insert(NM_STORAGE(self), slice, value);
      }
      break;
    case nm::YALE_STORE:
      nm_yale_storage_set(NM_STORAGE(self), slice, value);
      break;
    }

    return argv[dim];

  } else if (NM_DIM(self) &lt; dim) {
    rb_raise(rb_eArgError, &quot;Coordinates given exceed number of matrix dimensions&quot;);
  } else {
    rb_raise(rb_eNotImpError, &quot;Slicing not supported yet&quot;);
  }
  return Qnil;
}</pre>
          </div><!-- 5B-5D-3D-source -->
          
        </div>

        

        
      </div><!-- 5B-5D-3D-method -->

    
      <div id="method-i-capacity" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">capacity</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Find the capacity of an <a href="NMatrix.html">NMatrix</a>. The capacity
only differs from the size for Yale matrices, which occasionally allocate
more space than they need. For list and dense, capacity gives the number of
elements in the matrix.</p>
          
          

          
          <div class="method-source-code" id="capacity-source">
            <pre>static VALUE nm_capacity(VALUE self) {
  VALUE cap;

  switch(NM_STYPE(self)) {
  case nm::YALE_STORE:
    cap = UINT2NUM(((YALE_STORAGE*)(NM_STORAGE(self)))-&gt;capacity);
    break;

  case nm::DENSE_STORE:
    cap = UINT2NUM(nm_storage_count_max_elements( NM_STORAGE_DENSE(self) ));
    break;

  case nm::LIST_STORE:
    cap = UINT2NUM(nm_list_storage_count_elements( NM_STORAGE_LIST(self) ));
    break;

  default:
    rb_raise(nm_eStorageTypeError, &quot;unrecognized stype in nm_capacity()&quot;);
  }

  return cap;
}</pre>
          </div><!-- capacity-source -->
          
        </div>

        

        
      </div><!-- capacity-method -->

    
      <div id="method-i-cast" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">cast</span><span
            class="method-args">(p1, p2)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Copy constructor for changing dtypes and stypes.</p>
          
          

          
          <div class="method-source-code" id="cast-source">
            <pre>static VALUE nm_init_cast_copy(VALUE self, VALUE new_stype_symbol, VALUE new_dtype_symbol) {
  nm::dtype_t new_dtype = nm_dtype_from_rbsymbol(new_dtype_symbol);
  nm::stype_t new_stype = nm_stype_from_rbsymbol(new_stype_symbol);

  CheckNMatrixType(self);

  NMATRIX *lhs = ALLOC(NMATRIX),
          *rhs;
  lhs-&gt;stype = new_stype;

  UnwrapNMatrix( self, rhs );

  // Copy the storage
  STYPE_CAST_COPY_TABLE(cast_copy);
  lhs-&gt;storage = cast_copy[lhs-&gt;stype][rhs-&gt;stype](rhs-&gt;storage, new_dtype);

  STYPE_MARK_TABLE(mark);

  return Data_Wrap_Struct(CLASS_OF(self), mark[lhs-&gt;stype], nm_delete, lhs);
}</pre>
          </div><!-- cast-source -->
          
        </div>

        

        
      </div><!-- cast-method -->

    
      <div id="method-i-cols" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            cols &rarr; Integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>This shortcut use <a href="NMatrix.html#method-i-shape">shape</a> to return
the number of columns (the second dimension) of the matrix.</p>
          
          

          
          <div class="method-source-code" id="cols-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">cols</span>
  <span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>]
<span class="ruby-keyword">end</span></pre>
          </div><!-- cols-source -->
          
        </div>

        

        
      </div><!-- cols-method -->

    
      <div id="method-i-column" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            column(column_number) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            column(column_number, get_by) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the column specified. Uses slicing by copy as default.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>column_number</code> -&gt; Integer.</p>
</li><li>
<p><code>get_by</code> -&gt; Type of slicing to use, <code>:copy</code> or
<code>:reference</code>.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>A <a href="NMatrix.html">NMatrix</a> representing the requested column as a
column vector.</p>
</li></ul>
</li></ul>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-identifier">m</span> = <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2</span>, [<span class="ruby-value">1</span>, <span class="ruby-value">4</span>, <span class="ruby-value">9</span>, <span class="ruby-value">14</span>], :<span class="ruby-identifier">int32</span>) <span class="ruby-comment"># =&gt;  1   4</span>
                                                <span class="ruby-value">9</span>  <span class="ruby-value">14</span>

<span class="ruby-identifier">m</span>.<span class="ruby-identifier">column</span>(<span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt;   4</span>
                  <span class="ruby-value">14</span>
</pre>
          
          

          
          <div class="method-source-code" id="column-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 306</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">column</span>(<span class="ruby-identifier">column_number</span>, <span class="ruby-identifier">get_by</span> = <span class="ruby-value">:copy</span>)
  <span class="ruby-keyword">unless</span> [<span class="ruby-value">:copy</span>, <span class="ruby-value">:reference</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">get_by</span>)
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&quot;column() 2nd parameter must be :copy or :reference&quot;</span>
  <span class="ruby-keyword">end</span>
  
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">get_by</span> <span class="ruby-operator">==</span> <span class="ruby-value">:copy</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">slice</span>(<span class="ruby-value">0</span> <span class="ruby-operator">...</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">column_number</span>)
  <span class="ruby-keyword">else</span> <span class="ruby-comment"># by reference</span>
    <span class="ruby-keyword">self</span>[<span class="ruby-value">0</span> <span class="ruby-operator">...</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">column_number</span>]
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- column-source -->
          
        </div>

        

        
      </div><!-- column-method -->

    
      <div id="method-i-complex_conjugate" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            complex_conjugate &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            complex_conjugate(new_stype) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the complex conjugate of this matrix. See also <a
href="NMatrix.html#method-i-complex_conjugate">#complex_conjugate</a>! for
an in-place operation (provided the dtype is already
<code>:complex64</code> or <code>:complex128</code>).</p>

<p>Doesnâ€™t work on list matrices, but you can optionally pass in the stype you
want to cast to if youâ€™re dealing with a list matrix.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>new_stype</code> -&gt; stype for the new matrix.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>If the original <a href="NMatrix.html">NMatrix</a> isnâ€™t complex, the
result is a <code>:complex128</code> <a href="NMatrix.html">NMatrix</a>.
Otherwise, itâ€™s the original dtype.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="complex_conjugate-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 220</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">complex_conjugate</span>(<span class="ruby-identifier">new_stype</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span>)
        <span class="ruby-keyword">self</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-identifier">new_stype</span>, <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-identifier">upcast</span>(<span class="ruby-identifier">dtype</span>, <span class="ruby-value">:complex64</span>)).<span class="ruby-identifier">complex_conjugate!</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- complex_conjugate-source -->
          
        </div>

        

        
      </div><!-- complex_conjugate-method -->

    
      <div id="method-i-complex_conjugate-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            complex_conjugate &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Transform the matrix (in-place) to its complex conjugate. Only works on
complex matrices.</p>

<p>FIXME: For non-complex matrices, someone needs to implement a non-in-place
complex conjugate (which doesnâ€™t use a bang). Bang should imply that no
copy is being made, even temporarily.</p>
          
          

          
          <div class="method-source-code" id="complex_conjugate-21-source">
            <pre>static VALUE nm_complex_conjugate_bang(VALUE self) {
  NMATRIX* m;
  void* elem;
  size_t size, p;

  UnwrapNMatrix(self, m);

  if (m-&gt;stype == nm::DENSE_STORE) {

    size = nm_storage_count_max_elements(NM_STORAGE(self));
    elem = NM_STORAGE_DENSE(self)-&gt;elements;

  } else if (m-&gt;stype == nm::YALE_STORE) {

    size = nm_yale_storage_get_size(NM_STORAGE_YALE(self));
    elem = NM_STORAGE_YALE(self)-&gt;a;

  } else {
    rb_raise(rb_eNotImpError, &quot;please cast to yale or dense (complex) first&quot;);
  }

  // Walk through and negate the imaginary component
  if (NM_DTYPE(self) == nm::COMPLEX64) {

    for (p = 0; p &lt; size; ++p) {
      reinterpret_cast&lt;nm::Complex64*&gt;(elem)[p].i = -reinterpret_cast&lt;nm::Complex64*&gt;(elem)[p].i;
    }

  } else if (NM_DTYPE(self) == nm::COMPLEX128) {

    for (p = 0; p &lt; size; ++p) {
      reinterpret_cast&lt;nm::Complex128*&gt;(elem)[p].i = -reinterpret_cast&lt;nm::Complex128*&gt;(elem)[p].i;
    }

  } else {
    rb_raise(nm_eDataTypeError, &quot;can only calculate in-place complex conjugate on matrices of type :complex64 or :complex128&quot;);
  }

  return self;
}</pre>
          </div><!-- complex_conjugate-21-source -->
          
        </div>

        

        
      </div><!-- complex_conjugate-21-method -->

    
      <div id="method-i-conjugate_transpose" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            conjugate_transpose &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calculate the conjugate transpose of a matrix. If your dtype is already
complex, this should only require one copy (for the transpose).</p>
<ul><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>The conjugate transpose of the matrix as a copy.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="conjugate_transpose-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 234</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">conjugate_transpose</span>
        <span class="ruby-keyword">self</span>.<span class="ruby-identifier">transpose</span>.<span class="ruby-identifier">complex_conjugate!</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- conjugate_transpose-source -->
          
        </div>

        

        
      </div><!-- conjugate_transpose-method -->

    
      <div id="method-i-det" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            det &rarr; determinant
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calculate the determinant by way of LU decomposition. This is accomplished
using clapack_getrf, and then by summing the diagonal elements. There is a
risk of underflow/overflow.</p>

<p>There are probably also more efficient ways to calculate the determinant.
This method requires making a copy of the matrix, since clapack_getrf
modifies its input.</p>

<p>For smaller matrices, you may be able to use <code>#det_exact</code>.</p>

<p>This function is guaranteed to return the same type of data in the matrix
upon which it is called. In other words, if you call it on a rational
matrix, youâ€™ll get a rational number back.</p>

<p>Integer matrices are converted to rational matrices for the purposes of
performing the calculation, as xGETRF canâ€™t work on integer matrices.</p>
<ul><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>The determinant of the matrix. Itâ€™s the same type as the matrixâ€™s dtype.</p>
</li></ul>
</li><li>
<p><strong>Raises</strong> :</p>
<ul><li>
<p><code>NotImplementedError</code> -&gt; Must be used in 2D matrices.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="det-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 183</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">det</span>
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">NotImplementedError</span>, <span class="ruby-string">&quot;determinant can be calculated only for 2D matrices&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span> <span class="ruby-operator">==</span> <span class="ruby-value">2</span>

  <span class="ruby-comment"># Cast to a dtype for which getrf is implemented</span>
  <span class="ruby-identifier">new_dtype</span> = [<span class="ruby-value">:byte</span>,<span class="ruby-value">:int8</span>,<span class="ruby-value">:int16</span>,<span class="ruby-value">:int32</span>,<span class="ruby-value">:int64</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>) <span class="ruby-operator">?</span> <span class="ruby-value">:rational128</span> <span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>
  <span class="ruby-identifier">copy</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-value">:dense</span>, <span class="ruby-identifier">new_dtype</span>)

  <span class="ruby-comment"># Need to know the number of permutations. We'll add up the diagonals of</span>
  <span class="ruby-comment"># the factorized matrix.</span>
  <span class="ruby-identifier">pivot</span> = <span class="ruby-identifier">copy</span>.<span class="ruby-identifier">getrf!</span>

  <span class="ruby-identifier">prod</span> = <span class="ruby-identifier">pivot</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">%</span> <span class="ruby-value">2</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span> <span class="ruby-operator">?</span> <span class="ruby-value">-1</span> <span class="ruby-operator">:</span> <span class="ruby-value">1</span> <span class="ruby-comment"># odd permutations =&gt; negative</span>
  [<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>],<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>]].<span class="ruby-identifier">min</span>.<span class="ruby-identifier">times</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">prod</span> <span class="ruby-operator">*=</span> <span class="ruby-identifier">copy</span>[<span class="ruby-identifier">i</span>,<span class="ruby-identifier">i</span>]
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Convert back to an integer if necessary</span>
  <span class="ruby-identifier">new_dtype</span> <span class="ruby-operator">!=</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">prod</span>.<span class="ruby-identifier">to_i</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">prod</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- det-source -->
          
        </div>

        

        
      </div><!-- det-method -->

    
      <div id="method-i-det_exact" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">det_exact</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Calculate the exact determinant of a dense matrix.</p>

<p>Returns nil for dense matrices which are not square or number of dimensions
other than 2.</p>

<p>Note: Currently only implemented for 2x2 and 3x3 matrices.</p>
          
          

          
          <div class="method-source-code" id="det_exact-source">
            <pre>static VALUE nm_det_exact(VALUE self) {
  if (NM_STYPE(self) != nm::DENSE_STORE) rb_raise(nm_eStorageTypeError, &quot;can only calculate exact determinant for dense matrices&quot;);

  if (NM_DIM(self) != 2 || NM_SHAPE0(self) != NM_SHAPE1(self)) return Qnil;

  // Calculate the determinant and then assign it to the return value
  void* result = ALLOCA_N(char, DTYPE_SIZES[NM_DTYPE(self)]);
  nm_math_det_exact(NM_SHAPE0(self), NM_STORAGE_DENSE(self)-&gt;elements, NM_SHAPE0(self), NM_DTYPE(self), result);

  return rubyobj_from_cval(result, NM_DTYPE(self)).rval;
}</pre>
          </div><!-- det_exact-source -->
          
        </div>

        

        
      </div><!-- det_exact-method -->

    
      <div id="method-i-dim" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">dim</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-dimensions">dimensions</a>
        </div>
        
      </div><!-- dim-method -->

    
      <div id="method-i-dimensions" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            dim &rarr; Integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the number of dimensions of a matrix.</p>

<p>In other words, if you set your matrix to be 3x4, the dim is 2. If the
matrix was initialized as 3x4x3, the dim is 3.</p>

<p>This function may lie slightly for NVectors, which are internally stored as
dim 2 (and have an orientation), but act as if theyâ€™re dim 1.</p>
          
          

          
          <div class="method-source-code" id="dimensions-source">
            <pre>static VALUE nm_dim(VALUE self) {
  return INT2FIX(NM_STORAGE(self)-&gt;dim);
}</pre>
          </div><!-- dimensions-source -->
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-dim">dim</a>
        </div>
        

        
      </div><!-- dimensions-method -->

    
      <div id="method-i-dot" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">dot</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Matrix multiply (dot product): against another matrix or a vector.</p>

<p>For elementwise, use * instead.</p>

<p>The two matrices must be of the same stype (for now). If dtype differs, an
upcast will occur.</p>
          
          

          
          <div class="method-source-code" id="dot-source">
            <pre>static VALUE nm_multiply(VALUE left_v, VALUE right_v) {
  NMATRIX *left, *right;

  // left has to be of type NMatrix.
  CheckNMatrixType(left_v);

  UnwrapNMatrix( left_v, left );

  if (NM_RUBYVAL_IS_NUMERIC(right_v))
    return matrix_multiply_scalar(left, right_v);

  else if (TYPE(right_v) == T_ARRAY)
    rb_raise(rb_eNotImpError, &quot;for matrix-vector multiplication, please use an NVector instead of an Array for now&quot;);

  //if (RDATA(right_v)-&gt;dfree != (RUBY_DATA_FUNC)nm_delete) {
  else { // both are matrices
    CheckNMatrixType(right_v);
    UnwrapNMatrix( right_v, right );

    if (left-&gt;storage-&gt;shape[1] != right-&gt;storage-&gt;shape[0])
      rb_raise(rb_eArgError, &quot;incompatible dimensions&quot;);

    if (left-&gt;stype != right-&gt;stype)
      rb_raise(rb_eNotImpError, &quot;matrices must have same stype&quot;);

    return matrix_multiply(left, right);

  } 

  return Qnil;
}</pre>
          </div><!-- dot-source -->
          
        </div>

        

        
      </div><!-- dot-method -->

    
      <div id="method-i-dtype" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            dtype &rarr; Symbol
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the data type (dtype) of a matrix, e.g., :byte, :int8, :int16, :int32,
:int64, :float32, :float64, :complex64, :complex128, :rational32,
:rational64, :rational128, or :object (the last is a Ruby object).</p>
          
          

          
          <div class="method-source-code" id="dtype-source">
            <pre>static VALUE nm_dtype(VALUE self) {
  ID dtype = rb_intern(DTYPE_NAMES[NM_DTYPE(self)]);
  return ID2SYM(dtype);
}</pre>
          </div><!-- dtype-source -->
          
        </div>

        

        
      </div><!-- dtype-method -->

    
      <div id="method-i-each" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each &rarr;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Iterate over the matrix as you would an Enumerable (e.g., <a
href="Array.html">Array</a>).</p>

<p>Currently only works for dense.</p>
          
          

          
          <div class="method-source-code" id="each-source">
            <pre>static VALUE nm_each(VALUE nmatrix) {
  volatile VALUE nm = nmatrix; // not sure why we do this, but it gets done in ruby's array.c.

  switch(NM_STYPE(nm)) {
  case nm::DENSE_STORE:
    return nm_dense_each(nm);
  default:
    rb_raise(rb_eNotImpError, &quot;only dense matrix's each method works right now&quot;);
  }
}</pre>
          </div><!-- each-source -->
          
        </div>

        

        
      </div><!-- each-method -->

    
      <div id="method-i-each_stored_with_indices" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">each_stored_with_indices</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Iterate over the sparse entries of any matrix. For dense and yale, this
iterates over non-zero entries; for list, this iterates over non-default
entries. Yields dim+1 values for each entry: i, j, â€¦, and the entry itself.</p>
          
          

          
          <div class="method-source-code" id="each_stored_with_indices-source">
            <pre>static VALUE nm_each_stored_with_indices(VALUE nmatrix) {
  volatile VALUE nm = nmatrix;

  switch(NM_STYPE(nm)) {
  case nm::YALE_STORE:
    return nm_yale_each_stored_with_indices(nm);
  case nm::DENSE_STORE:
    return nm_dense_each_with_indices(nm);
  default:
    rb_raise(rb_eNotImpError, &quot;not yet implemented for list matrices&quot;);
  }
}</pre>
          </div><!-- each_stored_with_indices-source -->
          
        </div>

        

        
      </div><!-- each_stored_with_indices-method -->

    
      <div id="method-i-factorize_lu" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            factorize_lu &rarr; ...
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>LU factorization of a matrix.</p>

<p>FIXME: For some reason, getrf seems to require that the matrix be
transposed first â€“ and then you have to transpose the FIXME: result again.
Ideally, this would be an in-place factorize instead, and would be called
nm_factorize_lu_bang.</p>
          
          

          
          <div class="method-source-code" id="factorize_lu-source">
            <pre>static VALUE nm_factorize_lu(VALUE self) {
  if (NM_STYPE(self) != nm::DENSE_STORE) {
    rb_raise(rb_eNotImpError, &quot;only implemented for dense storage&quot;);
  }

  if (NM_DIM(self) != 2) {
    rb_raise(rb_eNotImpError, &quot;matrix is not 2-dimensional&quot;);
  }

  VALUE copy = nm_init_transposed(self);

  static int (*ttable[nm::NUM_DTYPES])(const enum CBLAS_ORDER, const int m, const int n, void* a, const int lda, int* ipiv) = {
      NULL, NULL, NULL, NULL, NULL, // integers not allowed due to division
      nm::math::clapack_getrf&lt;float&gt;,
      nm::math::clapack_getrf&lt;double&gt;,
#ifdef HAVE_CLAPACK_H
      clapack_cgetrf, clapack_zgetrf, // call directly, same function signature!
#else
      nm::math::clapack_getrf&lt;nm::Complex64&gt;,
      nm::math::clapack_getrf&lt;nm::Complex128&gt;,
#endif
      nm::math::clapack_getrf&lt;nm::Rational32&gt;,
      nm::math::clapack_getrf&lt;nm::Rational64&gt;,
      nm::math::clapack_getrf&lt;nm::Rational128&gt;,
      nm::math::clapack_getrf&lt;nm::RubyObject&gt;
  };

  int* ipiv = ALLOCA_N(int, std::min(NM_SHAPE0(copy), NM_SHAPE1(copy)));

  // In-place factorize
  ttable[NM_DTYPE(copy)](CblasRowMajor, NM_SHAPE0(copy), NM_SHAPE1(copy), NM_STORAGE_DENSE(copy)-&gt;elements, NM_SHAPE1(copy), ipiv);

  // Transpose the result
  return nm_init_transposed(copy);
}</pre>
          </div><!-- factorize_lu-source -->
          
        </div>

        

        
      </div><!-- factorize_lu-method -->

    
      <div id="method-i-getrf-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            getrf! &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>LU factorization of a general M-by-N matrix <code>A</code> using partial
pivoting with row interchanges. Only works in dense matrices.</p>
<ul><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>The IPIV vector. The L and U matrices are stored in A.</p>
</li></ul>
</li><li>
<p><strong>Raises</strong> :</p>
<ul><li>
<p><code>StorageTypeError</code> -&gt; ATLAS functions only work on dense
matrices.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="getrf-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 151</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">getrf!</span>
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">StorageTypeError</span>, <span class="ruby-string">&quot;ATLAS functions only work on dense matrices&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dense</span>
  <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">LAPACK</span><span class="ruby-operator">::</span><span class="ruby-identifier">clapack_getrf</span>(<span class="ruby-value">:row</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>], <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>], <span class="ruby-keyword">self</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>])
<span class="ruby-keyword">end</span></pre>
          </div><!-- getrf-21-source -->
          
        </div>

        

        
      </div><!-- getrf-21-method -->

    
      <div id="method-i-hermitian-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            hermitian? &rarr; Boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Is this matrix hermitian?</p>

<p>Definition: <a
href="http://en.wikipedia.org/wiki/Hermitian_matrix">en.wikipedia.org/wiki/Hermitian_matrix</a></p>

<p>For non-complex matrices, this function should return the same result as
symmetric?.</p>
          
          

          
          <div class="method-source-code" id="hermitian-3F-source">
            <pre>static VALUE nm_hermitian(VALUE self) {
  return is_symmetric(self, true);
}</pre>
          </div><!-- hermitian-3F-source -->
          
        </div>

        

        
      </div><!-- hermitian-3F-method -->

    
      <div id="method-i-initialize_copy" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">initialize_copy</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Copy constructor for no change of dtype or stype (used for <a
href="NMatrix.html#method-i-initialize_copy">initialize_copy</a> hook).</p>
          
          

          
          <div class="method-source-code" id="initialize_copy-source">
            <pre>static VALUE nm_init_copy(VALUE copy, VALUE original) {
  NMATRIX *lhs, *rhs;

  CheckNMatrixType(original);

  if (copy == original) return copy;

  UnwrapNMatrix( original, rhs );
  UnwrapNMatrix( copy,     lhs );

  lhs-&gt;stype = rhs-&gt;stype;

  // Copy the storage
  STYPE_CAST_COPY_TABLE(ttable);
  lhs-&gt;storage = ttable[lhs-&gt;stype][rhs-&gt;stype](rhs-&gt;storage, rhs-&gt;storage-&gt;dtype);

  return copy;
}</pre>
          </div><!-- initialize_copy-source -->
          
        </div>

        

        
      </div><!-- initialize_copy-method -->

    
      <div id="method-i-inverse" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">inverse</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-invert">invert</a>
        </div>
        
      </div><!-- inverse-method -->

    
      <div id="method-i-invert" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            invert &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Make a copy of the matrix, then invert it (requires <a
href="NMatrix/LAPACK.html">LAPACK</a>).</p>
<ul><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>A dense <a href="NMatrix.html">NMatrix</a>.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="invert-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 134</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">invert</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-value">:dense</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>).<span class="ruby-identifier">invert!</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- invert-source -->
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-inverse">inverse</a>
        </div>
        

        
      </div><!-- invert-method -->

    
      <div id="method-i-invert-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            invert! &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Use <a href="NMatrix/LAPACK.html">LAPACK</a> to calculate the inverse of
the matrix (in-place). Only works on dense matrices.</p>

<p>Note: If you donâ€™t have <a href="NMatrix/LAPACK.html">LAPACK</a>, e.g., on
a Mac, this may not work yet.</p>
          
          

          
          <div class="method-source-code" id="invert-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 115</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">invert!</span>
  <span class="ruby-comment"># Get the pivot array; factor the matrix</span>
  <span class="ruby-identifier">pivot</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">getrf!</span>

  <span class="ruby-comment"># Now calculate the inverse using the pivot array</span>
  <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">LAPACK</span><span class="ruby-operator">::</span><span class="ruby-identifier">clapack_getri</span>(<span class="ruby-value">:row</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>], <span class="ruby-keyword">self</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">pivot</span>)

  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- invert-21-source -->
          
        </div>

        

        
      </div><!-- invert-21-method -->

    
      <div id="method-i-is_ref-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">is_ref?</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Check to determine whether matrix is a reference to another matrix.</p>
          
          

          
          <div class="method-source-code" id="is_ref-3F-source">
            <pre>static VALUE nm_is_ref(VALUE self) {
        // Refs only allowed for dense and list matrices.
  if (NM_STYPE(self) == nm::DENSE_STORE) {
    return (NM_DENSE_SRC(self) == NM_STORAGE(self)) ? Qfalse : Qtrue;
  }

  if (NM_STYPE(self) == nm::LIST_STORE) {
    return (NM_LIST_SRC(self) == NM_STORAGE(self)) ? Qfalse : Qtrue;
  }

  return Qfalse;
}</pre>
          </div><!-- is_ref-3F-source -->
          
        </div>

        

        
      </div><!-- is_ref-3F-method -->

    
      <div id="method-i-itype" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            itype &rarr; Symbol or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the index data type (dtype) of a matrix. Defined only for yale; others
return nil.</p>
          
          

          
          <div class="method-source-code" id="itype-source">
            <pre>static VALUE nm_itype(VALUE self) {
  if (NM_STYPE(self) == nm::YALE_STORE) {
    ID itype = rb_intern(ITYPE_NAMES[NM_ITYPE(self)]);
    return ID2SYM(itype);
  }
  return Qnil;
}</pre>
          </div><!-- itype-source -->
          
        </div>

        

        
      </div><!-- itype-method -->

    
      <div id="method-i-rows" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            rows &rarr; Integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>This shortcut use <a href="NMatrix.html#method-i-shape">shape</a> to return
the number of rows (the first dimension) of the matrix.</p>
          
          

          
          <div class="method-source-code" id="rows-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">rows</span>
  <span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]
<span class="ruby-keyword">end</span></pre>
          </div><!-- rows-source -->
          
        </div>

        

        
      </div><!-- rows-method -->

    
      <div id="method-i-shape" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            shape &rarr; Array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the shape (dimensions) of a matrix.</p>
          
          

          
          <div class="method-source-code" id="shape-source">
            <pre>static VALUE nm_shape(VALUE self) {
  STORAGE* s   = NM_STORAGE(self);
  size_t index;

  // Copy elements into a VALUE array and then use those to create a Ruby array with rb_ary_new4.
  VALUE* shape = ALLOCA_N(VALUE, s-&gt;dim);
  for (index = 0; index &lt; s-&gt;dim; ++index)
    shape[index] = INT2FIX(s-&gt;shape[index]);

  return rb_ary_new4(s-&gt;dim, shape);
}</pre>
          </div><!-- shape-source -->
          
        </div>

        

        
      </div><!-- shape-method -->

    
      <div id="method-i-slice" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            slice &rarr; ...
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Access the contents of an <a href="NMatrix.html">NMatrix</a> at given
coordinates, using copying.</p>

<pre class="ruby"><span class="ruby-identifier">n</span>.<span class="ruby-identifier">slice</span>(<span class="ruby-value">3</span>,<span class="ruby-value">3</span>)  <span class="ruby-comment"># =&gt; 5.0</span>
<span class="ruby-identifier">n</span>.<span class="ruby-identifier">slice</span>(<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>,<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>) <span class="ruby-comment">#=&gt; matrix [2,2]</span>
</pre>
          
          

          
          <div class="method-source-code" id="slice-source">
            <pre>static VALUE nm_mget(int argc, VALUE* argv, VALUE self) {
  static void* (*ttable[nm::NUM_STYPES])(STORAGE*, SLICE*) = {
    nm_dense_storage_get,
    nm_list_storage_get,
    nm_yale_storage_get
  };
  
  return nm_xslice(argc, argv, ttable[NM_STYPE(self)], nm_delete, self);
}</pre>
          </div><!-- slice-source -->
          
        </div>

        

        
      </div><!-- slice-method -->

    
      <div id="method-i-stype" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            stype &rarr; Symbol
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the storage type (stype) of a matrix, e.g., :yale, :dense, or :list.</p>
          
          

          
          <div class="method-source-code" id="stype-source">
            <pre>static VALUE nm_stype(VALUE self) {
  ID stype = rb_intern(STYPE_NAMES[NM_STYPE(self)]);
  return ID2SYM(stype);
}</pre>
          </div><!-- stype-source -->
          
        </div>

        

        
      </div><!-- stype-method -->

    
      <div id="method-i-symmetric-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            symmetric? &rarr; Boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Is this matrix symmetric?</p>
          
          

          
          <div class="method-source-code" id="symmetric-3F-source">
            <pre>static VALUE nm_symmetric(VALUE self) {
  return is_symmetric(self, false);
}</pre>
          </div><!-- symmetric-3F-source -->
          
        </div>

        

        
      </div><!-- symmetric-3F-method -->

    
      <div id="method-i-to_h" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">to_h</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-to_hash">to_hash</a>
        </div>
        
      </div><!-- to_h-method -->

    
      <div id="method-i-to_hash" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            to_hash &rarr; Hash
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Create a Ruby Hash from an <a href="NMatrix.html">NMatrix</a>.</p>

<p>Currently only works for list storage.</p>
          
          

          
          <div class="method-source-code" id="to_hash-source">
            <pre>static VALUE nm_to_hash(VALUE self) {
  if (NM_STYPE(self) != nm::LIST_STORE) {
    rb_raise(rb_eNotImpError, &quot;please cast to :list first&quot;);
  }

  return nm_list_storage_to_hash(NM_STORAGE_LIST(self), NM_DTYPE(self));
}</pre>
          </div><!-- to_hash-source -->
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-to_h">to_h</a>
        </div>
        

        
      </div><!-- to_hash-method -->

    
      <div id="method-i-transpose" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">transpose</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Copy constructor for transposing.</p>
          
          

          
          <div class="method-source-code" id="transpose-source">
            <pre>static VALUE nm_init_transposed(VALUE self) {
  static STORAGE* (*storage_copy_transposed[nm::NUM_STYPES])(const STORAGE* rhs_base) = {
    nm_dense_storage_copy_transposed,
    nm_list_storage_copy_transposed,
    nm_yale_storage_copy_transposed
  };

  NMATRIX* lhs = nm_create( NM_STYPE(self),
                            storage_copy_transposed[NM_STYPE(self)]( NM_STORAGE(self) )
                          );

  STYPE_MARK_TABLE(mark);

  return Data_Wrap_Struct(CLASS_OF(self), mark[lhs-&gt;stype], nm_delete, lhs);
}</pre>
          </div><!-- transpose-source -->
          
        </div>

        

        
      </div><!-- transpose-method -->

    
      <div id="method-i-write" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">write</span><span
            class="method-args">(*args)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Binary file writer for <a href="NMatrix.html">NMatrix</a> standard format.
file should be a path, which we arenâ€™t going to check very carefully (in
other words, this function should generally be called from a Ruby helper
method). Function also takes a symmetry argument, which allows us to
specify that we only want to save the upper triangular portion of the
matrix (or if the matrix is a lower triangular matrix, only the lower
triangular portion). nil means regular storage.</p>
          
          

          
          <div class="method-source-code" id="write-source">
            <pre>static VALUE nm_write(int argc, VALUE* argv, VALUE self) {
  using std::ofstream;

  if (argc &lt; 1 || argc &gt; 2) {
    rb_raise(rb_eArgError, &quot;Expected one or two arguments&quot;);
  }
  VALUE file = argv[0],
        symm = argc == 1 ? Qnil : argv[1];

  NMATRIX* nmatrix;
  UnwrapNMatrix( self, nmatrix );

  nm::symm_t symm_ = interpret_symm(symm);
  nm::itype_t itype = (nmatrix-&gt;stype == nm::YALE_STORE) ? reinterpret_cast&lt;YALE_STORAGE*&gt;(nmatrix-&gt;storage)-&gt;itype : nm::UINT32;

  if (nmatrix-&gt;storage-&gt;dtype == nm::RUBYOBJ) {
    rb_raise(rb_eNotImpError, &quot;Ruby Object writing is not implemented yet&quot;);
  }

  // Get the dtype, stype, itype, and symm and ensure they're the correct number of bytes.
  uint8_t st = static_cast&lt;uint8_t&gt;(nmatrix-&gt;stype),
          dt = static_cast&lt;uint8_t&gt;(nmatrix-&gt;storage-&gt;dtype),
          sm = static_cast&lt;uint8_t&gt;(symm_),
          it = static_cast&lt;uint8_t&gt;(itype);
  uint16_t dim = nmatrix-&gt;storage-&gt;dim;

  // Check arguments before starting to write.
  if (nmatrix-&gt;stype == nm::LIST_STORE) rb_raise(nm_eStorageTypeError, &quot;cannot save list matrix; cast to yale or dense first&quot;);
  if (symm_ != nm::NONSYMM) {
    if (dim != 2) rb_raise(rb_eArgError, &quot;symmetry/triangularity not defined for a non-2D matrix&quot;);
    if (nmatrix-&gt;storage-&gt;shape[0] != nmatrix-&gt;storage-&gt;shape[1])
      rb_raise(rb_eArgError, &quot;symmetry/triangularity not defined for a non-square matrix&quot;);
    if (symm_ == nm::HERM &amp;&amp;
          dt != static_cast&lt;uint8_t&gt;(nm::COMPLEX64) &amp;&amp; dt != static_cast&lt;uint8_t&gt;(nm::COMPLEX128) &amp;&amp; dt != static_cast&lt;uint8_t&gt;(nm::RUBYOBJ))
      rb_raise(rb_eArgError, &quot;cannot save a non-complex matrix as hermitian&quot;);
  }

  ofstream f(RSTRING_PTR(file), std::ios::out | std::ios::binary);

  // Get the NMatrix version information.
  uint16_t major, minor, release, null16 = 0;
  get_version_info(major, minor, release);

  // WRITE FIRST 64-BIT BLOCK
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;major),   sizeof(uint16_t));
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;minor),   sizeof(uint16_t));
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;release), sizeof(uint16_t));
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;null16),  sizeof(uint16_t));

  // WRITE SECOND 64-BIT BLOCK
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;dt), sizeof(uint8_t));
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;st), sizeof(uint8_t));
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;it), sizeof(uint8_t));
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;sm), sizeof(uint8_t));
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;null16), sizeof(uint16_t));
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;dim), sizeof(uint16_t));

  // Write shape (in 64-bit blocks)
  write_padded_shape(f, nmatrix-&gt;storage-&gt;dim, nmatrix-&gt;storage-&gt;shape, itype);

  if (nmatrix-&gt;stype == nm::DENSE_STORE) {
    write_padded_dense_elements(f, reinterpret_cast&lt;DENSE_STORAGE*&gt;(nmatrix-&gt;storage), symm_, nmatrix-&gt;storage-&gt;dtype);
  } else if (nmatrix-&gt;stype == nm::YALE_STORE) {
    YALE_STORAGE* s = reinterpret_cast&lt;YALE_STORAGE*&gt;(nmatrix-&gt;storage);
    uint32_t ndnz   = s-&gt;ndnz,
             length = nm_yale_storage_get_size(s);
    f.write(reinterpret_cast&lt;const char*&gt;(&amp;ndnz),   sizeof(uint32_t));
    f.write(reinterpret_cast&lt;const char*&gt;(&amp;length), sizeof(uint32_t));

    write_padded_yale_elements(f, s, length, symm_, s-&gt;dtype, itype);
  }

  f.close();

  return Qtrue;
}</pre>
          </div><!-- write-source -->
          
        </div>

        

        
      </div><!-- write-method -->

    
    </section><!-- public-instance-method-details -->
  
  </section><!-- 5Buntitled-5D -->

</div><!-- documentation -->


<footer id="validator-badges">
  <p><a href="http://validator.w3.org/check/referer">[Validate]</a>
  <p>Generated by <a href="https://github.com/rdoc/rdoc">RDoc</a> 4.0.0.rc.2.1.
  <p>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish Rdoc Generator</a> 3.
</footer>

