<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class NMatrix - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
</script>

<script src="./js/jquery.js"></script>
<script src="./js/darkfish.js"></script>

<link href="./css/fonts.css" rel="stylesheet">
<link href="./css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="./index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="./table_of_contents.html#pages">Pages</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    <div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  
  <p class="link"><a href="Object.html">Object</a>
  
</div>

    <div id="includes-section" class="nav-section">
  <h3>Included Modules</h3>

  <ul class="link-list">
  
  
    <li><span class="include">Enumerable</span>
  
  
  </ul>
</div>

    
    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li ><a href="#method-c-5B-5D">::[]</a>
    
    <li ><a href="#method-c-block_diag">::block_diag</a>
    
    <li ><a href="#method-c-block_diagonal">::block_diagonal</a>
    
    <li ><a href="#method-c-diag">::diag</a>
    
    <li ><a href="#method-c-diagonal">::diagonal</a>
    
    <li ><a href="#method-c-diagonals">::diagonals</a>
    
    <li ><a href="#method-c-eye">::eye</a>
    
    <li ><a href="#method-c-guess_dtype">::guess_dtype</a>
    
    <li ><a href="#method-c-identity">::identity</a>
    
    <li ><a href="#method-c-load_matlab_file">::load_matlab_file</a>
    
    <li ><a href="#method-c-load_pcd_file">::load_pcd_file</a>
    
    <li ><a href="#method-c-meshgrid">::meshgrid</a>
    
    <li ><a href="#method-c-min_dtype">::min_dtype</a>
    
    <li ><a href="#method-c-new">::new</a>
    
    <li ><a href="#method-c-ones">::ones</a>
    
    <li ><a href="#method-c-ones_like">::ones_like</a>
    
    <li ><a href="#method-c-rand">::rand</a>
    
    <li ><a href="#method-c-random">::random</a>
    
    <li ><a href="#method-c-read">::read</a>
    
    <li ><a href="#method-c-register_lapack_extension">::register_lapack_extension</a>
    
    <li ><a href="#method-c-seq">::seq</a>
    
    <li ><a href="#method-c-size">::size</a>
    
    <li ><a href="#method-c-translation">::translation</a>
    
    <li ><a href="#method-c-upcast">::upcast</a>
    
    <li ><a href="#method-c-x_rotation">::x_rotation</a>
    
    <li ><a href="#method-c-y_rotation">::y_rotation</a>
    
    <li ><a href="#method-c-z_rotation">::z_rotation</a>
    
    <li ><a href="#method-c-zeroes">::zeroes</a>
    
    <li ><a href="#method-c-zeros">::zeros</a>
    
    <li ><a href="#method-c-zeros_like">::zeros_like</a>
    
    <li ><a href="#method-i-3D-3D">#==</a>
    
    <li ><a href="#method-i-5B-5D">#[]</a>
    
    <li ><a href="#method-i-5B-5D-3D">#[]=</a>
    
    <li ><a href="#method-i-__dense_unary_round__">#__dense_unary_round__</a>
    
    <li ><a href="#method-i-__list_unary_round__">#__list_unary_round__</a>
    
    <li ><a href="#method-i-__yale_unary_round__">#__yale_unary_round__</a>
    
    <li ><a href="#method-i-abs">#abs</a>
    
    <li ><a href="#method-i-abs_dtype">#abs_dtype</a>
    
    <li ><a href="#method-i-absolute_sum">#absolute_sum</a>
    
    <li ><a href="#method-i-angle_vector">#angle_vector</a>
    
    <li ><a href="#method-i-asum">#asum</a>
    
    <li ><a href="#method-i-binned_sorted_indices">#binned_sorted_indices</a>
    
    <li ><a href="#method-i-capacity">#capacity</a>
    
    <li ><a href="#method-i-cast">#cast</a>
    
    <li ><a href="#method-i-cast_full">#cast_full</a>
    
    <li ><a href="#method-i-clone_structure">#clone_structure</a>
    
    <li ><a href="#method-i-col">#col</a>
    
    <li ><a href="#method-i-cols">#cols</a>
    
    <li ><a href="#method-i-column">#column</a>
    
    <li ><a href="#method-i-complex_conjugate">#complex_conjugate</a>
    
    <li ><a href="#method-i-complex_conjugate-21">#complex_conjugate!</a>
    
    <li ><a href="#method-i-complex_dtype-3F">#complex_dtype?</a>
    
    <li ><a href="#method-i-concat">#concat</a>
    
    <li ><a href="#method-i-conjugate_transpose">#conjugate_transpose</a>
    
    <li ><a href="#method-i-corr">#corr</a>
    
    <li ><a href="#method-i-cov">#cov</a>
    
    <li ><a href="#method-i-data_pointer">#data_pointer</a>
    
    <li ><a href="#method-i-dconcat">#dconcat</a>
    
    <li ><a href="#method-i-default_value">#default_value</a>
    
    <li ><a href="#method-i-dense-3F">#dense?</a>
    
    <li ><a href="#method-i-det">#det</a>
    
    <li ><a href="#method-i-det_exact">#det_exact</a>
    
    <li ><a href="#method-i-diagonal">#diagonal</a>
    
    <li ><a href="#method-i-dim">#dim</a>
    
    <li ><a href="#method-i-dimensions">#dimensions</a>
    
    <li ><a href="#method-i-dot">#dot</a>
    
    <li ><a href="#method-i-dtype">#dtype</a>
    
    <li ><a href="#method-i-dtype_for_floor_or_ceil">#dtype_for_floor_or_ceil</a>
    
    <li ><a href="#method-i-each">#each</a>
    
    <li ><a href="#method-i-each_along_dim">#each_along_dim</a>
    
    <li ><a href="#method-i-each_column">#each_column</a>
    
    <li ><a href="#method-i-each_layer">#each_layer</a>
    
    <li ><a href="#method-i-each_ordered_stored_with_indices">#each_ordered_stored_with_indices</a>
    
    <li ><a href="#method-i-each_rank">#each_rank</a>
    
    <li ><a href="#method-i-each_row">#each_row</a>
    
    <li ><a href="#method-i-each_stored_with_index">#each_stored_with_index</a>
    
    <li ><a href="#method-i-each_stored_with_indices">#each_stored_with_indices</a>
    
    <li ><a href="#method-i-each_with_indices">#each_with_indices</a>
    
    <li ><a href="#method-i-effective_dim">#effective_dim</a>
    
    <li ><a href="#method-i-effective_dimensions">#effective_dimensions</a>
    
    <li ><a href="#method-i-factorize_cholesky">#factorize_cholesky</a>
    
    <li ><a href="#method-i-factorize_lu">#factorize_lu</a>
    
    <li ><a href="#method-i-flat_map">#flat_map</a>
    
    <li ><a href="#method-i-float_dtype-3F">#float_dtype?</a>
    
    <li ><a href="#method-i-gesdd">#gesdd</a>
    
    <li ><a href="#method-i-gesdd-21">#gesdd!</a>
    
    <li ><a href="#method-i-gesvd">#gesvd</a>
    
    <li ><a href="#method-i-gesvd-21">#gesvd!</a>
    
    <li ><a href="#method-i-getrf-21">#getrf!</a>
    
    <li ><a href="#method-i-hconcat">#hconcat</a>
    
    <li ><a href="#method-i-hermitian-3F">#hermitian?</a>
    
    <li ><a href="#method-i-hessenberg">#hessenberg</a>
    
    <li ><a href="#method-i-hessenberg-21">#hessenberg!</a>
    
    <li ><a href="#method-i-index">#index</a>
    
    <li ><a href="#method-i-initialize_copy">#initialize_copy</a>
    
    <li class="calls-super" ><a href="#method-i-inject">#inject</a>
    
    <li ><a href="#method-i-inject_along_dim">#inject_along_dim</a>
    
    <li ><a href="#method-i-inject_rank">#inject_rank</a>
    
    <li ><a href="#method-i-integer_dtype-3F">#integer_dtype?</a>
    
    <li ><a href="#method-i-internal_dot">#internal_dot</a>
    
    <li ><a href="#method-i-inverse">#inverse</a>
    
    <li ><a href="#method-i-invert">#invert</a>
    
    <li ><a href="#method-i-invert-21">#invert!</a>
    
    <li ><a href="#method-i-is_ref-3F">#is_ref?</a>
    
    <li ><a href="#method-i-kron_prod">#kron_prod</a>
    
    <li ><a href="#method-i-laswp">#laswp</a>
    
    <li ><a href="#method-i-laswp-21">#laswp!</a>
    
    <li ><a href="#method-i-layer">#layer</a>
    
    <li ><a href="#method-i-list-3F">#list?</a>
    
    <li ><a href="#method-i-log">#log</a>
    
    <li ><a href="#method-i-lower_triangle">#lower_triangle</a>
    
    <li ><a href="#method-i-lower_triangle-21">#lower_triangle!</a>
    
    <li ><a href="#method-i-map">#map</a>
    
    <li ><a href="#method-i-map-21">#map!</a>
    
    <li ><a href="#method-i-map_stored">#map_stored</a>
    
    <li ><a href="#method-i-max">#max</a>
    
    <li ><a href="#method-i-mean">#mean</a>
    
    <li ><a href="#method-i-min">#min</a>
    
    <li ><a href="#method-i-norm2">#norm2</a>
    
    <li ><a href="#method-i-nrm2">#nrm2</a>
    
    <li ><a href="#method-i-nvector-3F">#nvector?</a>
    
    <li ><a href="#method-i-object_dtype-3F">#object_dtype?</a>
    
    <li ><a href="#method-i-offset">#offset</a>
    
    <li ><a href="#method-i-permute_columns">#permute_columns</a>
    
    <li ><a href="#method-i-permute_columns-21">#permute_columns!</a>
    
    <li ><a href="#method-i-potrf-21">#potrf!</a>
    
    <li ><a href="#method-i-potrf_lower-21">#potrf_lower!</a>
    
    <li ><a href="#method-i-potrf_upper-21">#potrf_upper!</a>
    
    <li ><a href="#method-i-pow">#pow</a>
    
    <li ><a href="#method-i-quaternion">#quaternion</a>
    
    <li ><a href="#method-i-rank">#rank</a>
    
    <li ><a href="#method-i-reduce_along_dim">#reduce_along_dim</a>
    
    <li ><a href="#method-i-repeat">#repeat</a>
    
    <li ><a href="#method-i-reshape">#reshape</a>
    
    <li ><a href="#method-i-reshape-21">#reshape!</a>
    
    <li ><a href="#method-i-round">#round</a>
    
    <li ><a href="#method-i-row">#row</a>
    
    <li ><a href="#method-i-rows">#rows</a>
    
    <li ><a href="#method-i-shape">#shape</a>
    
    <li ><a href="#method-i-shuffle">#shuffle</a>
    
    <li ><a href="#method-i-shuffle-21">#shuffle!</a>
    
    <li ><a href="#method-i-size">#size</a>
    
    <li ><a href="#method-i-slice">#slice</a>
    
    <li ><a href="#method-i-solve">#solve</a>
    
    <li ><a href="#method-i-sorted_indices">#sorted_indices</a>
    
    <li ><a href="#method-i-std">#std</a>
    
    <li ><a href="#method-i-stype">#stype</a>
    
    <li ><a href="#method-i-sum">#sum</a>
    
    <li ><a href="#method-i-supershape">#supershape</a>
    
    <li ><a href="#method-i-symmetric-3F">#symmetric?</a>
    
    <li ><a href="#method-i-to_a">#to_a</a>
    
    <li ><a href="#method-i-to_f">#to_f</a>
    
    <li ><a href="#method-i-to_flat_a">#to_flat_a</a>
    
    <li ><a href="#method-i-to_flat_array">#to_flat_array</a>
    
    <li ><a href="#method-i-to_h">#to_h</a>
    
    <li ><a href="#method-i-to_hash">#to_hash</a>
    
    <li ><a href="#method-i-trace">#trace</a>
    
    <li ><a href="#method-i-transpose">#transpose</a>
    
    <li ><a href="#method-i-tril">#tril</a>
    
    <li ><a href="#method-i-tril-21">#tril!</a>
    
    <li ><a href="#method-i-triu">#triu</a>
    
    <li ><a href="#method-i-triu-21">#triu!</a>
    
    <li ><a href="#method-i-upper_triangle">#upper_triangle</a>
    
    <li ><a href="#method-i-upper_triangle-21">#upper_triangle!</a>
    
    <li ><a href="#method-i-variance">#variance</a>
    
    <li ><a href="#method-i-vconcat">#vconcat</a>
    
    <li ><a href="#method-i-vector-3F">#vector?</a>
    
    <li ><a href="#method-i-write">#write</a>
    
    <li ><a href="#method-i-yale-3F">#yale?</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-NMatrix">
  <h1 id="class-NMatrix" class="class">
    class NMatrix
  </h1>

  <section class="description">
    
<p><a href="NMatrix.html">NMatrix</a> is a matrix class that supports both
multidimensional arrays (`:dense` stype) and sparse storage (`:list` or
`:yale` stypes) and 13 data types, including complex numbers, various
integer and floating-point sizes and ruby objects.</p>

  </section>

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    

    

    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

    
      <div id="method-c-5B-5D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            NMatrix[Numeric, ..., Numeric, dtype: Symbol] &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            NMatrix[Array, dtype: Symbol] &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>The default value for <code>dtype</code> is guessed from the first
parameter. For example:</p>

<pre class="ruby"><span class="ruby-constant">NMatrix</span>[<span class="ruby-value">1.0</span>, <span class="ruby-value">2.0</span>].<span class="ruby-identifier">dtype</span> <span class="ruby-comment"># =&gt; :float64</span>
</pre>

<p>But this is just a <strong>guess</strong>. If the other values can&#39;t be
converted to this dtype, a <code>TypeError</code> will be raised.</p>

<p>You can use the <code>N</code> constant in this way:</p>

<pre class="ruby"><span class="ruby-constant">N</span> = <span class="ruby-constant">NMatrix</span>
<span class="ruby-constant">N</span>[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>]
</pre>

<p><a href="NMatrix.html">NMatrix</a> needs to have a succinct way to create a
matrix by specifying the components directly. This is very useful for using
it as an advanced calculator, it is useful for learning how to use, for
testing language features and for developing algorithms.</p>

<p>The <a href="NMatrix.html#method-c-5B-5D">::[]</a> method provides a way to
create a matrix in a way that is compact and natural. The components are
specified using Ruby array syntax. Optionally, one can specify a dtype as
the last parameter (default is :float64).</p>

<p>Examples:</p>

<pre>a = N[ 1,2,3,4 ]          =&gt;  1  2  3  4

a = N[ 1,2,3,4, :int32 ]  =&gt;  1  2  3  4

a = N[ [1,2,3], [3,4,5] ] =&gt;  1.0  2.0  3.0
                              3.0  4.0  5.0

a = N[ 3,6,9 ].transpose =&gt; 3
                            6
                            9</pre>

<p>SYNTAX COMPARISON:</p>

<pre>MATLAB:         a = [ [1 2 3] ; [4 5 6] ]   or  [ 1 2 3 ; 4 5 6 ]
IDL:                    a = [ [1,2,3] , [4,5,6] ]
NumPy:          a = array( [1,2,3], [4,5,6] )

SciRuby:      a = NMatrix[ [1,2,3], [4,5,6] ]
Ruby array:   a =  [ [1,2,3], [4,5,6] ]</pre>
          
          

          
          <div class="method-source-code" id="5B-5D-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 100</span>
<span class="ruby-keyword">def</span> <span class="ruby-operator">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">params</span>)
  <span class="ruby-identifier">options</span> = <span class="ruby-identifier">params</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Hash</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">params</span>.<span class="ruby-identifier">pop</span> <span class="ruby-operator">:</span> {}

  <span class="ruby-comment"># First find the dimensions of the array.</span>
  <span class="ruby-identifier">i</span> = <span class="ruby-value">0</span>
  <span class="ruby-identifier">shape</span> = []
  <span class="ruby-identifier">row</span> = <span class="ruby-identifier">params</span>
  <span class="ruby-keyword">while</span> <span class="ruby-identifier">row</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>)
    <span class="ruby-identifier">shape</span>[<span class="ruby-identifier">i</span>] = <span class="ruby-identifier">row</span>.<span class="ruby-identifier">length</span>
    <span class="ruby-identifier">row</span> = <span class="ruby-identifier">row</span>[<span class="ruby-value">0</span>]
    <span class="ruby-identifier">i</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># A row vector should be stored as 1xN, not N</span>
  <span class="ruby-comment">#shape.unshift(1) if shape.size == 1</span>

  <span class="ruby-comment"># Then flatten the array.</span>
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">params</span>.<span class="ruby-identifier">flatten</span>, <span class="ruby-identifier">options</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-block_diag" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">block_diag</span><span
            class="method-args">(*params)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-c-block_diagonal">block_diagonal</a>
        </div>
        
      </div>

    
      <div id="method-c-block_diagonal" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">block_diagonal</span><span
            class="method-args">(*params)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Generate a block-diagonal <a href="NMatrix.html">NMatrix</a> from the
supplied 2D square matrices.</p>
<ul><li>
<p><strong>Arguments</strong></p>
<ul><li>
<p>+*params+ -&gt; An array that collects all arguments passed to the method.
The method</p>

<pre>can receive any number of arguments. Optionally, the last entry of +params+ is 
a hash of options from NMatrix#initialize. All other entries of +params+ are 
the blocks of the desired block-diagonal matrix. Each such matrix block can be 
supplied as a square 2D NMatrix object, or alternatively as an array of arrays 
(with dimensions corresponding to a square matrix), or alternatively as a number.</pre>
</li></ul>
</li><li>
<p><strong>Returns</strong></p>
<ul><li>
<p><a href="NMatrix.html">NMatrix</a> of block-diagonal form filled with
specified matrices as the blocks along the diagonal.</p>
</li></ul>
</li><li>
<p><strong>Example</strong></p>
</li></ul>

<pre>a = NMatrix.new([2,2], [1,2,3,4])
b = NMatrix.new([1,1], [123], dtype: :float64)
c = Array.new(2) { [[10,10], [10,10]] }
d = Array[[1,2,3], [4,5,6], [7,8,9]]
m = NMatrix.block_diagonal(a, b, *c, d, 10.0, 11, dtype: :int64, stype: :yale)
      =&gt; 
      [
        [1, 2,   0,  0,  0,  0,  0, 0, 0, 0,  0,  0]
        [3, 4,   0,  0,  0,  0,  0, 0, 0, 0,  0,  0]
        [0, 0, 123,  0,  0,  0,  0, 0, 0, 0,  0,  0]
        [0, 0,   0, 10, 10,  0,  0, 0, 0, 0,  0,  0]
        [0, 0,   0, 10, 10,  0,  0, 0, 0, 0,  0,  0]
        [0, 0,   0,  0,  0, 10, 10, 0, 0, 0,  0,  0]
        [0, 0,   0,  0,  0, 10, 10, 0, 0, 0,  0,  0]
        [0, 0,   0,  0,  0,  0,  0, 1, 2, 3,  0,  0]
        [0, 0,   0,  0,  0,  0,  0, 4, 5, 6,  0,  0]
        [0, 0,   0,  0,  0,  0,  0, 7, 8, 9,  0,  0]
        [0, 0,   0,  0,  0,  0,  0, 0, 0, 0, 10,  0]
        [0, 0,   0,  0,  0,  0,  0, 0, 0, 0,  0, 11]
      ]</pre>
          
          

          
          <div class="method-source-code" id="block_diagonal-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 313</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">block_diagonal</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">params</span>)
  <span class="ruby-identifier">options</span> = <span class="ruby-identifier">params</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Hash</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">params</span>.<span class="ruby-identifier">pop</span> <span class="ruby-operator">:</span> {}

  <span class="ruby-identifier">params</span>.<span class="ruby-identifier">each_index</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">params</span>[<span class="ruby-identifier">i</span>] = <span class="ruby-identifier">params</span>[<span class="ruby-identifier">i</span>].<span class="ruby-identifier">to_nm</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">params</span>[<span class="ruby-identifier">i</span>].<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>) <span class="ruby-comment"># Convert Array to NMatrix</span>
    <span class="ruby-identifier">params</span>[<span class="ruby-identifier">i</span>] = <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>([<span class="ruby-value">1</span>,<span class="ruby-value">1</span>], [<span class="ruby-identifier">params</span>[<span class="ruby-identifier">i</span>]]) <span class="ruby-keyword">if</span> <span class="ruby-identifier">params</span>[<span class="ruby-identifier">i</span>].<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Numeric</span>) <span class="ruby-comment"># Convert number to NMatrix</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">block_sizes</span> = [] <span class="ruby-comment">#holds the size of each matrix block</span>
  <span class="ruby-identifier">params</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">b</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">unless</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">NMatrix</span>)
      <span class="ruby-identifier">raise</span>(<span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&quot;Only NMatrix or appropriate Array objects or single numbers allowed&quot;</span>)
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">raise</span>(<span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&quot;Only 2D matrices or 2D arrays allowed&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">shape</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">==</span> <span class="ruby-value">2</span>
    <span class="ruby-identifier">raise</span>(<span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&quot;Only square-shaped blocks allowed&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>]
    <span class="ruby-identifier">block_sizes</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">block_diag_mat</span> = <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">zeros</span>(<span class="ruby-identifier">block_sizes</span>.<span class="ruby-identifier">sum</span>, <span class="ruby-identifier">options</span>)
  (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-identifier">params</span>.<span class="ruby-identifier">length</span>).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">n</span><span class="ruby-operator">|</span>
    <span class="ruby-comment"># First determine the size and position of the n&#39;th block in the block-diagonal matrix</span>
    <span class="ruby-identifier">block_size</span> = <span class="ruby-identifier">block_sizes</span>[<span class="ruby-identifier">n</span>]
    <span class="ruby-identifier">block_pos</span> = <span class="ruby-identifier">block_sizes</span>[<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-identifier">n</span>].<span class="ruby-identifier">sum</span>
    <span class="ruby-comment"># populate the n&#39;th block in the block-diagonal matrix</span>
    (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-identifier">block_size</span>).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
      (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-identifier">block_size</span>).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">j</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">block_diag_mat</span>[<span class="ruby-identifier">block_pos</span><span class="ruby-operator">+</span><span class="ruby-identifier">i</span>,<span class="ruby-identifier">block_pos</span><span class="ruby-operator">+</span><span class="ruby-identifier">j</span>] = <span class="ruby-identifier">params</span>[<span class="ruby-identifier">n</span>][<span class="ruby-identifier">i</span>,<span class="ruby-identifier">j</span>]
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">return</span> <span class="ruby-identifier">block_diag_mat</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-c-block_diag">block_diag</a>
        </div>
        

        
      </div>

    
      <div id="method-c-diag" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">diag</span><span
            class="method-args">(entries, opts={})</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-c-diagonal">diagonal</a>
        </div>
        
      </div>

    
      <div id="method-c-diagonal" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            diagonals(array) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            diagonals(array, dtype: dtype, stype: stype) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a matrix filled with specified diagonals.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>entries</code> -&gt; <a href="Array.html">Array</a> containing input
values for diagonal matrix</p>
</li><li>
<p><code>options</code> -&gt; (optional) Hash with options for
NMatrix#initialize</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p><a href="NMatrix.html">NMatrix</a> filled with specified diagonal values.</p>
</li></ul>
</li></ul>

<p>Examples:</p>

<pre>NMatrix.diagonal([1.0,2,3,4]) # =&gt; 1.0 0.0 0.0 0.0
                                   0.0 2.0 0.0 0.0
                                   0.0 0.0 3.0 0.0
                                   0.0 0.0 0.0 4.0

NMatrix.diagonal([1,2,3,4], dtype: :int32) # =&gt; 1 0 0 0
                                                0 2 0 0
                                                0 0 3 0
                                                0 0 0 4</pre>
          
          

          
          <div class="method-source-code" id="diagonal-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 265</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">diagonal</span>(<span class="ruby-identifier">entries</span>, <span class="ruby-identifier">opts</span>={})
  <span class="ruby-identifier">m</span> = <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">zeros</span>(<span class="ruby-identifier">entries</span>.<span class="ruby-identifier">size</span>,
                    {<span class="ruby-value">:dtype</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">guess_dtype</span>(<span class="ruby-identifier">entries</span>[<span class="ruby-value">0</span>]), <span class="ruby-value">:capacity</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">entries</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>}.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>)
                   )
  <span class="ruby-identifier">entries</span>.<span class="ruby-identifier">each_with_index</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">n</span>, <span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">m</span>[<span class="ruby-identifier">i</span>,<span class="ruby-identifier">i</span>] = <span class="ruby-identifier">n</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">m</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-c-diag">diag</a>, <a href="NMatrix.html#method-c-diagonals">diagonals</a>
        </div>
        

        
      </div>

    
      <div id="method-c-diagonals" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">diagonals</span><span
            class="method-args">(entries, opts={})</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-c-diagonal">diagonal</a>
        </div>
        
      </div>

    
      <div id="method-c-eye" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            eye(shape) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            eye(shape, dtype: dtype) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            eye(shape, stype: stype, dtype: dtype) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates an identity matrix (square matrix rank 2).</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>size</code> -&gt; <a href="Array.html">Array</a> (or integer for
square matrix) specifying the dimensions.</p>
</li><li>
<p><code>dtype</code> -&gt; (optional) Default is <code>:float64</code></p>
</li><li>
<p><code>stype</code> -&gt; (optional) Default is <code>:dense</code>.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>An identity matrix.</p>
</li></ul>
</li></ul>

<p>Examples:</p>

<pre>NMatrix.eye(3) # =&gt;   1.0   0.0   0.0
                      0.0   1.0   0.0
                      0.0   0.0   1.0

NMatrix.eye(3, dtype: :int32) # =&gt;   1   0   0
                                     0   1   0
                                     0   0   1

NMatrix.eye(2, dtype: :int32, stype: :yale) # =&gt;   1   0
                                                   0   1</pre>
          
          

          
          <div class="method-source-code" id="eye-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 229</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">eye</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">opts</span>={})
  <span class="ruby-comment"># Fill the diagonal with 1&#39;s.</span>
  <span class="ruby-identifier">m</span> = <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">zeros</span>(<span class="ruby-identifier">shape</span>, {<span class="ruby-value">:dtype</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">:float64</span>}.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>))
  (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-identifier">m</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">m</span>[<span class="ruby-identifier">i</span>, <span class="ruby-identifier">i</span>] = <span class="ruby-value">1</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">m</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-c-identity">identity</a>
        </div>
        

        
      </div>

    
      <div id="method-c-guess_dtype" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">guess_dtype</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Guess the dtype given a Ruby VALUE and return it as a symbol.</p>

<p>Not to be confused with nm_dtype_guess, which returns an nm::dtype_t. (This
calls that.)</p>
          
          

          
          <div class="method-source-code" id="guess_dtype-source">
            <pre>static VALUE nm_guess_dtype(VALUE self, VALUE v) {
  return ID2SYM(rb_intern(DTYPE_NAMES[nm_dtype_guess(v)]));
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-identity" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">identity</span><span
            class="method-args">(shape, opts={})</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-c-eye">eye</a>
        </div>
        
      </div>

    
      <div id="method-c-load_matlab_file" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            load_matlab_file(path) &rarr; Mat5Reader
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>file_path</code> -&gt; The path to a version 5 .mat file.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>A Mat5Reader object.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="load_matlab_file-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 88</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">load_matlab_file</span>(<span class="ruby-identifier">file_path</span>)
  <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">IO</span><span class="ruby-operator">::</span><span class="ruby-constant">Mat5Reader</span>.<span class="ruby-identifier">new</span>(<span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-identifier">file_path</span>, <span class="ruby-string">&#39;rb&#39;</span>)).<span class="ruby-identifier">to_ruby</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-load_pcd_file" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            load_pcd_file(path) &rarr; PointCloudReader::MetaReader
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>file_path</code> -&gt; The path to a PCL PCD file.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>A PointCloudReader::MetaReader object with the matrix stored in its
<code>matrix</code> property</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="load_pcd_file-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 99</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">load_pcd_file</span>(<span class="ruby-identifier">file_path</span>)
  <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">IO</span><span class="ruby-operator">::</span><span class="ruby-constant">PointCloudReader</span><span class="ruby-operator">::</span><span class="ruby-constant">MetaReader</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">file_path</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-meshgrid" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            meshgrid(arrs) &rarr; Array of NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            meshgrid(arrs, options) &rarr; Array of NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Make N-D coordinate arrays for vectorized evaluations of N-D scalar/vector
fields over N-D grids, given <a href="N.html">N</a> coordinate arrays arrs.
<a href="N.html">N</a> &gt; 1.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>vectors</code> -&gt; <a href="Array.html">Array</a> of <a
href="N.html">N</a> coordinate arrays (Array or <a
href="NMatrix.html">NMatrix</a>), if any have more than one dimension they
will be flatten</p>
</li><li>
<p><code>options</code> -&gt; Hash with options (:sparse Boolean, false by
default; :indexing Symbol, may be :ij or :xy, :xy by default)</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p><a href="Array.html">Array</a> of <a href="N.html">N</a> N-D NMatrixes</p>
</li></ul>
</li><li>
<p><strong>Examples</strong> :</p>

<pre class="ruby"><span class="ruby-identifier">x</span>, <span class="ruby-identifier">y</span> = <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-identifier">meshgrid</span>([[<span class="ruby-value">1</span>, [<span class="ruby-value">2</span>, <span class="ruby-value">3</span>]], [<span class="ruby-value">4</span>, <span class="ruby-value">5</span>]])
<span class="ruby-identifier">x</span>.<span class="ruby-identifier">to_a</span> <span class="ruby-comment">#&lt;= [[1, 2, 3], [1, 2, 3]]</span>
<span class="ruby-identifier">y</span>.<span class="ruby-identifier">to_a</span> <span class="ruby-comment">#&lt;= [[4, 4, 4], [5, 5, 5]]</span>
</pre>
</li><li>
<p><strong>Using</strong> <strong>options</strong> :</p>

<pre class="ruby"><span class="ruby-identifier">x</span>, <span class="ruby-identifier">y</span> = <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-identifier">meshgrid</span>([[[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>], <span class="ruby-value">3</span>], [<span class="ruby-value">4</span>, <span class="ruby-value">5</span>]], <span class="ruby-identifier">sparse</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>)
<span class="ruby-identifier">x</span>.<span class="ruby-identifier">to_a</span> <span class="ruby-comment">#&lt;= [[1, 2, 3]]</span>
<span class="ruby-identifier">y</span>.<span class="ruby-identifier">to_a</span> <span class="ruby-comment">#&lt;= [[4], [5]]</span>

<span class="ruby-identifier">x</span>, <span class="ruby-identifier">y</span> = <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-identifier">meshgrid</span>([[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>], [[<span class="ruby-value">4</span>], <span class="ruby-value">5</span>]], <span class="ruby-identifier">indexing</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">ij</span>)
<span class="ruby-identifier">x</span>.<span class="ruby-identifier">to_a</span> <span class="ruby-comment">#&lt;= [[1, 1], [2, 2], [3, 3]]</span>
<span class="ruby-identifier">y</span>.<span class="ruby-identifier">to_a</span> <span class="ruby-comment">#&lt;= [[4, 5], [4, 5], [4, 5]]</span>
</pre>
</li></ul>
          
          

          
          <div class="method-source-code" id="meshgrid-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 136</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">meshgrid</span>(<span class="ruby-identifier">vectors</span>, <span class="ruby-identifier">options</span> = {})
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&#39;Expected at least 2 arrays.&#39;</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">vectors</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">2</span>
  <span class="ruby-identifier">options</span>[<span class="ruby-value">:indexing</span>] <span class="ruby-operator">||=</span> <span class="ruby-value">:xy</span>
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&#39;Indexing must be :xy of :ij&#39;</span>) <span class="ruby-keyword">unless</span> [<span class="ruby-value">:ij</span>, <span class="ruby-value">:xy</span>].<span class="ruby-identifier">include?</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:indexing</span>]
  <span class="ruby-identifier">mats</span> = <span class="ruby-identifier">vectors</span>.<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">arr</span><span class="ruby-operator">|</span> <span class="ruby-identifier">arr</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:flatten</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">arr</span>.<span class="ruby-identifier">flatten</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">arr</span>.<span class="ruby-identifier">to_flat_array</span> }
  <span class="ruby-identifier">mats</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">mats</span>[<span class="ruby-value">1</span>] = <span class="ruby-identifier">mats</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">mats</span>[<span class="ruby-value">0</span>] <span class="ruby-keyword">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:indexing</span>] <span class="ruby-operator">==</span> <span class="ruby-value">:xy</span>
  <span class="ruby-identifier">new_dim</span> = <span class="ruby-identifier">mats</span>.<span class="ruby-identifier">size</span>
  <span class="ruby-identifier">lengths</span> = <span class="ruby-identifier">mats</span>.<span class="ruby-identifier">map</span>(<span class="ruby-operator">&amp;</span><span class="ruby-value">:size</span>)
  <span class="ruby-identifier">result</span> = <span class="ruby-identifier">mats</span>.<span class="ruby-identifier">map</span>.<span class="ruby-identifier">with_index</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">matrix</span>, <span class="ruby-identifier">axis</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:sparse</span>]
      <span class="ruby-identifier">new_shape</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">new_dim</span>, <span class="ruby-value">1</span>)
      <span class="ruby-identifier">new_shape</span>[<span class="ruby-identifier">axis</span>] = <span class="ruby-identifier">lengths</span>[<span class="ruby-identifier">axis</span>]
      <span class="ruby-identifier">new_elements</span> = <span class="ruby-identifier">matrix</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">before_axis</span> = <span class="ruby-identifier">lengths</span>[<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-identifier">axis</span>].<span class="ruby-identifier">reduce</span>(<span class="ruby-value">:*</span>)
      <span class="ruby-identifier">after_axis</span> = <span class="ruby-identifier">lengths</span>[(<span class="ruby-identifier">axis</span><span class="ruby-operator">+</span><span class="ruby-value">1</span>)<span class="ruby-operator">..</span><span class="ruby-value">-1</span>].<span class="ruby-identifier">reduce</span>(<span class="ruby-value">:*</span>)
      <span class="ruby-identifier">new_shape</span> = <span class="ruby-identifier">lengths</span>
      <span class="ruby-identifier">new_elements</span> = <span class="ruby-identifier">after_axis</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">matrix</span>.<span class="ruby-identifier">map</span>{ <span class="ruby-operator">|</span><span class="ruby-identifier">el</span><span class="ruby-operator">|</span> [<span class="ruby-identifier">el</span>] <span class="ruby-operator">*</span> <span class="ruby-identifier">after_axis</span> }.<span class="ruby-identifier">flatten</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">matrix</span>
      <span class="ruby-identifier">new_elements</span> <span class="ruby-operator">*=</span> <span class="ruby-identifier">before_axis</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">before_axis</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">new_shape</span>, <span class="ruby-identifier">new_elements</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">result</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">result</span>[<span class="ruby-value">1</span>] = <span class="ruby-identifier">result</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">result</span>[<span class="ruby-value">0</span>] <span class="ruby-keyword">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:indexing</span>] <span class="ruby-operator">==</span> <span class="ruby-value">:xy</span>
  <span class="ruby-identifier">result</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-min_dtype" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">min_dtype</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Get the minimum allowable dtype for a Ruby VALUE and return it as a symbol.</p>
          
          

          
          <div class="method-source-code" id="min_dtype-source">
            <pre>static VALUE nm_min_dtype(VALUE self, VALUE v) {
  return ID2SYM(rb_intern(DTYPE_NAMES[nm_dtype_min(v)]));
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-new" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            new(shape) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            new(shape, initial_value) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            new(shape, initial_array) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            new(shape, initial_value, options) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            new(shape, initial_array, options) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Create a new <a href="NMatrix.html">NMatrix</a>.</p>

<p>The only mandatory argument is shape, which may be a positive integer or an
array of positive integers.</p>

<p>It is recommended that you supply an initialization value or array of
values. Without one, Yale and List matrices will be initialized to 0; and
dense matrices will be undefined.</p>

<p>Additional options may be provided using keyword arguments. The keywords
are +:dtype, <code>:stype</code>, <code>:capacity</code>, and
<code>:default</code>. Only Yale uses a capacity argument, which is used to
reserve the initial size of its storage vectors. List and Yale both accept
a default value (which itself defaults to 0). This default is taken from
the initial value if such a value is given; it is more likely to be
required when an initial array is provided.</p>

<p>The storage type, or stype, is used to specify whether we want a
<code>:dense</code>, <code>:list</code>, or <code>:yale</code> matrix;
dense is the default.</p>

<p>The data type, or dtype, can be one of: :byte, :int8, :int16, :int32,
:int64, :float32, :float64, :complex64, :complex128, or :object. The
constructor will attempt to guess it from the initial value/array/default
provided, if any. Otherwise, the default is :object, which stores any type
of Ruby object.</p>

<p>In addition to the above, there is a legacy constructor from the alpha
version. To use that version, you must be providing exactly four arguments.
It is now deprecated.</p>

<p>There is one additional constructor for advanced users, which takes seven
arguments and is only for creating Yale matrices with known IA, JA, and A
arrays. This is used primarily internally for IO, e.g., reading Matlab
matrices, which are stored in old Yale (not our Yale) format. But be
careful; there are no overflow warnings. All of these constructors are
defined for power-users. Everyone else should probably resort to the
shortcut functions defined in shortcuts.rb.</p>
          
          

          
          <div class="method-source-code" id="new-source">
            <pre>static VALUE nm_init(int argc, VALUE* argv, VALUE nm) {
  NM_CONSERVATIVE(nm_register_value(&amp;nm));
  NM_CONSERVATIVE(nm_register_values(argv, argc));

  if (argc &lt;= 3) { // Call the new constructor unless all four arguments are given (or the 7-arg version is given)
    NM_CONSERVATIVE(nm_unregister_values(argv, argc));
    NM_CONSERVATIVE(nm_unregister_value(&amp;nm));
        return nm_init_new_version(argc, argv, nm);
  }

  /* First, determine stype (dense by default) */
  nm::stype_t stype;
  size_t  offset = 0;

  if (!SYMBOL_P(argv[0]) &amp;&amp; TYPE(argv[0]) != T_STRING) {
    stype = nm::DENSE_STORE;

  } else {
    // 0: String or Symbol
    stype  = interpret_stype(argv[0]);
    offset = 1;
  }

  // If there are 7 arguments and Yale, refer to a different init function with fewer sanity checks.
  if (argc == 7) {
    if (stype == nm::YALE_STORE) {
      NM_CONSERVATIVE(nm_unregister_values(argv, argc));
      NM_CONSERVATIVE(nm_unregister_value(&amp;nm));
      return nm_init_yale_from_old_yale(argv[1], argv[2], argv[3], argv[4], argv[5], argv[6], nm);

    } else {
      NM_CONSERVATIVE(nm_unregister_values(argv, argc));
      NM_CONSERVATIVE(nm_unregister_value(&amp;nm));
      rb_raise(rb_eArgError, &quot;Expected 2-4 arguments (or 7 for internal Yale creation)&quot;);
    }
  }

  // 1: Array or Fixnum
  size_t dim;
  size_t* shape = interpret_shape(argv[offset], &amp;dim);

  // 2-3: dtype
  nm::dtype_t dtype = interpret_dtype(argc-1-offset, argv+offset+1, stype);

  size_t init_cap = 0, init_val_len = 0;
  void* init_val  = NULL;
  if (!SYMBOL_P(argv[1+offset]) || TYPE(argv[1+offset]) == T_ARRAY) {
        // Initial value provided (could also be initial capacity, if yale).

    if (stype == nm::YALE_STORE &amp;&amp; NM_RUBYVAL_IS_NUMERIC(argv[1+offset])) {
      init_cap = FIX2UINT(argv[1+offset]);

    } else {
        // 4: initial value / dtype
      init_val = interpret_initial_value(argv[1+offset], dtype);

      if (TYPE(argv[1+offset]) == T_ARRAY)      init_val_len = RARRAY_LEN(argv[1+offset]);
      else                                  init_val_len = 1;
    }

  } else {
        // DType is RUBYOBJ.

    if (stype == nm::DENSE_STORE) {
        /*
         * No need to initialize dense with any kind of default value unless it&#39;s
         * an RUBYOBJ matrix.
         */
      if (dtype == nm::RUBYOBJ) {
        // Pretend [nil] was passed for RUBYOBJ.
        init_val = NM_ALLOC(VALUE);
        *(VALUE*)init_val = Qnil;

        init_val_len = 1;

      } else {
        init_val = NULL;
      }
    } else if (stype == nm::LIST_STORE) {
      init_val = NM_ALLOC_N(char, DTYPE_SIZES[dtype]);
      std::memset(init_val, 0, DTYPE_SIZES[dtype]);
    }
  }

  if (dtype == nm::RUBYOBJ) {
    nm_register_values(reinterpret_cast&lt;VALUE*&gt;(init_val), init_val_len);
  }

  // TODO: Update to allow an array as the initial value.
  NMATRIX* nmatrix;
  UnwrapNMatrix(nm, nmatrix);

  nmatrix-&gt;stype = stype;

  switch (stype) {
    case nm::DENSE_STORE:
      nmatrix-&gt;storage = (STORAGE*)nm_dense_storage_create(dtype, shape, dim, init_val, init_val_len);
      break;

    case nm::LIST_STORE:
      nmatrix-&gt;storage = (STORAGE*)nm_list_storage_create(dtype, shape, dim, init_val);
      break;

    case nm::YALE_STORE:
      nmatrix-&gt;storage = (STORAGE*)nm_yale_storage_create(dtype, shape, dim, init_cap);
      nm_yale_storage_init((YALE_STORAGE*)(nmatrix-&gt;storage), NULL);
      break;
  }

  if (dtype == nm::RUBYOBJ) {
    nm_unregister_values(reinterpret_cast&lt;VALUE*&gt;(init_val), init_val_len);
  }

  NM_CONSERVATIVE(nm_unregister_values(argv, argc));
  NM_CONSERVATIVE(nm_unregister_value(&amp;nm));

  return nm;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-ones" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            ones(shape) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            ones(shape, dtype: dtype, stype: stype) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a matrix filled with ones.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>shape</code> -&gt; <a href="Array.html">Array</a> (or integer for
square matrix) specifying the shape.</p>
</li><li>
<p><code>opts</code> -&gt; (optional) Hash of options from NMatrix#initialize</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p><a href="NMatrix.html">NMatrix</a> filled with ones.</p>
</li></ul>
</li></ul>

<p>Examples:</p>

<pre>NMatrix.ones([1, 3]) # =&gt;  1.0   1.0   1.0

NMatrix.ones([2, 3], dtype: :int32) # =&gt;  1  1  1
                                          1  1  1</pre>
          
          

          
          <div class="method-source-code" id="ones-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 171</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">ones</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">opts</span>={})
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-value">1</span>, {<span class="ruby-value">:dtype</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">:float64</span>, <span class="ruby-value">:default</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>}.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>))
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-ones_like" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            ones_like(nm) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a new matrix of ones with the same dtype and shape as the provided
matrix.</p>

<p>@param [NMatrix] nm the nmatrix whose dtype and shape will be used @return
[NMatrix] a new nmatrix filled with ones.</p>
          
          

          
          <div class="method-source-code" id="ones_like-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 184</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">ones_like</span>(<span class="ruby-identifier">nm</span>)
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">ones</span>(<span class="ruby-identifier">nm</span>.<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-identifier">nm</span>.<span class="ruby-identifier">dtype</span>, <span class="ruby-identifier">stype</span><span class="ruby-operator">:</span> <span class="ruby-identifier">nm</span>.<span class="ruby-identifier">stype</span>, <span class="ruby-identifier">capacity</span><span class="ruby-operator">:</span> <span class="ruby-identifier">nm</span>.<span class="ruby-identifier">capacity</span>, <span class="ruby-identifier">default</span><span class="ruby-operator">:</span> <span class="ruby-value">1</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-rand" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">rand</span><span
            class="method-args">(shape, opts={})</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-c-random">random</a>
        </div>
        
      </div>

    
      <div id="method-c-random" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            random(shape) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a <code>:dense</code> <a href="NMatrix.html">NMatrix</a> with
random numbers between 0 and 1 generated by <code>Random::rand</code>. The
parameter is the dimension of the matrix.</p>

<p>If you use an integer dtype, make sure to specify :scale as a parameter, or
you&#39;ll only get a matrix of 0s.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>shape</code> -&gt; <a href="Array.html">Array</a> (or integer for
square matrix) specifying the dimensions.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p><a href="NMatrix.html">NMatrix</a> filled with random values.</p>
</li></ul>
</li></ul>

<p>Examples:</p>

<pre>NMatrix.random([2, 2]) # =&gt; 0.4859439730644226   0.1783195585012436
                            0.23193766176700592  0.4503345191478729

NMatrix.random([2, 2], :dtype =&gt; :byte, :scale =&gt; 255) # =&gt; [ [252, 108] [44, 12] ]</pre>
          
          

          
          <div class="method-source-code" id="random-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 370</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">random</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">opts</span>={})
  <span class="ruby-identifier">scale</span> = <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:scale</span>) <span class="ruby-operator">||</span> <span class="ruby-value">1.0</span>

  <span class="ruby-identifier">rng</span> = <span class="ruby-constant">Random</span>.<span class="ruby-identifier">new</span>

  <span class="ruby-identifier">random_values</span> = []


  <span class="ruby-comment"># Construct the values of the final matrix based on the dimension.</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:dtype</span>] <span class="ruby-operator">==</span> <span class="ruby-value">:complex64</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:dtype</span>] <span class="ruby-operator">==</span> <span class="ruby-value">:complex128</span>
    <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">size</span>(<span class="ruby-identifier">shape</span>).<span class="ruby-identifier">times</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">random_values</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">Complex</span>(<span class="ruby-identifier">rng</span>.<span class="ruby-identifier">rand</span>(<span class="ruby-identifier">scale</span>), <span class="ruby-identifier">rng</span>.<span class="ruby-identifier">rand</span>(<span class="ruby-identifier">scale</span>)) }
  <span class="ruby-keyword">else</span>
    <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">size</span>(<span class="ruby-identifier">shape</span>).<span class="ruby-identifier">times</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">random_values</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">rng</span>.<span class="ruby-identifier">rand</span>(<span class="ruby-identifier">scale</span>) }
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">random_values</span>, {<span class="ruby-value">:dtype</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">:float64</span>, <span class="ruby-value">:stype</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">:dense</span>}.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>))
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-c-rand">rand</a>
        </div>
        

        
      </div>

    
      <div id="method-c-read" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">read</span><span
            class="method-args">(p1, p2 = v2)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Binary file reader for <a href="NMatrix.html">NMatrix</a> standard format.
file should be a path, which we aren&#39;t going to check very carefully
(in other words, this function should generally be called from a Ruby
helper method).</p>

<p>Note that currently, this function will by default refuse to read files
that are newer than your version of <a href="NMatrix.html">NMatrix</a>. To
force an override, set the second argument to anything other than nil.</p>

<p>Returns an <a href="NMatrix.html">NMatrix</a> Ruby object.</p>
          
          

          
          <div class="method-source-code" id="read-source">
            <pre>static VALUE nm_read(int argc, VALUE* argv, VALUE self) {
  using std::ifstream;

  NM_CONSERVATIVE(nm_register_values(argv, argc));
  NM_CONSERVATIVE(nm_register_value(&amp;self));

  VALUE file, force_;

  // Read the arguments
  rb_scan_args(argc, argv, &quot;11&quot;, &amp;file, &amp;force_);
  bool force   = (force_ != Qnil &amp;&amp; force_ != Qfalse);


  if (!RB_FILE_EXISTS(file)) { // FIXME: Errno::ENOENT
    NM_CONSERVATIVE(nm_unregister_values(argv, argc));
    NM_CONSERVATIVE(nm_unregister_value(&amp;self));
    rb_raise(rb_get_errno_exc(&quot;ENOENT&quot;), &quot;%s&quot;, RSTRING_PTR(file));
  }

  // Open a file stream
  ifstream f(RSTRING_PTR(file), std::ios::in | std::ios::binary);

  uint16_t major, minor, release;
  get_version_info(major, minor, release); // compare to NMatrix version

  uint16_t fmajor, fminor, frelease, null16;

  // READ FIRST 64-BIT BLOCK
  f.read(reinterpret_cast&lt;char*&gt;(&amp;fmajor),   sizeof(uint16_t));
  f.read(reinterpret_cast&lt;char*&gt;(&amp;fminor),   sizeof(uint16_t));
  f.read(reinterpret_cast&lt;char*&gt;(&amp;frelease), sizeof(uint16_t));
  f.read(reinterpret_cast&lt;char*&gt;(&amp;null16),   sizeof(uint16_t));

  int ver  = major * 10000 + minor * 100 + release,
      fver = fmajor * 10000 + fminor * 100 + release;
  if (fver &gt; ver &amp;&amp; force == false) {
    NM_CONSERVATIVE(nm_unregister_values(argv, argc));
    NM_CONSERVATIVE(nm_unregister_value(&amp;self));
    rb_raise(rb_eIOError, &quot;File was created in newer version of NMatrix than current (%u.%u.%u)&quot;, fmajor, fminor, frelease);
  }
  if (null16 != 0) rb_warn(&quot;nm_read: Expected zero padding was not zero (0)\n&quot;);

  uint8_t dt, st, it, sm;
  uint16_t dim;

  // READ SECOND 64-BIT BLOCK
  f.read(reinterpret_cast&lt;char*&gt;(&amp;dt), sizeof(uint8_t));
  f.read(reinterpret_cast&lt;char*&gt;(&amp;st), sizeof(uint8_t));
  f.read(reinterpret_cast&lt;char*&gt;(&amp;it), sizeof(uint8_t)); // FIXME: should tell how few bytes indices are stored as
  f.read(reinterpret_cast&lt;char*&gt;(&amp;sm), sizeof(uint8_t));
  f.read(reinterpret_cast&lt;char*&gt;(&amp;null16), sizeof(uint16_t));
  f.read(reinterpret_cast&lt;char*&gt;(&amp;dim), sizeof(uint16_t));

  if (null16 != 0) rb_warn(&quot;nm_read: Expected zero padding was not zero (1)&quot;);
  nm::stype_t stype = static_cast&lt;nm::stype_t&gt;(st);
  nm::dtype_t dtype = static_cast&lt;nm::dtype_t&gt;(dt);
  nm::symm_t  symm  = static_cast&lt;nm::symm_t&gt;(sm);
  //nm::itype_t itype = static_cast&lt;nm::itype_t&gt;(it);

  // READ NEXT FEW 64-BIT BLOCKS
  size_t* shape = NM_ALLOC_N(size_t, dim);
  read_padded_shape(f, dim, shape);

  STORAGE* s;
  if (stype == nm::DENSE_STORE) {
    s = nm_dense_storage_create(dtype, shape, dim, NULL, 0);
    nm_register_storage(stype, s);

    read_padded_dense_elements(f, reinterpret_cast&lt;DENSE_STORAGE*&gt;(s), symm, dtype);

  } else if (stype == nm::YALE_STORE) {
    uint32_t ndnz, length;

    // READ YALE-SPECIFIC 64-BIT BLOCK
    f.read(reinterpret_cast&lt;char*&gt;(&amp;ndnz),     sizeof(uint32_t));
    f.read(reinterpret_cast&lt;char*&gt;(&amp;length),   sizeof(uint32_t));

    s = nm_yale_storage_create(dtype, shape, dim, length); // set length as init capacity

    nm_register_storage(stype, s);

    read_padded_yale_elements(f, reinterpret_cast&lt;YALE_STORAGE*&gt;(s), length, symm, dtype);
  } else {
    NM_CONSERVATIVE(nm_unregister_values(argv, argc));
    NM_CONSERVATIVE(nm_unregister_value(&amp;self));
    rb_raise(nm_eStorageTypeError, &quot;please convert to yale or dense before saving&quot;);
  }

  NMATRIX* nm = nm_create(stype, s);

  // Return the appropriate matrix object (Ruby VALUE)
  // FIXME: This should probably return CLASS_OF(self) instead of cNMatrix, but I don&#39;t know how that works for
  // FIXME: class methods.
  nm_register_nmatrix(nm);
  VALUE to_return = Data_Wrap_Struct(cNMatrix, nm_mark, nm_delete, nm);

  nm_unregister_nmatrix(nm);
  NM_CONSERVATIVE(nm_unregister_values(argv, argc));
  NM_CONSERVATIVE(nm_unregister_value(&amp;self));
  nm_unregister_storage(stype, s);

  switch(stype) {
  case nm::DENSE_STORE:
  case nm::YALE_STORE:
    return to_return;
  default: // this case never occurs (due to earlier rb_raise)
    return Qnil;
  }

}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-register_lapack_extension" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">register_lapack_extension</span><span
            class="method-args">(name)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="register_lapack_extension-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/lapack_ext_common.rb, line 30</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">register_lapack_extension</span>(<span class="ruby-identifier">name</span>)
  <span class="ruby-keyword">if</span> (<span class="ruby-keyword">defined?</span> <span class="ruby-identifier">@@lapack_extension</span>)
    <span class="ruby-identifier">raise</span> <span class="ruby-node">&quot;Attempting to load #{name} when #{@@lapack_extension} is already loaded. You can only load one LAPACK extension.&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">@@lapack_extension</span> = <span class="ruby-identifier">name</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-seq" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            seq(shape) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            seq(shape, options) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            bindgen(shape) &rarr; NMatrix of :byte
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            indgen(shape) &rarr; NMatrix of :int64
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            findgen(shape) &rarr; NMatrix of :float32
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            dindgen(shape) &rarr; NMatrix of :float64
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            cindgen(shape) &rarr; NMatrix of :complex64
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            zindgen(shape) &rarr; NMatrix of :complex128
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            rbindgen(shape) &rarr; NMatrix of :object
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a matrix filled with a sequence of integers starting at zero.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>shape</code> -&gt; <a href="Array.html">Array</a> (or integer for
square matrix) specifying the dimensions.</p>
</li><li>
<p><code>options</code> -&gt; (optional) Options permissible for
NMatrix#initialize</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p><a href="NMatrix.html">NMatrix</a> filled with values 0 through
<code>size</code>.</p>
</li></ul>
</li></ul>

<p>Examples:</p>

<pre>NMatrix.seq(2) # =&gt;   0   1
              2   3

NMatrix.seq([3, 3], dtype: :float32) # =&gt;  0.0  1.0  2.0
                                    3.0  4.0  5.0
                                    6.0  7.0  8.0</pre>
          
          

          
          <div class="method-source-code" id="seq-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 418</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">seq</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">options</span>={})

  <span class="ruby-comment"># Construct the values of the final matrix based on the dimension.</span>
  <span class="ruby-identifier">values</span> = (<span class="ruby-value">0</span> <span class="ruby-operator">...</span> <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">size</span>(<span class="ruby-identifier">shape</span>)).<span class="ruby-identifier">to_a</span>

  <span class="ruby-comment"># It&#39;ll produce :int32, except if a dtype is provided.</span>
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">values</span>, {<span class="ruby-value">:stype</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">:dense</span>}.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">options</span>))
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-size" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">size</span><span
            class="method-args">(shape)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Calculate the size of an <a href="NMatrix.html">NMatrix</a> of a given
shape.</p>
          
          

          
          <div class="method-source-code" id="size-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 104</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">size</span>(<span class="ruby-identifier">shape</span>)
  <span class="ruby-identifier">shape</span> = [<span class="ruby-identifier">shape</span>,<span class="ruby-identifier">shape</span>] <span class="ruby-keyword">unless</span> <span class="ruby-identifier">shape</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>)
  (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-identifier">shape</span>.<span class="ruby-identifier">size</span>).<span class="ruby-identifier">inject</span>(<span class="ruby-value">1</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span>,<span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">*</span> <span class="ruby-identifier">shape</span>[<span class="ruby-identifier">i</span>] }
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-translation" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            translation(x, y, z) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            translation([x,y,z]) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            translation(translation_matrix) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            translation(translation_matrix) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            translation(translation, dtype: dtype) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            translation(x, y, z, dtype: dtype) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Generate a 4x4 homogeneous transformation matrix representing a
translation.</p>
<ul><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>A homogeneous transformation matrix consisting of a translation.</p>
</li></ul>
</li></ul>

<p>Examples:</p>

<pre>NMatrix.translation(4.0,5.0,6.0) # =&gt;
                                      1.0   0.0   0.0   4.0
                                      0.0   1.0   0.0   5.0
                                      0.0   0.0   1.0   6.0
                                      0.0   0.0   0.0   1.0

NMatrix.translation(4.0,5.0,6.0, dtype: :int64) # =&gt;
                                                     1  0  0  4
                                                     0  1  0  5
                                                     0  0  1  6
                                                     0  0  0  1
NMatrix.translation(4,5,6) # =&gt;
                                 1  0  0  4
                                 0  1  0  5
                                 0  0  1  6
                                 0  0  0  1</pre>
          
          

          
          <div class="method-source-code" id="translation-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/homogeneous.rb, line 127</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">translation</span> <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>
  <span class="ruby-identifier">xyz</span> = <span class="ruby-identifier">args</span>.<span class="ruby-identifier">shift</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">NMatrix</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>)
  <span class="ruby-identifier">default_dtype</span> = <span class="ruby-identifier">xyz</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-value">:dtype</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">xyz</span>.<span class="ruby-identifier">dtype</span> <span class="ruby-operator">:</span> <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">guess_dtype</span>(<span class="ruby-identifier">xyz</span>)
  <span class="ruby-identifier">opts</span> = {<span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-identifier">default_dtype</span>}
  <span class="ruby-identifier">opts</span> = <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">args</span>.<span class="ruby-identifier">pop</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Hash</span>)
  <span class="ruby-identifier">xyz</span> <span class="ruby-operator">||=</span> <span class="ruby-identifier">args</span>

  <span class="ruby-identifier">n</span> = <span class="ruby-keyword">if</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
    <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">eye</span>(<span class="ruby-value">4</span>, <span class="ruby-identifier">opts</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">eye</span>(<span class="ruby-value">4</span>, <span class="ruby-identifier">opts</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">n</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>,<span class="ruby-value">3</span>] = <span class="ruby-identifier">xyz</span>
  <span class="ruby-identifier">n</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-upcast" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            upcast(first_dtype, second_dtype) &rarr; Symbol
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Given a binary operation between types t1 and t2, what type will be
returned?</p>

<p>This is a singleton method on <a href="NMatrix.html">NMatrix</a>, e.g., <a
href="NMatrix.html#method-c-upcast">::upcast</a>(:int32, :int64)</p>
          
          

          
          <div class="method-source-code" id="upcast-source">
            <pre>static VALUE nm_upcast(VALUE self, VALUE t1, VALUE t2) {
  nm::dtype_t d1    = nm_dtype_from_rbsymbol(t1),
              d2    = nm_dtype_from_rbsymbol(t2);

  return ID2SYM(rb_intern( DTYPE_NAMES[ Upcast[d1][d2] ] ));
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-x_rotation" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            x_rotation(angle_in_radians) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            x_rotation(angle_in_radians, dtype: dtype) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            y_rotation(angle_in_radians) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            y_rotation(angle_in_radians, dtype: dtype) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            z_rotation(angle_in_radians) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            z_rotation(angle_in_radians, dtype: dtype) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Generate a 4x4 homogeneous transformation matrix representing a rotation
about the x, y, or z axis respectively.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>angle_in_radians</code> -&gt; The angle of rotation in radians.</p>
</li><li>
<p><code>dtype</code> -&gt; (optional) Default is <code>:float64</code></p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>A homogeneous transformation matrix consisting of a single rotation.</p>
</li></ul>
</li></ul>

<p>Examples:</p>

<pre>NMatrix.x_rotation(Math::PI.quo(6)) # =&gt;
                                          1.0      0.0       0.0       0.0
                                          0.0      0.866025 -0.499999  0.0
                                          0.0      0.499999  0.866025  0.0
                                          0.0      0.0       0.0       1.0

NMatrix.x_rotation(Math::PI.quo(6), dtype: :float32) # =&gt;
                                          1.0      0.0       0.0       0.0
                                          0.0      0.866025 -0.5       0.0
                                          0.0      0.5       0.866025  0.0
                                          0.0      0.0       0.0       1.0</pre>
          
          

          
          <div class="method-source-code" id="x_rotation-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/homogeneous.rb, line 66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">x_rotation</span> <span class="ruby-identifier">angle_in_radians</span>, <span class="ruby-identifier">opts</span>={}
  <span class="ruby-identifier">c</span> = <span class="ruby-constant">Math</span>.<span class="ruby-identifier">cos</span>(<span class="ruby-identifier">angle_in_radians</span>)
  <span class="ruby-identifier">s</span> = <span class="ruby-constant">Math</span>.<span class="ruby-identifier">sin</span>(<span class="ruby-identifier">angle_in_radians</span>)
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">4</span>, [<span class="ruby-value">1.0</span>, <span class="ruby-value">0.0</span>, <span class="ruby-value">0.0</span>, <span class="ruby-value">0.0</span>,
                  <span class="ruby-value">0.0</span>, <span class="ruby-identifier">c</span>,   <span class="ruby-operator">-</span><span class="ruby-identifier">s</span>,  <span class="ruby-value">0.0</span>,
                  <span class="ruby-value">0.0</span>, <span class="ruby-identifier">s</span>,    <span class="ruby-identifier">c</span>,  <span class="ruby-value">0.0</span>,
                  <span class="ruby-value">0.0</span>, <span class="ruby-value">0.0</span>, <span class="ruby-value">0.0</span>, <span class="ruby-value">1.0</span>], {<span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-value">:float64</span>}.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>))
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-y_rotation" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">y_rotation</span><span
            class="method-args">(angle_in_radians, opts={})</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="y_rotation-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/homogeneous.rb, line 75</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">y_rotation</span> <span class="ruby-identifier">angle_in_radians</span>, <span class="ruby-identifier">opts</span>={}
  <span class="ruby-identifier">c</span> = <span class="ruby-constant">Math</span>.<span class="ruby-identifier">cos</span>(<span class="ruby-identifier">angle_in_radians</span>)
  <span class="ruby-identifier">s</span> = <span class="ruby-constant">Math</span>.<span class="ruby-identifier">sin</span>(<span class="ruby-identifier">angle_in_radians</span>)
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">4</span>, [ <span class="ruby-identifier">c</span>,  <span class="ruby-value">0.0</span>,  <span class="ruby-identifier">s</span>,  <span class="ruby-value">0.0</span>,
                  <span class="ruby-value">0.0</span>, <span class="ruby-value">1.0</span>, <span class="ruby-value">0.0</span>, <span class="ruby-value">0.0</span>,
                  <span class="ruby-operator">-</span><span class="ruby-identifier">s</span>,  <span class="ruby-value">0.0</span>,  <span class="ruby-identifier">c</span>,  <span class="ruby-value">0.0</span>,
                  <span class="ruby-value">0.0</span>, <span class="ruby-value">0.0</span>, <span class="ruby-value">0.0</span>, <span class="ruby-value">1.0</span>], {<span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-value">:float64</span>}.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>))
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-z_rotation" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">z_rotation</span><span
            class="method-args">(angle_in_radians, opts={})</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="z_rotation-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/homogeneous.rb, line 84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">z_rotation</span> <span class="ruby-identifier">angle_in_radians</span>, <span class="ruby-identifier">opts</span>={}
  <span class="ruby-identifier">c</span> = <span class="ruby-constant">Math</span>.<span class="ruby-identifier">cos</span>(<span class="ruby-identifier">angle_in_radians</span>)
  <span class="ruby-identifier">s</span> = <span class="ruby-constant">Math</span>.<span class="ruby-identifier">sin</span>(<span class="ruby-identifier">angle_in_radians</span>)
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">4</span>, [ <span class="ruby-identifier">c</span>,  <span class="ruby-operator">-</span><span class="ruby-identifier">s</span>,  <span class="ruby-value">0.0</span>, <span class="ruby-value">0.0</span>,
                   <span class="ruby-identifier">s</span>,   <span class="ruby-identifier">c</span>,  <span class="ruby-value">0.0</span>, <span class="ruby-value">0.0</span>,
                  <span class="ruby-value">0.0</span>, <span class="ruby-value">0.0</span>, <span class="ruby-value">1.0</span>, <span class="ruby-value">0.0</span>,
                  <span class="ruby-value">0.0</span>, <span class="ruby-value">0.0</span>, <span class="ruby-value">0.0</span>, <span class="ruby-value">1.0</span>], {<span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-value">:float64</span>}.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>))
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-zeroes" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">zeroes</span><span
            class="method-args">(shape, opts = {})</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-c-zeros">zeros</a>
        </div>
        
      </div>

    
      <div id="method-c-zeros" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            zeros(shape) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            zeros(shape, dtype: dtype) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            zeros(shape, dtype: dtype, stype: stype) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a new matrix of zeros with the dimensions supplied as parameters.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>shape</code> -&gt; <a href="Array.html">Array</a> (or integer for
square matrix) specifying the dimensions.</p>
</li><li>
<p><code>dtype</code> -&gt; (optional) Default is <code>:float64</code></p>
</li><li>
<p><code>stype</code> -&gt; (optional) Default is <code>:dense</code>.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p><a href="NMatrix.html">NMatrix</a> filled with zeros.</p>
</li></ul>
</li></ul>

<p>Examples:</p>

<pre>NMatrix.zeros(2) # =&gt;  0.0   0.0
                       0.0   0.0

NMatrix.zeros([2, 3], dtype: :int32) # =&gt;  0  0  0
                                           0  0  0

NMatrix.zeros([1, 5], dtype: :int32) # =&gt;  0  0  0  0  0</pre>
          
          

          
          <div class="method-source-code" id="zeros-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 146</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">zeros</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">opts</span> = {})
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-value">0</span>, {<span class="ruby-value">:dtype</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">:float64</span>}.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>))
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-c-zeroes">zeroes</a>
        </div>
        

        
      </div>

    
      <div id="method-c-zeros_like" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            zeros_like(nm) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a new matrix of zeros with the same stype, dtype, and shape as the
provided matrix.</p>

<p>@param [NMatrix] nm the nmatrix whose stype, dtype, and shape will be used
@return [NMatrix] a new nmatrix filled with zeros.</p>
          
          

          
          <div class="method-source-code" id="zeros_like-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 197</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">zeros_like</span>(<span class="ruby-identifier">nm</span>)
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">zeros</span>(<span class="ruby-identifier">nm</span>.<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-identifier">nm</span>.<span class="ruby-identifier">dtype</span>, <span class="ruby-identifier">stype</span><span class="ruby-operator">:</span> <span class="ruby-identifier">nm</span>.<span class="ruby-identifier">stype</span>, <span class="ruby-identifier">capacity</span><span class="ruby-operator">:</span> <span class="ruby-identifier">nm</span>.<span class="ruby-identifier">capacity</span>, <span class="ruby-identifier">default</span><span class="ruby-operator">:</span> <span class="ruby-value">0</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

    
      <div id="method-i-3D-3D" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">==</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Equality operator. Returns a single true or false value indicating whether
the matrices are equivalent.</p>

<p>For elementwise, use =~ instead.</p>

<p>This method will raise an exception if dimensions do not match.</p>

<p>When stypes differ, this function calls a protected Ruby method.</p>
          
          

          
          <div class="method-source-code" id="3D-3D-source">
            <pre>static VALUE nm_eqeq(VALUE left, VALUE right) {
  NM_CONSERVATIVE(nm_register_value(&amp;left));
  NM_CONSERVATIVE(nm_register_value(&amp;right));

  NMATRIX *l, *r;

  CheckNMatrixType(left);
  CheckNMatrixType(right);

  UnwrapNMatrix(left, l);
  UnwrapNMatrix(right, r);

  bool result = false;

  // Check that the shapes match before going any further.
  if (l-&gt;storage-&gt;dim != r-&gt;storage-&gt;dim) {
    NM_CONSERVATIVE(nm_unregister_value(&amp;left));
    NM_CONSERVATIVE(nm_unregister_value(&amp;right));
    rb_raise(nm_eShapeError, &quot;cannot compare matrices with different dimension&quot;);
  }

  size_t dim = l-&gt;storage-&gt;dim;
  for (size_t i=0; i&lt;dim; i++) {
    if (l-&gt;storage-&gt;shape[i] != r-&gt;storage-&gt;shape[i]) {
      NM_CONSERVATIVE(nm_unregister_value(&amp;left));
      NM_CONSERVATIVE(nm_unregister_value(&amp;right));
      rb_raise(nm_eShapeError, &quot;cannot compare matrices with different shapes&quot;);
    }
  }

  if (l-&gt;stype != r-&gt;stype) { // DIFFERENT STYPES

    if (l-&gt;stype == nm::DENSE_STORE)
      result = rb_funcall(left, rb_intern(&quot;dense_eql_sparse?&quot;), 1, right);
    else if (r-&gt;stype == nm::DENSE_STORE)
      result = rb_funcall(right, rb_intern(&quot;dense_eql_sparse?&quot;), 1, left);
    else
      result = rb_funcall(left, rb_intern(&quot;sparse_eql_sparse?&quot;), 1, right);

  } else {

    switch(l-&gt;stype) {       // SAME STYPES
    case nm::DENSE_STORE:
      result = nm_dense_storage_eqeq(l-&gt;storage, r-&gt;storage);
      break;
    case nm::LIST_STORE:
      result = nm_list_storage_eqeq(l-&gt;storage, r-&gt;storage);
      break;
    case nm::YALE_STORE:
      result = nm_yale_storage_eqeq(l-&gt;storage, r-&gt;storage);
      break;
    }
  }

  NM_CONSERVATIVE(nm_unregister_value(&amp;left));
  NM_CONSERVATIVE(nm_unregister_value(&amp;right));

  return result ? Qtrue : Qfalse;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-5B-5D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            matrix[indices] &rarr; ...
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Access the contents of an <a href="NMatrix.html">NMatrix</a> at given
coordinates by reference.</p>

<pre class="ruby"><span class="ruby-identifier">n</span>[<span class="ruby-value">3</span>,<span class="ruby-value">3</span>]  <span class="ruby-comment"># =&gt; 5.0</span>
<span class="ruby-identifier">n</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>,<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>] <span class="ruby-comment">#=&gt; matrix [2,2]</span>
</pre>
          
          

          
          <div class="method-source-code" id="5B-5D-source">
            <pre>static VALUE nm_mref(int argc, VALUE* argv, VALUE self) {
  static void* (*ttable[nm::NUM_STYPES])(const STORAGE*, SLICE*) = {
    nm_dense_storage_ref,
    nm_list_storage_ref,
    nm_yale_storage_ref
  };
  nm::stype_t stype = NM_STYPE(self);
  return nm_xslice(argc, argv, ttable[stype], nm_delete_ref, self);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-5B-5D-3D" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">[]=</span><span
            class="method-args">(*args)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Modify the contents of an <a href="NMatrix.html">NMatrix</a> in the given
cell</p>

<pre class="ruby"><span class="ruby-identifier">n</span>[<span class="ruby-value">3</span>,<span class="ruby-value">3</span>] = <span class="ruby-value">5.0</span>
</pre>

<p>Also returns the new contents, so you can chain:</p>

<pre class="ruby"><span class="ruby-identifier">n</span>[<span class="ruby-value">3</span>,<span class="ruby-value">3</span>] = <span class="ruby-identifier">n</span>[<span class="ruby-value">2</span>,<span class="ruby-value">3</span>] = <span class="ruby-value">5.0</span>
</pre>
          
          

          
          <div class="method-source-code" id="5B-5D-3D-source">
            <pre>static VALUE nm_mset(int argc, VALUE* argv, VALUE self) {

  size_t dim = NM_DIM(self); // last arg is the value

  VALUE to_return = Qnil;

  if ((size_t)(argc) &gt; NM_DIM(self)+1) {
    rb_raise(rb_eArgError, &quot;wrong number of arguments (%d for %lu)&quot;, argc, effective_dim(NM_STORAGE(self))+1);
  } else {
    NM_CONSERVATIVE(nm_register_value(&amp;self));
    NM_CONSERVATIVE(nm_register_values(argv, argc));

    SLICE* slice = get_slice(dim, argc-1, argv, NM_STORAGE(self)-&gt;shape);

    static void (*ttable[nm::NUM_STYPES])(VALUE, SLICE*, VALUE) = {
      nm_dense_storage_set,
      nm_list_storage_set,
      nm_yale_storage_set
    };

    ttable[NM_STYPE(self)](self, slice, argv[argc-1]);

    free_slice(slice);

    to_return = argv[argc-1];

    NM_CONSERVATIVE(nm_unregister_value(&amp;self));
    NM_CONSERVATIVE(nm_unregister_values(argv, argc));
  }

  return to_return;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-abs" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            abs &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Maps all values in a matrix to their absolute values.</p>
          
          

          
          <div class="method-source-code" id="abs-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 784</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">abs</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dense</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">__dense_map__</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">v</span>.<span class="ruby-identifier">abs</span> }
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:list</span>
    <span class="ruby-comment"># FIXME: Need __list_map_stored__, but this will do for now.</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">__list_map_merged_stored__</span>(<span class="ruby-keyword">nil</span>, <span class="ruby-keyword">nil</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">v</span>,<span class="ruby-identifier">dummy</span><span class="ruby-operator">|</span> <span class="ruby-identifier">v</span>.<span class="ruby-identifier">abs</span> }
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">__yale_map_stored__</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">v</span>.<span class="ruby-identifier">abs</span> }
  <span class="ruby-keyword">end</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span>, <span class="ruby-identifier">abs_dtype</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-abs_dtype" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            abs_dtype &rarr; Symbol
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the dtype of the result of a call to <a
href="NMatrix.html#method-i-abs">abs</a>. In most cases, this is the same
as dtype; it should only differ for :complex64 (where it&#39;s :float32)
and :complex128 (:float64).</p>
          
          

          
          <div class="method-source-code" id="abs_dtype-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 768</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">abs_dtype</span>
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:complex64</span>
    <span class="ruby-value">:float32</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:complex128</span>
    <span class="ruby-value">:float64</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-absolute_sum" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">absolute_sum</span><span
            class="method-args">(incx=1, n=nil)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-asum">asum</a>
        </div>
        
      </div>

    
      <div id="method-i-angle_vector" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            angle_vector &rarr; [angle, about_vector]
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Find the angle vector for a quaternion. Assumes the quaternion has unit
length.</p>

<p>Source: <a
href="http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle">www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle</a>/</p>
<ul><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>An angle (in radians) describing the rotation about the
<code>about_vector</code>.</p>
</li><li>
<p>A length-3 <a href="NMatrix.html">NMatrix</a> representing the
corresponding quaternion.</p>
</li></ul>
</li></ul>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-identifier">q</span>.<span class="ruby-identifier">angle_vector</span> <span class="ruby-comment"># =&gt; [1, 0, 0, 0]</span>
</pre>
          
          

          
          <div class="method-source-code" id="angle_vector-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/homogeneous.rb, line 228</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">angle_vector</span>
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">ShapeError</span>, <span class="ruby-string">&quot;Expected length-4 vector or matrix (quaternion)&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">!=</span> <span class="ruby-value">4</span>
  <span class="ruby-identifier">raise</span>(<span class="ruby-string">&quot;Expected unit quaternion&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>

  <span class="ruby-identifier">xyz</span> = <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>([<span class="ruby-value">3</span>], <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>)

  <span class="ruby-identifier">angle</span> = <span class="ruby-value">2</span> <span class="ruby-operator">*</span> <span class="ruby-constant">Math</span>.<span class="ruby-identifier">acos</span>(<span class="ruby-keyword">self</span>[<span class="ruby-value">0</span>])
  <span class="ruby-identifier">s</span> = <span class="ruby-constant">Math</span>.<span class="ruby-identifier">sqrt</span>(<span class="ruby-value">1.0</span> <span class="ruby-operator">-</span> <span class="ruby-keyword">self</span>[<span class="ruby-value">0</span>]<span class="ruby-operator">*</span><span class="ruby-keyword">self</span>[<span class="ruby-value">0</span>])

  <span class="ruby-identifier">xyz</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>] = <span class="ruby-keyword">self</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">3</span>]
  <span class="ruby-identifier">xyz</span> <span class="ruby-operator">/=</span> <span class="ruby-identifier">s</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">s</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0.001</span> <span class="ruby-comment"># avoid divide by zero</span>
  <span class="ruby-keyword">return</span> [<span class="ruby-identifier">angle</span>, <span class="ruby-identifier">xyz</span>]
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-asum" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            absolute_sum &rarr; Numeric
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <h2 id="method-i-asum-label-Arguments">Arguments<span><a href="#method-i-asum-label-Arguments">&para;</a> <a href="#top">&uarr;</a></span></h2>

<pre>- +incx+ -&gt; the skip size (defaults to 1, no skip)
- +n+ -&gt; the number of elements to include</pre>

<p>Return the sum of the contents of the vector. This is the BLAS asum
routine.</p>
          
          

          
          <div class="method-source-code" id="asum-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 805</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">asum</span> <span class="ruby-identifier">incx</span>=<span class="ruby-value">1</span>, <span class="ruby-identifier">n</span>=<span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span> <span class="ruby-operator">==</span> [<span class="ruby-value">1</span>]
    <span class="ruby-keyword">return</span> <span class="ruby-keyword">self</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">abs</span> <span class="ruby-keyword">unless</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">complex_dtype?</span>
    <span class="ruby-keyword">return</span> <span class="ruby-keyword">self</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">real</span>.<span class="ruby-identifier">abs</span> <span class="ruby-operator">+</span> <span class="ruby-keyword">self</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">imag</span>.<span class="ruby-identifier">abs</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">method_missing</span>(<span class="ruby-value">:asum</span>, <span class="ruby-identifier">incx</span>, <span class="ruby-identifier">n</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">vector?</span>
  <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">BLAS</span><span class="ruby-operator">::</span><span class="ruby-identifier">asum</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">incx</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">/</span> <span class="ruby-identifier">incx</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-absolute_sum">absolute_sum</a>
        </div>
        

        
      </div>

    
      <div id="method-i-binned_sorted_indices" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            binned_sorted_indices &rarr; Array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an array of arrays of indices ordered by value sorted. Functions
basically like <code>sorted_indices</code>, but groups indices together for
those values that are the same.</p>
          
          

          
          <div class="method-source-code" id="binned_sorted_indices-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 913</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">binned_sorted_indices</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">method_missing</span>(<span class="ruby-value">:sorted_indices</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">vector?</span>
  <span class="ruby-identifier">ary</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">to_flat_array</span>
  <span class="ruby-identifier">ary2</span> = []
  <span class="ruby-identifier">last_bin</span> = <span class="ruby-identifier">ary</span>.<span class="ruby-identifier">each_index</span>.<span class="ruby-identifier">sort_by</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> [<span class="ruby-identifier">ary</span>[<span class="ruby-identifier">i</span>]] }.<span class="ruby-identifier">inject</span>([]) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">result</span>, <span class="ruby-identifier">element</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">result</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">ary</span>[<span class="ruby-identifier">result</span>[<span class="ruby-value">-1</span>]] <span class="ruby-operator">==</span> <span class="ruby-identifier">ary</span>[<span class="ruby-identifier">element</span>]
      <span class="ruby-identifier">result</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">element</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">ary2</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">result</span>
      [<span class="ruby-identifier">element</span>]
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">ary2</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">last_bin</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">last_bin</span>.<span class="ruby-identifier">empty?</span>
  <span class="ruby-identifier">ary2</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-capacity" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">capacity</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Find the capacity of an <a href="NMatrix.html">NMatrix</a>. The capacity
only differs from the size for Yale matrices, which occasionally allocate
more space than they need. For list and dense, capacity gives the number of
elements in the matrix.</p>

<p>If you call this on a slice, it may behave unpredictably. Most likely
it&#39;ll just return the original matrix&#39;s capacity.</p>
          
          

          
          <div class="method-source-code" id="capacity-source">
            <pre>static VALUE nm_capacity(VALUE self) {
  NM_CONSERVATIVE(nm_register_value(&amp;self));
  VALUE cap;

  switch(NM_STYPE(self)) {
  case nm::YALE_STORE:
    cap = UINT2NUM(reinterpret_cast&lt;YALE_STORAGE*&gt;(NM_STORAGE_YALE(self)-&gt;src)-&gt;capacity);
    break;

  case nm::DENSE_STORE:
    cap = UINT2NUM(nm_storage_count_max_elements( NM_STORAGE_DENSE(self) ));
    break;

  case nm::LIST_STORE:
    cap = UINT2NUM(nm_list_storage_count_elements( NM_STORAGE_LIST(self) ));
    break;

  default:
    NM_CONSERVATIVE(nm_unregister_value(&amp;self));
    rb_raise(nm_eStorageTypeError, &quot;unrecognized stype in nm_capacity()&quot;);
  }

  NM_CONSERVATIVE(nm_unregister_value(&amp;self));
  return cap;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-cast" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            cast(stype, dtype, default) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            cast(stype, dtype) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            cast(stype) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            cast(options) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>This is a user-friendly helper for calling <a
href="NMatrix.html#method-i-cast_full">cast_full</a>. The easiest way to
call this function is using an options hash, e.g.,</p>

<pre class="ruby"><span class="ruby-identifier">n</span>.<span class="ruby-identifier">cast</span>(:<span class="ruby-identifier">stype</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">yale</span>, :<span class="ruby-identifier">dtype</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">int64</span>, :<span class="ruby-identifier">default</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">false</span>)
</pre>

<p>For list and yale, :default sets the default value or init of the
matrix. List allows a bit more freedom since non-zeros are permitted. For
yale, unpredictable behavior may result if the value is not false, nil, or
some version of 0. Dense discards :default.</p>

<p>dtype and stype are inferred from the matrix upon which <a
href="NMatrix.html#method-i-cast">cast</a> is called  so you only really
need to provide one. You can actually call this function with no arguments,
in which case it functions like clone.</p>

<p>If your dtype is :object and you are converting from :dense to a sparse
type, it is recommended that you provide a :default, as 0 may behave
differently from its Float or Complex equivalent. If no option is given,
Fixnum 0 will be used.</p>
          
          

          
          <div class="method-source-code" id="cast-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 226</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">cast</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">params</span>)
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">params</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">params</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Hash</span>))
    <span class="ruby-identifier">opts</span> = {
        <span class="ruby-value">:stype</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span>,
        <span class="ruby-value">:dtype</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>,
        <span class="ruby-value">:default</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dense</span> <span class="ruby-operator">?</span> <span class="ruby-value">0</span> <span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">default_value</span>
    }.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">params</span>[<span class="ruby-value">0</span>])

    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">cast_full</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:stype</span>], <span class="ruby-identifier">opts</span>[<span class="ruby-value">:dtype</span>], <span class="ruby-identifier">opts</span>[<span class="ruby-value">:default</span>])
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">params</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">params</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
    <span class="ruby-identifier">params</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">params</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
    <span class="ruby-comment">#HACK: the default value can cause an exception if dtype is not complex</span>
    <span class="ruby-comment">#and default_value is. (The ruby C code apparently won&#39;t convert these.)</span>
    <span class="ruby-comment">#Perhaps this should be fixed in the C code (in rubyval_to_cval).</span>
    <span class="ruby-identifier">default_value</span> = <span class="ruby-identifier">maybe_get_noncomplex_default_value</span>(<span class="ruby-identifier">params</span>[<span class="ruby-value">1</span>])
    <span class="ruby-identifier">params</span> <span class="ruby-operator">&lt;&lt;</span> (<span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dense</span> <span class="ruby-operator">?</span> <span class="ruby-value">0</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">default_value</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">params</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">==</span> <span class="ruby-value">2</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">cast_full</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">params</span>)
  <span class="ruby-keyword">end</span>

<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-cast_full" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            cast_full(stype) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            cast_full(stype, dtype, sparse_basis) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Copy constructor for changing dtypes and stypes.</p>
          
          

          
          <div class="method-source-code" id="cast_full-source">
            <pre>VALUE nm_cast(VALUE self, VALUE new_stype_symbol, VALUE new_dtype_symbol, VALUE init) {
  NM_CONSERVATIVE(nm_register_value(&amp;self));
  NM_CONSERVATIVE(nm_register_value(&amp;init));

  nm::dtype_t new_dtype = nm_dtype_from_rbsymbol(new_dtype_symbol);
  nm::stype_t new_stype = nm_stype_from_rbsymbol(new_stype_symbol);

  CheckNMatrixType(self);
  NMATRIX *rhs;

  UnwrapNMatrix( self, rhs );

  void* init_ptr = NM_ALLOCA_N(char, DTYPE_SIZES[new_dtype]);
  rubyval_to_cval(init, new_dtype, init_ptr);

  NMATRIX* m = nm_cast_with_ctype_args(rhs, new_stype, new_dtype, init_ptr);
  nm_register_nmatrix(m);

  VALUE to_return = Data_Wrap_Struct(CLASS_OF(self), nm_mark, nm_delete, m);

  nm_unregister_nmatrix(m);
  NM_CONSERVATIVE(nm_unregister_value(&amp;self));
  NM_CONSERVATIVE(nm_unregister_value(&amp;init));
  return to_return;

}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-clone_structure" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            clone_structure &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>This function is like clone, but it only copies the structure and the
default value. None of the other values are copied. It takes an optional
capacity argument. This is mostly only useful for dense, where you may not
want to initialize; for other types, you should probably use
<code>zeros_like</code>.</p>
          
          

          
          <div class="method-source-code" id="clone_structure-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 989</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">clone_structure</span>(<span class="ruby-identifier">capacity</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">opts</span> = {<span class="ruby-identifier">stype</span><span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span>, <span class="ruby-identifier">default</span><span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">default_value</span>, <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>}
  <span class="ruby-identifier">opts</span> = {<span class="ruby-identifier">capacity</span><span class="ruby-operator">:</span> <span class="ruby-identifier">capacity</span>}.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>) <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">yale?</span>
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">opts</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-col" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">col</span><span
            class="method-args">(column_number, get_by = :copy)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-column">column</a>
        </div>
        
      </div>

    
      <div id="method-i-cols" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            cols &rarr; Integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>This shortcut use <a href="NMatrix.html#method-i-shape">shape</a> to return
the number of columns (the second dimension) of the matrix.</p>
          
          

          
          <div class="method-source-code" id="cols-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 267</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">cols</span>
  <span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>]
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-column" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            column(column_number) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            column(column_number, get_by) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the column specified. Uses slicing by copy as default.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>column_number</code> -&gt; Integer.</p>
</li><li>
<p><code>get_by</code> -&gt; Type of slicing to use, <code>:copy</code> or
<code>:reference</code>.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>A <a href="NMatrix.html">NMatrix</a> representing the requested column as a
column vector.</p>
</li></ul>
</li></ul>

<p>Examples:</p>

<pre>m = NMatrix.new(2, [1, 4, 9, 14], :int32) # =&gt;  1   4
                                                9  14

m.column(1) # =&gt;   4
                  14</pre>
          
          

          
          <div class="method-source-code" id="column-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 516</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">column</span>(<span class="ruby-identifier">column_number</span>, <span class="ruby-identifier">get_by</span> = <span class="ruby-value">:copy</span>)
  <span class="ruby-identifier">rank</span>(<span class="ruby-value">1</span>, <span class="ruby-identifier">column_number</span>, <span class="ruby-identifier">get_by</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-col">col</a>
        </div>
        

        
      </div>

    
      <div id="method-i-complex_conjugate" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            complex_conjugate &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Transform the matrix (non-in-place) to its complex conjugate. Only works on
complex matrices.</p>
          
          

          
          <div class="method-source-code" id="complex_conjugate-source">
            <pre>static VALUE nm_complex_conjugate(VALUE self) {
  VALUE copy;
  return nm_complex_conjugate_bang(nm_init_copy(copy,self));
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-complex_conjugate-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            complex_conjugate_bang &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Transform the matrix (in-place) to its complex conjugate. Only works on
complex matrices.</p>

<p>Bang should imply that no copy is being made, even temporarily.</p>
          
          

          
          <div class="method-source-code" id="complex_conjugate-21-source">
            <pre>static VALUE nm_complex_conjugate_bang(VALUE self) {

  NMATRIX* m;
  void* elem;
  size_t size, p;

  UnwrapNMatrix(self, m);

  if (m-&gt;stype == nm::DENSE_STORE) {

    size = nm_storage_count_max_elements(NM_STORAGE(self));
    elem = NM_STORAGE_DENSE(self)-&gt;elements;

  } else if (m-&gt;stype == nm::YALE_STORE) {

    size = nm_yale_storage_get_size(NM_STORAGE_YALE(self));
    elem = NM_STORAGE_YALE(self)-&gt;a;

  } else {
    rb_raise(rb_eNotImpError, &quot;please cast to yale or dense (complex) first&quot;);
  }

  // Walk through and negate the imaginary component
  if (NM_DTYPE(self) == nm::COMPLEX64) {

    for (p = 0; p &lt; size; ++p) {
      reinterpret_cast&lt;nm::Complex64*&gt;(elem)[p].i = -reinterpret_cast&lt;nm::Complex64*&gt;(elem)[p].i;
    }

  } else if (NM_DTYPE(self) == nm::COMPLEX128) {

    for (p = 0; p &lt; size; ++p) {
      reinterpret_cast&lt;nm::Complex128*&gt;(elem)[p].i = -reinterpret_cast&lt;nm::Complex128*&gt;(elem)[p].i;
    }

  }
  return self;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-complex_dtype-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            complex_dtype?() &rarr; Boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Checks if dtype is a complex type</p>
          
          

          
          <div class="method-source-code" id="complex_dtype-3F-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 364</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">complex_dtype?</span>
  [<span class="ruby-value">:complex64</span>, <span class="ruby-value">:complex128</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-concat" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            concat(*m2) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            concat(*m2, rank) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            hconcat(*m2) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            vconcat(*m2) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            dconcat(*m3) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Joins two matrices together into a new larger matrix. Attempts to determine
which direction to concatenate on by looking for the first common element
of the matrix <code>shape</code> in reverse. In other words, concatenating
two columns together without supplying <code>rank</code> will glue them
into an n x 2 matrix.</p>

<p>You can also use hconcat, vconcat, and dconcat for the first three ranks.
concat performs an hconcat when no rank argument is provided.</p>

<p>The two matrices must have the same <code>dim</code>.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>matrices</code> -&gt; one or more matrices</p>
</li><li>
<p><code>rank</code> -&gt; Fixnum (for rank); alternatively, may use :row,
:column, or</p>
</li></ul>

<p>:layer for 0, 1, 2, respectively</p>
</li></ul>
          
          

          
          <div class="method-source-code" id="concat-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 662</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">concat</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">matrices</span>)
  <span class="ruby-identifier">rank</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">rank</span> = <span class="ruby-identifier">matrices</span>.<span class="ruby-identifier">pop</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">matrices</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">NMatrix</span>)

  <span class="ruby-comment"># Find the first matching dimension and concatenate along that (unless rank is specified)</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">rank</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-identifier">rank</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span><span class="ruby-operator">-</span><span class="ruby-value">1</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>.<span class="ruby-identifier">reverse_each</span>.<span class="ruby-identifier">with_index</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">s</span>,<span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">matrices</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">m</span><span class="ruby-operator">|</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-identifier">i</span>] <span class="ruby-operator">!=</span> <span class="ruby-identifier">s</span>
          <span class="ruby-identifier">rank</span> <span class="ruby-operator">-=</span> <span class="ruby-value">1</span>
          <span class="ruby-keyword">break</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">rank</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Symbol</span>) <span class="ruby-comment"># Convert to numeric</span>
    <span class="ruby-identifier">rank</span> = {<span class="ruby-value">:row</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>, <span class="ruby-value">:column</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>, <span class="ruby-value">:col</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>, <span class="ruby-value">:lay</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">2</span>, <span class="ruby-value">:layer</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">2</span>}[<span class="ruby-identifier">rank</span>]
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Need to figure out the new shape.</span>
  <span class="ruby-identifier">new_shape</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>.<span class="ruby-identifier">dup</span>
  <span class="ruby-identifier">new_shape</span>[<span class="ruby-identifier">rank</span>] = <span class="ruby-identifier">matrices</span>.<span class="ruby-identifier">inject</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-identifier">rank</span>]) { <span class="ruby-operator">|</span><span class="ruby-identifier">total</span>,<span class="ruby-identifier">m</span><span class="ruby-operator">|</span> <span class="ruby-identifier">total</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">m</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-identifier">rank</span>] }

  <span class="ruby-comment"># Now figure out the options for constructing the concatenated matrix.</span>
  <span class="ruby-identifier">opts</span> = {<span class="ruby-identifier">stype</span><span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span>, <span class="ruby-identifier">default</span><span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">default_value</span>, <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>}
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">yale?</span>
    <span class="ruby-comment"># We can generally predict the new capacity for Yale. Subtract out the number of rows</span>
    <span class="ruby-comment"># for each matrix being concatenated, and then add in the number of rows for the new</span>
    <span class="ruby-comment"># shape. That takes care of the diagonal. The rest of the capacity is represented by</span>
    <span class="ruby-comment"># the non-diagonal non-default values.</span>
    <span class="ruby-identifier">new_cap</span> = <span class="ruby-identifier">matrices</span>.<span class="ruby-identifier">inject</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">capacity</span> <span class="ruby-operator">-</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">total</span>,<span class="ruby-identifier">m</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">total</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">m</span>.<span class="ruby-identifier">capacity</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">m</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]
    <span class="ruby-keyword">end</span> <span class="ruby-operator">-</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">+</span> <span class="ruby-identifier">new_shape</span>[<span class="ruby-value">0</span>]
    <span class="ruby-identifier">opts</span> = {<span class="ruby-identifier">capacity</span><span class="ruby-operator">:</span> <span class="ruby-identifier">new_cap</span>}.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Do the actual construction.</span>
  <span class="ruby-identifier">n</span> = <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">new_shape</span>, <span class="ruby-identifier">opts</span>)

  <span class="ruby-comment"># Figure out where to start and stop the concatenation. We&#39;ll use NMatrices instead of</span>
  <span class="ruby-comment"># Arrays because then we can do elementwise addition.</span>
  <span class="ruby-identifier">ranges</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>.<span class="ruby-identifier">map</span>.<span class="ruby-identifier">with_index</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">s</span>,<span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-identifier">i</span>] }

  <span class="ruby-identifier">matrices</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-keyword">self</span>)
  <span class="ruby-identifier">matrices</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">m</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">n</span>[<span class="ruby-operator">*</span><span class="ruby-identifier">ranges</span>] = <span class="ruby-identifier">m</span>

    <span class="ruby-comment"># move over by the requisite amount</span>
    <span class="ruby-identifier">ranges</span>[<span class="ruby-identifier">rank</span>]  = (<span class="ruby-identifier">ranges</span>[<span class="ruby-identifier">rank</span>].<span class="ruby-identifier">first</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">m</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-identifier">rank</span>])<span class="ruby-operator">...</span>(<span class="ruby-identifier">ranges</span>[<span class="ruby-identifier">rank</span>].<span class="ruby-identifier">last</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">m</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-identifier">rank</span>])
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">n</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-conjugate_transpose" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            conjugate_transpose &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calculate the conjugate transpose of a matrix. If your dtype is already
complex, this should only require one copy (for the transpose).</p>
<ul><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>The conjugate transpose of the matrix as a copy.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="conjugate_transpose-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 624</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">conjugate_transpose</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">transpose</span>.<span class="ruby-identifier">complex_conjugate!</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-corr" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">corr</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Calculate the correlation matrix.</p>
          
          

          
          <div class="method-source-code" id="corr-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 523</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">corr</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">NotImplementedError</span>, <span class="ruby-string">&quot;Does not work for complex dtypes&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">complex_dtype?</span>
  <span class="ruby-identifier">standard_deviation</span> = <span class="ruby-identifier">std</span>
  <span class="ruby-identifier">cov</span> <span class="ruby-operator">/</span> (<span class="ruby-identifier">standard_deviation</span>.<span class="ruby-identifier">transpose</span>.<span class="ruby-identifier">dot</span>(<span class="ruby-identifier">standard_deviation</span>))
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-cov" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">cov</span><span
            class="method-args">(opts={})</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Calculate the variance co-variance matrix</p>

<h2 id="method-i-cov-label-Options">Options<span><a href="#method-i-cov-label-Options">&para;</a> <a href="#top">&uarr;</a></span></h2>
<ul><li>
<p><code>:for_sample_data</code> - Default true. If set to false will consider
the denominator for population data (i.e. <a href="N.html">N</a>, as
opposed to N-1 for sample data).</p>
</li></ul>

<h2 id="method-i-cov-label-References">References<span><a href="#method-i-cov-label-References">&para;</a> <a href="#top">&uarr;</a></span></h2>
<ul><li>
<p><a
href="http://stattrek.com/matrix-algebra/covariance-matrix.aspx">stattrek.com/matrix-algebra/covariance-matrix.aspx</a></p>
</li></ul>
          
          

          
          <div class="method-source-code" id="cov-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 510</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">cov</span>(<span class="ruby-identifier">opts</span>={})
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">TypeError</span>, <span class="ruby-string">&quot;Only works for non-integer dtypes&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">integer_dtype?</span>
   <span class="ruby-identifier">opts</span> = {
    <span class="ruby-identifier">for_sample_data</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>
  }.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>)
  
  <span class="ruby-identifier">denominator</span>      = <span class="ruby-identifier">opts</span>[<span class="ruby-value">:for_sample_data</span>] <span class="ruby-operator">?</span> <span class="ruby-identifier">rows</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">rows</span>
  <span class="ruby-identifier">ones</span>             = <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">ones</span> [<span class="ruby-identifier">rows</span>,<span class="ruby-value">1</span>] 
  <span class="ruby-identifier">deviation_scores</span> = <span class="ruby-keyword">self</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">ones</span>.<span class="ruby-identifier">dot</span>(<span class="ruby-identifier">ones</span>.<span class="ruby-identifier">transpose</span>).<span class="ruby-identifier">dot</span>(<span class="ruby-keyword">self</span>) <span class="ruby-operator">/</span> <span class="ruby-identifier">rows</span>
  <span class="ruby-identifier">deviation_scores</span>.<span class="ruby-identifier">transpose</span>.<span class="ruby-identifier">dot</span>(<span class="ruby-identifier">deviation_scores</span>) <span class="ruby-operator">/</span> <span class="ruby-identifier">denominator</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-data_pointer" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">data_pointer</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns the pointer to the matrix storage&#39;s data. This is useful
primarily when you are using FFI with <a href="NMatrix.html">NMatrix</a> 
say, for example, you want to pass a float* to some function, and your <a
href="NMatrix.html">NMatrix</a> is a :float32 :dense matrix. Then you can
call this function and get that pointer directly instead of copying the
data.</p>
          
          

          
          <div class="method-source-code" id="data_pointer-source">
            <pre>static VALUE nm_data_pointer(VALUE self) {
  //if (NM_DTYPE(self) == nm::LIST_STORE)
  //  rb_warn(&quot;pointer requested for list storage, which may be meaningless&quot;);

  // This is actually pretty easy, since all of the storage types have their elements positioned in the same place
  // relative to one another. So yes, believe it or not, this should work just as well for Yale or list storage as for
  // dense.
  return INT2FIX(NM_STORAGE_DENSE(self)-&gt;elements);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-dconcat" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">dconcat</span><span
            class="method-args">(*matrices)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Depth concatenation with <code>matrices</code>.</p>
          
          

          
          <div class="method-source-code" id="dconcat-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 727</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">dconcat</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">matrices</span>)
  <span class="ruby-identifier">concat</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">matrices</span>, <span class="ruby-value">:layer</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-default_value" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            default_value &rarr; ...
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the default value for the matrix. For dense, this is undefined and will
return Qnil. For list, it is user-defined. For yale, it&#39;s going to be
some variation on zero, but may be Qfalse or Qnil.</p>
          
          

          
          <div class="method-source-code" id="default_value-source">
            <pre>static VALUE nm_default_value(VALUE self) {
  switch(NM_STYPE(self)) {
  case nm::YALE_STORE:
    return nm_yale_default_value(self);
  case nm::LIST_STORE:
    return nm_list_default_value(self);
  case nm::DENSE_STORE:
  default:
    return Qnil;
  }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-dense-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            dense? &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Determine if <code>m</code> is a dense matrix.</p>
          
          

          
          <div class="method-source-code" id="dense-3F-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">dense?</span>; <span class="ruby-keyword">return</span> <span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dense</span>; <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-det" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            det &rarr; determinant
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calculate the determinant by way of LU decomposition. This is accomplished
using clapack_getrf, and then by taking the product of the diagonal
elements. There is a risk of underflow/overflow.</p>

<p>There are probably also more efficient ways to calculate the determinant.
This method requires making a copy of the matrix, since clapack_getrf
modifies its input.</p>

<p>For smaller matrices, you may be able to use <code>#det_exact</code>.</p>

<p>This function is guaranteed to return the same type of data in the matrix
upon which it is called.</p>

<p>Integer matrices are converted to floating point matrices for the purposes
of performing the calculation, as xGETRF can&#39;t work on integer
matrices.</p>
<ul><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>The determinant of the matrix. It&#39;s the same type as the matrix&#39;s
dtype.</p>
</li></ul>
</li><li>
<p><strong>Raises</strong> :</p>
<ul><li>
<p><code>ShapeError</code> -&gt; Must be used on square matrices.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="det-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 454</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">det</span>
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">ShapeError</span>, <span class="ruby-string">&quot;determinant can be calculated only for square matrices&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span> <span class="ruby-operator">==</span> <span class="ruby-value">2</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>]

  <span class="ruby-comment"># Cast to a dtype for which getrf is implemented</span>
  <span class="ruby-identifier">new_dtype</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">integer_dtype?</span> <span class="ruby-operator">?</span> <span class="ruby-value">:float64</span> <span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>
  <span class="ruby-identifier">copy</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-value">:dense</span>, <span class="ruby-identifier">new_dtype</span>)

  <span class="ruby-comment"># Need to know the number of permutations. We&#39;ll add up the diagonals of</span>
  <span class="ruby-comment"># the factorized matrix.</span>
  <span class="ruby-identifier">pivot</span> = <span class="ruby-identifier">copy</span>.<span class="ruby-identifier">getrf!</span>

  <span class="ruby-identifier">num_perm</span> = <span class="ruby-value">0</span> <span class="ruby-comment">#number of permutations</span>
  <span class="ruby-identifier">pivot</span>.<span class="ruby-identifier">each_with_index</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">swap</span>, <span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-comment">#pivot indexes rows starting from 1, instead of 0, so need to subtract 1 here</span>
    <span class="ruby-identifier">num_perm</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">swap</span><span class="ruby-operator">-</span><span class="ruby-value">1</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">i</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">prod</span> = <span class="ruby-identifier">num_perm</span> <span class="ruby-operator">%</span> <span class="ruby-value">2</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span> <span class="ruby-operator">?</span> <span class="ruby-value">-1</span> <span class="ruby-operator">:</span> <span class="ruby-value">1</span> <span class="ruby-comment"># odd permutations =&gt; negative</span>
  [<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>],<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>]].<span class="ruby-identifier">min</span>.<span class="ruby-identifier">times</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">prod</span> <span class="ruby-operator">*=</span> <span class="ruby-identifier">copy</span>[<span class="ruby-identifier">i</span>,<span class="ruby-identifier">i</span>]
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Convert back to an integer if necessary</span>
  <span class="ruby-identifier">new_dtype</span> <span class="ruby-operator">!=</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">prod</span>.<span class="ruby-identifier">round</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">prod</span> <span class="ruby-comment">#prevent rounding errors</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-det_exact" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">det_exact</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Calculate the exact determinant of a dense matrix.</p>

<p>Returns nil for dense matrices which are not square or number of dimensions
other than 2.</p>

<p>Note: Currently only implemented for 2x2 and 3x3 matrices.</p>
          
          

          
          <div class="method-source-code" id="det_exact-source">
            <pre>static VALUE nm_det_exact(VALUE self) {

  if (NM_STYPE(self) != nm::DENSE_STORE) {
    rb_raise(rb_eNotImpError, &quot;can only calculate exact determinant for dense matrices&quot;);
    return Qnil;
  }
  if (NM_DIM(self) != 2 || NM_SHAPE0(self) != NM_SHAPE1(self)) {
    rb_raise(nm_eShapeError, &quot;matrices must be square to have a determinant defined&quot;);
    return Qnil;
  }

  NM_CONSERVATIVE(nm_register_value(&amp;self));

  // Calculate the determinant and then assign it to the return value
  void* result = NM_ALLOCA_N(char, DTYPE_SIZES[NM_DTYPE(self)]);
  nm::dtype_t dtype = NM_DTYPE(self);
  nm_math_det_exact(NM_SHAPE0(self), NM_STORAGE_DENSE(self)-&gt;elements, NM_SHAPE0(self), NM_DTYPE(self), result);

  if (dtype == nm::RUBYOBJ) {
    nm_register_values(reinterpret_cast&lt;VALUE*&gt;(result), 1);
  }
  VALUE to_return = rubyobj_from_cval(result, NM_DTYPE(self)).rval;
  if (dtype == nm::RUBYOBJ) {
    nm_unregister_values(reinterpret_cast&lt;VALUE*&gt;(result), 1);
  }
  NM_CONSERVATIVE(nm_unregister_value(&amp;self));

  return to_return;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-diagonal" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">diagonal</span><span
            class="method-args">(main_diagonal=true)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Return the main diagonal or antidiagonal a matrix. Only works with 2D
matrices.</p>

<h2 id="method-i-diagonal-label-Arguments">Arguments<span><a href="#method-i-diagonal-label-Arguments">&para;</a> <a href="#top">&uarr;</a></span></h2>
<ul><li>
<p><code>main_diagonal</code> - Defaults to true. If passed &#39;false&#39;,
then will return the  antidiagonal of the matrix.</p>
</li></ul>

<h2 id="method-i-diagonal-label-References">References<span><a href="#method-i-diagonal-label-References">&para;</a> <a href="#top">&uarr;</a></span></h2>
<ul><li>
<p><a
href="http://en.wikipedia.org/wiki/Main_diagonal">en.wikipedia.org/wiki/Main_diagonal</a></p>
</li></ul>
          
          

          
          <div class="method-source-code" id="diagonal-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 281</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">diagonal</span> <span class="ruby-identifier">main_diagonal</span>=<span class="ruby-keyword">true</span>
  <span class="ruby-identifier">diag_size</span> = [<span class="ruby-identifier">cols</span>, <span class="ruby-identifier">rows</span>].<span class="ruby-identifier">min</span>
  <span class="ruby-identifier">diag</span> = <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span> [<span class="ruby-identifier">diag_size</span>], <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-identifier">dtype</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">main_diagonal</span>
    <span class="ruby-value">0</span>.<span class="ruby-identifier">upto</span>(<span class="ruby-identifier">diag_size</span><span class="ruby-operator">-</span><span class="ruby-value">1</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">diag</span>[<span class="ruby-identifier">i</span>] = <span class="ruby-keyword">self</span>[<span class="ruby-identifier">i</span>,<span class="ruby-identifier">i</span>]
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">row</span> = <span class="ruby-value">0</span>
    (<span class="ruby-identifier">diag_size</span><span class="ruby-operator">-</span><span class="ruby-value">1</span>).<span class="ruby-identifier">downto</span>(<span class="ruby-value">0</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">col</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">diag</span>[<span class="ruby-identifier">row</span>] = <span class="ruby-keyword">self</span>[<span class="ruby-identifier">row</span>,<span class="ruby-identifier">col</span>]
      <span class="ruby-identifier">row</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">diag</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-dim" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">dim</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-dimensions">dimensions</a>
        </div>
        
      </div>

    
      <div id="method-i-dimensions" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            dim &rarr; Integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the number of dimensions of a matrix.</p>

<p>In other words, if you set your matrix to be 3x4, the dim is 2. If the
matrix was initialized as 3x4x3, the dim is 3.</p>

<p>Use <a href="NMatrix.html#method-i-effective_dim">effective_dim</a> to get
the dimension of an <a href="NMatrix.html">NMatrix</a> which acts as a
vector (e.g., a column or row).</p>
          
          

          
          <div class="method-source-code" id="dimensions-source">
            <pre>static VALUE nm_dim(VALUE self) {
  return INT2FIX(NM_STORAGE(self)-&gt;dim);
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-dim">dim</a>
        </div>
        

        
      </div>

    
      <div id="method-i-dot" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">dot</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Matrix multiply (dot product): against another matrix or a vector.</p>

<p>For elementwise, use * instead.</p>

<p>The two matrices must be of the same stype (for now). If dtype differs, an
upcast will occur.</p>
          
          

          
          <div class="method-source-code" id="dot-source">
            <pre>static VALUE nm_multiply(VALUE left_v, VALUE right_v) {
  NM_CONSERVATIVE(nm_register_value(&amp;left_v));
  NM_CONSERVATIVE(nm_register_value(&amp;right_v));

  NMATRIX *left, *right;

  UnwrapNMatrix( left_v, left );

  if (NM_RUBYVAL_IS_NUMERIC(right_v)) {
    NM_CONSERVATIVE(nm_unregister_value(&amp;left_v));
    NM_CONSERVATIVE(nm_unregister_value(&amp;right_v));
    return matrix_multiply_scalar(left, right_v);
  }

  else if (TYPE(right_v) == T_ARRAY) {
    NM_CONSERVATIVE(nm_unregister_value(&amp;left_v));
    NM_CONSERVATIVE(nm_unregister_value(&amp;right_v));
    rb_raise(rb_eNotImpError, &quot;please convert array to nx1 or 1xn NMatrix first&quot;);
  }

  else { // both are matrices (probably)
    CheckNMatrixType(right_v);
    UnwrapNMatrix( right_v, right );

    // work like vector dot product for 1dim
    if (left-&gt;storage-&gt;dim == 1 &amp;&amp; right-&gt;storage-&gt;dim == 1) {
      if (left-&gt;storage-&gt;shape[0] != right-&gt;storage-&gt;shape[0]) {
        NM_CONSERVATIVE(nm_unregister_value(&amp;left_v));
        NM_CONSERVATIVE(nm_unregister_value(&amp;right_v));
        rb_raise(rb_eArgError, &quot;The left- and right-hand sides of the operation must have the same dimensionality.&quot;);
      } else {
        VALUE result = elementwise_op(nm::EW_MUL, left_v, right_v);
        VALUE to_return = rb_funcall(result, rb_intern(&quot;sum&quot;),0);
        NM_CONSERVATIVE(nm_unregister_value(&amp;left_v));
        NM_CONSERVATIVE(nm_unregister_value(&amp;right_v));
        return to_return;
      }
    }

    if (left-&gt;storage-&gt;shape[1] != right-&gt;storage-&gt;shape[0]) {
      NM_CONSERVATIVE(nm_unregister_value(&amp;left_v));
      NM_CONSERVATIVE(nm_unregister_value(&amp;right_v));
      rb_raise(rb_eArgError, &quot;incompatible dimensions&quot;);
    }

    if (left-&gt;stype != right-&gt;stype) {
      NM_CONSERVATIVE(nm_unregister_value(&amp;left_v));
      NM_CONSERVATIVE(nm_unregister_value(&amp;right_v));
      rb_raise(rb_eNotImpError, &quot;matrices must have same stype&quot;);
    }

    NM_CONSERVATIVE(nm_unregister_value(&amp;left_v));
    NM_CONSERVATIVE(nm_unregister_value(&amp;right_v));
    return matrix_multiply(left, right);

  }

  NM_CONSERVATIVE(nm_unregister_value(&amp;left_v));
  NM_CONSERVATIVE(nm_unregister_value(&amp;right_v));

  return Qnil;
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-internal_dot">internal_dot</a>
        </div>
        

        
      </div>

    
      <div id="method-i-dtype" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            dtype &rarr; Symbol
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the data type (dtype) of a matrix, e.g., :byte, :int8, :int16, :int32,
:int64, :float32, :float64, :complex64, :complex128, or :object (the last
is a Ruby object).</p>
          
          

          
          <div class="method-source-code" id="dtype-source">
            <pre>static VALUE nm_dtype(VALUE self) {
  ID dtype = rb_intern(DTYPE_NAMES[NM_DTYPE(self)]);
  return ID2SYM(dtype);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-each" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each &rarr; Enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Enumerate through the matrix. @see Enumerable#each</p>

<p>For dense, this actually calls a specialized each iterator (in C). For yale
and list, it relies upon <a
href="NMatrix.html#method-i-each_with_indices">each_with_indices</a> (which
is about as fast as reasonably possible for C code).</p>
          
          

          
          <div class="method-source-code" id="each-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/enumerate.rb, line 40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">each</span> <span class="ruby-operator">&amp;</span><span class="ruby-identifier">bl</span>
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dense</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">__dense_each__</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">bl</span>)
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">block_given?</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">each_with_indices</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">bl</span>)
  <span class="ruby-keyword">else</span> <span class="ruby-comment"># Handle case where no block is given</span>
    <span class="ruby-constant">Enumerator</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">yielder</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">self</span>.<span class="ruby-identifier">each_with_indices</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">params</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">yielder</span>.<span class="ruby-identifier">yield</span> <span class="ruby-identifier">params</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-each_along_dim" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">each_along_dim</span><span
            class="method-args">(dimen=0, get_by=:reference)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-each_rank">each_rank</a>
        </div>
        
      </div>

    
      <div id="method-i-each_column" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each_column { |column| block } &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Iterate through each column, referencing it as an <a
href="NMatrix.html">NMatrix</a> slice.</p>
          
          

          
          <div class="method-source-code" id="each_column-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/enumerate.rb, line 144</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">each_column</span>(<span class="ruby-identifier">get_by</span>=<span class="ruby-value">:reference</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">enum_for</span>(<span class="ruby-value">:each_column</span>, <span class="ruby-identifier">get_by</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block_given?</span>
  (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>]).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">j</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">yield</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">column</span>(<span class="ruby-identifier">j</span>, <span class="ruby-identifier">get_by</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-each_layer" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each_layer -&gt; { |column| block } &rarr; ...
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Iterate through each layer, referencing it as an <a
href="NMatrix.html">NMatrix</a> slice.</p>

<p>Note: If you have a 3-dimensional matrix, the first dimension contains
rows, the second contains columns, and the third contains layers.</p>
          
          

          
          <div class="method-source-code" id="each_layer-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/enumerate.rb, line 160</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">each_layer</span>(<span class="ruby-identifier">get_by</span>=<span class="ruby-value">:reference</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">enum_for</span>(<span class="ruby-value">:each_layer</span>, <span class="ruby-identifier">get_by</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block_given?</span>
  (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">2</span>]).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">k</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">yield</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">layer</span>(<span class="ruby-identifier">k</span>, <span class="ruby-identifier">get_by</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-each_ordered_stored_with_indices" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each_ordered_stored_with_indices &rarr; Enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Very similar to <a
href="NMatrix.html#method-i-each_stored_with_indices">each_stored_with_indices</a>.
The key difference is that it enforces matrix ordering rather than storage
ordering, which only matters if your matrix is Yale.</p>
          
          

          
          <div class="method-source-code" id="each_ordered_stored_with_indices-source">
            <pre>static VALUE nm_each_ordered_stored_with_indices(VALUE nmatrix) {
  NM_CONSERVATIVE(nm_register_value(&amp;nmatrix));
  VALUE to_return = Qnil;

  switch(NM_STYPE(nmatrix)) {
  case nm::YALE_STORE:
    to_return = nm_yale_each_ordered_stored_with_indices(nmatrix);
    break;
  case nm::DENSE_STORE:
    to_return = nm_dense_each_with_indices(nmatrix);
    break;
  case nm::LIST_STORE:
    to_return = nm_list_each_with_indices(nmatrix, true);
    break;
  default:
    NM_CONSERVATIVE(nm_unregister_value(&amp;nmatrix));
    rb_raise(nm_eDataTypeError, &quot;Not a proper storage type&quot;);
  }

  NM_CONSERVATIVE(nm_unregister_value(&amp;nmatrix));
  return to_return;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-each_rank" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each_rank() &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            each_rank() { |rank| block } &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            each_rank(dimen) &rarr; Enumerator
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            each_rank(dimen) { |rank| block } &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Generic for @each_row, @each_col</p>

<p>Iterate through each rank by reference.</p>

<p>@param [Fixnum] dimen the rank being iterated over.</p>
          
          

          
          <div class="method-source-code" id="each_rank-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/enumerate.rb, line 117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">each_rank</span>(<span class="ruby-identifier">dimen</span>=<span class="ruby-value">0</span>, <span class="ruby-identifier">get_by</span>=<span class="ruby-value">:reference</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">enum_for</span>(<span class="ruby-value">:each_rank</span>, <span class="ruby-identifier">dimen</span>, <span class="ruby-identifier">get_by</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block_given?</span>
  (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-identifier">dimen</span>]).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">idx</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">yield</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">rank</span>(<span class="ruby-identifier">dimen</span>, <span class="ruby-identifier">idx</span>, <span class="ruby-identifier">get_by</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-each_along_dim">each_along_dim</a>
        </div>
        

        
      </div>

    
      <div id="method-i-each_row" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each_row { |row| block } &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Iterate through each row, referencing it as an <a
href="NMatrix.html">NMatrix</a> slice.</p>
          
          

          
          <div class="method-source-code" id="each_row-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/enumerate.rb, line 131</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">each_row</span>(<span class="ruby-identifier">get_by</span>=<span class="ruby-value">:reference</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">enum_for</span>(<span class="ruby-value">:each_row</span>, <span class="ruby-identifier">get_by</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block_given?</span>
  (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">yield</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">row</span>(<span class="ruby-identifier">i</span>, <span class="ruby-identifier">get_by</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-each_stored_with_index" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each_stored_with_index &rarr; Enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Allow iteration across a vector NMatrix&#39;s stored values. See also
@each_stored_with_indices</p>
          
          

          
          <div class="method-source-code" id="each_stored_with_index-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/enumerate.rb, line 175</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">each_stored_with_index</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">NotImplementedError</span>, <span class="ruby-string">&quot;only works for dim 2 vectors&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-value">2</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">enum_for</span>(<span class="ruby-value">:each_stored_with_index</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block_given?</span>

  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">each_stored_with_indices</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">v</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">j</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
      <span class="ruby-keyword">yield</span>(<span class="ruby-identifier">v</span>,<span class="ruby-identifier">j</span>)
    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>] <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
      <span class="ruby-keyword">yield</span>(<span class="ruby-identifier">v</span>,<span class="ruby-identifier">i</span>)
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">method_missing</span>(<span class="ruby-value">:each_stored_with_index</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-each_stored_with_indices" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each_stored_with_indices &rarr; Enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Iterate over the stored entries of any matrix. For dense and yale, this
iterates over non-zero entries; for list, this iterates over non-default
entries. Yields dim+1 values for each entry: i, j, , and the entry itself.</p>
          
          

          
          <div class="method-source-code" id="each_stored_with_indices-source">
            <pre>static VALUE nm_each_stored_with_indices(VALUE nmatrix) {
  NM_CONSERVATIVE(nm_register_value(&amp;nmatrix));
  VALUE to_return = Qnil;

  switch(NM_STYPE(nmatrix)) {
  case nm::YALE_STORE:
    to_return = nm_yale_each_stored_with_indices(nmatrix);
    break;
  case nm::DENSE_STORE:
    to_return = nm_dense_each_with_indices(nmatrix);
    break;
  case nm::LIST_STORE:
    to_return = nm_list_each_with_indices(nmatrix, true);
    break;
  default:
    NM_CONSERVATIVE(nm_unregister_value(&amp;nmatrix));
    rb_raise(nm_eDataTypeError, &quot;Not a proper storage type&quot;);
  }

  NM_CONSERVATIVE(nm_unregister_value(&amp;nmatrix));
  return to_return;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-each_with_indices" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each_with_indices &rarr; Enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Iterate over all entries of any matrix in standard storage order (as with
<a href="NMatrix.html#method-i-each">each</a>), and include the indices.</p>
          
          

          
          <div class="method-source-code" id="each_with_indices-source">
            <pre>static VALUE nm_each_with_indices(VALUE nmatrix) {
  NM_CONSERVATIVE(nm_register_value(&amp;nmatrix));
  VALUE to_return = Qnil;

  switch(NM_STYPE(nmatrix)) {
  case nm::YALE_STORE:
    to_return = nm_yale_each_with_indices(nmatrix);
    break;
  case nm::DENSE_STORE:
    to_return = nm_dense_each_with_indices(nmatrix);
    break;
  case nm::LIST_STORE:
    to_return = nm_list_each_with_indices(nmatrix, false);
    break;
  default:
    NM_CONSERVATIVE(nm_unregister_value(&amp;nmatrix));
    rb_raise(nm_eDataTypeError, &quot;Not a proper storage type&quot;);
  }

  NM_CONSERVATIVE(nm_unregister_value(&amp;nmatrix));
  return to_return;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-effective_dim" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">effective_dim</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-effective_dimensions">effective_dimensions</a>
        </div>
        
      </div>

    
      <div id="method-i-effective_dimensions" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            effective_dim &rarr; Fixnum
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the number of dimensions that don&#39;t have length 1. Guaranteed
to be less than or equal to <a href="NMatrix.html#method-i-dim">dim</a>.</p>
          
          

          
          <div class="method-source-code" id="effective_dimensions-source">
            <pre>static VALUE nm_effective_dim(VALUE self) {
  return INT2FIX(effective_dim(NM_STORAGE(self)));
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-effective_dim">effective_dim</a>
        </div>
        

        
      </div>

    
      <div id="method-i-factorize_cholesky" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            factorize_cholesky &rarr; [upper NMatrix, lower NMatrix]
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calculates the Cholesky factorization of a matrix and returns the upper and
lower matrices such that A=LU and L=U*, where * is either the transpose or
conjugate transpose.</p>

<p>Unlike potrf!, this makes method requires that the original is matrix is
symmetric or Hermitian. However, it is still your responsibility to make
sure it is positive-definite.</p>
          
          

          
          <div class="method-source-code" id="factorize_cholesky-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 204</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">factorize_cholesky</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;Matrix must be symmetric/Hermitian for Cholesky factorization&quot;</span> <span class="ruby-keyword">unless</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">hermitian?</span>
  <span class="ruby-identifier">l</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">clone</span>.<span class="ruby-identifier">potrf_lower!</span>.<span class="ruby-identifier">tril!</span>
  <span class="ruby-identifier">u</span> = <span class="ruby-identifier">l</span>.<span class="ruby-identifier">conjugate_transpose</span>
  [<span class="ruby-identifier">u</span>,<span class="ruby-identifier">l</span>]
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-factorize_lu" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            factorize_lu &rarr; ...
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>LU factorization of a matrix. Optionally return the permutation matrix.</p>

<pre>Note that computing the permutation matrix will introduce a slight memory
and time overhead.</pre>

<h2 id="method-i-factorize_lu-label-Arguments">Arguments<span><a href="#method-i-factorize_lu-label-Arguments">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><code>with_permutation_matrix</code> - If set to <strong>true</strong> will
return the permutation</p>

<pre>matrix alongwith the LU factorization as a second return value.</pre>
          
          

          
          <div class="method-source-code" id="factorize_lu-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 224</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">factorize_lu</span> <span class="ruby-identifier">with_permutation_matrix</span>=<span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">NotImplementedError</span>, <span class="ruby-string">&quot;only implemented for dense storage&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dense</span>
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">NotImplementedError</span>, <span class="ruby-string">&quot;matrix is not 2-dimensional&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dimensions</span> <span class="ruby-operator">==</span> <span class="ruby-value">2</span>

  <span class="ruby-identifier">t</span>     = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">clone</span>
  <span class="ruby-identifier">pivot</span> = <span class="ruby-identifier">t</span>.<span class="ruby-identifier">getrf!</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">t</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">with_permutation_matrix</span>

  [<span class="ruby-identifier">t</span>, <span class="ruby-constant">FactorizeLUMethods</span>.<span class="ruby-identifier">permutation_matrix_from</span>(<span class="ruby-identifier">pivot</span>)]
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-flat_map" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">flat_map</span><span
            class="method-args">(&bl)</span>
          
        </div>
        

        <div class="method-description">
          
          <p>call-seq:</p>

<pre>flat_map -&gt; Enumerator
flat_map { |elem| block } -&gt; Array</pre>

<p>Maps using Enumerator (returns an <a href="Array.html">Array</a> or an
Enumerator)</p>
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-map">map</a>
        </div>
        
      </div>

    
      <div id="method-i-float_dtype-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            float_dtype?() &rarr; Boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Checks if dtype is a floating point type</p>
          
          

          
          <div class="method-source-code" id="float_dtype-3F-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 354</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">float_dtype?</span>
  [<span class="ruby-value">:float32</span>, <span class="ruby-value">:float64</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">dtype</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-gesdd" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            gesdd &rarr; [u, sigma, v_transpose]
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            gesdd &rarr; [u, sigma, v_conjugate_transpose] # complex
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Compute the singular value decomposition of a matrix using LAPACK&#39;s
GESDD function. This uses a divide-and-conquer strategy. See also <a
href="NMatrix.html#method-i-gesvd">gesvd</a>.</p>

<p>Optionally accepts a <code>workspace_size</code> parameter, which will be
honored only if it is larger than what LAPACK requires.</p>
          
          

          
          <div class="method-source-code" id="gesdd-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 350</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">gesdd</span>(<span class="ruby-identifier">workspace_size</span>=<span class="ruby-keyword">nil</span>)
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">clone</span>.<span class="ruby-identifier">gesdd!</span>(<span class="ruby-identifier">workspace_size</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-gesdd-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            gesdd! &rarr; [u, sigma, v_transpose]
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            gesdd! &rarr; [u, sigma, v_conjugate_transpose] # complex
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Compute the singular value decomposition of a matrix using LAPACK&#39;s
GESDD function. This uses a divide-and-conquer strategy. This is
destructive, modifying the source <a href="NMatrix.html">NMatrix</a>.  See
also <a href="NMatrix.html#method-i-gesvd">gesvd</a>.</p>

<p>Optionally accepts a <code>workspace_size</code> parameter, which will be
honored only if it is larger than what LAPACK requires.</p>
          
          

          
          <div class="method-source-code" id="gesdd-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 335</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">gesdd!</span>(<span class="ruby-identifier">workspace_size</span>=<span class="ruby-keyword">nil</span>)
  <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">LAPACK</span><span class="ruby-operator">::</span><span class="ruby-identifier">gesdd</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">workspace_size</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-gesvd" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            gesvd &rarr; [u, sigma, v_transpose]
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            gesvd &rarr; [u, sigma, v_conjugate_transpose] # complex
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Compute the singular value decomposition of a matrix using LAPACK&#39;s
GESVD function.</p>

<p>Optionally accepts a <code>workspace_size</code> parameter, which will be
honored only if it is larger than what LAPACK requires.</p>
          
          

          
          <div class="method-source-code" id="gesvd-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 318</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">gesvd</span>(<span class="ruby-identifier">workspace_size</span>=<span class="ruby-value">1</span>)
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">clone</span>.<span class="ruby-identifier">gesvd!</span>(<span class="ruby-identifier">workspace_size</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-gesvd-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            gesvd! &rarr; [u, sigma, v_transpose]
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            gesvd! &rarr; [u, sigma, v_conjugate_transpose] # complex
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Compute the singular value decomposition of a matrix using LAPACK&#39;s
GESVD function. This is destructive, modifying the source <a
href="NMatrix.html">NMatrix</a>.  See also <a
href="NMatrix.html#method-i-gesdd">gesdd</a>.</p>

<p>Optionally accepts a <code>workspace_size</code> parameter, which will be
honored only if it is larger than what LAPACK requires.</p>
          
          

          
          <div class="method-source-code" id="gesvd-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 304</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">gesvd!</span>(<span class="ruby-identifier">workspace_size</span>=<span class="ruby-value">1</span>)
  <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">LAPACK</span><span class="ruby-operator">::</span><span class="ruby-identifier">gesvd</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">workspace_size</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-getrf-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">getrf!</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="getrf-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/lapacke.rb, line 169</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">getrf!</span>
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">StorageTypeError</span>, <span class="ruby-string">&quot;LAPACK functions only work on dense matrices&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dense?</span>

  <span class="ruby-identifier">ipiv</span> = <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">LAPACK</span><span class="ruby-operator">::</span><span class="ruby-identifier">lapacke_getrf</span>(<span class="ruby-value">:row</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>], <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>], <span class="ruby-keyword">self</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>])

  <span class="ruby-keyword">return</span> <span class="ruby-identifier">ipiv</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-hconcat" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">hconcat</span><span
            class="method-args">(*matrices)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Horizontal concatenation with <code>matrices</code>.</p>
          
          

          
          <div class="method-source-code" id="hconcat-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 717</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">hconcat</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">matrices</span>)
  <span class="ruby-identifier">concat</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">matrices</span>, <span class="ruby-value">:column</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-hermitian-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            hermitian? &rarr; Boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Is this matrix hermitian?</p>

<p>Definition: <a
href="http://en.wikipedia.org/wiki/Hermitian_matrix">en.wikipedia.org/wiki/Hermitian_matrix</a></p>

<p>For non-complex matrices, this function should return the same result as
symmetric?.</p>
          
          

          
          <div class="method-source-code" id="hermitian-3F-source">
            <pre>static VALUE nm_hermitian(VALUE self) {
  return is_symmetric(self, true);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-hessenberg" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">hessenberg</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Reduce self to upper hessenberg form using householder transforms.</p>

<h2 id="method-i-hessenberg-label-References">References<span><a href="#method-i-hessenberg-label-References">&para;</a> <a href="#top">&uarr;</a></span></h2>
<ul><li>
<p><a
href="http://en.wikipedia.org/wiki/Hessenberg_matrix">en.wikipedia.org/wiki/Hessenberg_matrix</a></p>
</li><li>
<p><a
href="http://www.mymathlib.com/c_source/matrices/eigen/hessenberg_orthog.c">www.mymathlib.com/c_source/matrices/eigen/hessenberg_orthog.c</a></p>
</li></ul>
          
          

          
          <div class="method-source-code" id="hessenberg-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 241</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">hessenberg</span>
  <span class="ruby-identifier">clone</span>.<span class="ruby-identifier">hessenberg!</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-hessenberg-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">hessenberg!</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Destructive version of <a
href="NMatrix.html#method-i-hessenberg">hessenberg</a></p>
          
          

          
          <div class="method-source-code" id="hessenberg-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 246</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">hessenberg!</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">ShapeError</span>, <span class="ruby-string">&quot;Trying to reduce non 2D matrix to hessenberg form&quot;</span> <span class="ruby-keyword">if</span> 
    <span class="ruby-identifier">shape</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">!=</span> <span class="ruby-value">2</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">ShapeError</span>, <span class="ruby-string">&quot;Trying to reduce non-square matrix to hessenberg form&quot;</span> <span class="ruby-keyword">if</span> 
    <span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">!=</span> <span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>]
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">StorageTypeError</span>, <span class="ruby-string">&quot;Matrix must be dense&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">stype</span> <span class="ruby-operator">!=</span> <span class="ruby-value">:dense</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">TypeError</span>, <span class="ruby-string">&quot;Works with float matrices only&quot;</span> <span class="ruby-keyword">unless</span> 
    [<span class="ruby-value">:float64</span>,<span class="ruby-value">:float32</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">dtype</span>)

  <span class="ruby-identifier">__hessenberg__</span>(<span class="ruby-keyword">self</span>)
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-index" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">index</span><span
            class="method-args">(value)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Returns the index of the first occurence of the specified value. Returns 
an array containing the position of the value, nil in case the value is not
found.</p>
          
          

          
          <div class="method-source-code" id="index-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 966</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">index</span>(<span class="ruby-identifier">value</span>)
  <span class="ruby-identifier">index</span> = <span class="ruby-keyword">nil</span>

  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">each_with_indices</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">yields</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">yields</span>.<span class="ruby-identifier">first</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">value</span>
      <span class="ruby-identifier">yields</span>.<span class="ruby-identifier">shift</span>
      <span class="ruby-identifier">index</span> = <span class="ruby-identifier">yields</span>
      <span class="ruby-keyword">break</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span> 

  <span class="ruby-identifier">index</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-initialize_copy" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">initialize_copy</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Copy constructor for no change of dtype or stype (used for <a
href="NMatrix.html#method-i-initialize_copy">initialize_copy</a> hook).</p>
          
          

          
          <div class="method-source-code" id="initialize_copy-source">
            <pre>static VALUE nm_init_copy(VALUE copy, VALUE original) {
  NM_CONSERVATIVE(nm_register_value(&amp;copy));
  NM_CONSERVATIVE(nm_register_value(&amp;original));

  NMATRIX *lhs, *rhs;

  CheckNMatrixType(original);

  if (copy == original) {
    NM_CONSERVATIVE(nm_unregister_value(&amp;copy));
    NM_CONSERVATIVE(nm_unregister_value(&amp;original));
    return copy;
  }

  UnwrapNMatrix( original, rhs );
  UnwrapNMatrix( copy,     lhs );

  lhs-&gt;stype = rhs-&gt;stype;

  // Copy the storage
  CAST_TABLE(ttable);
  lhs-&gt;storage = ttable[lhs-&gt;stype][rhs-&gt;stype](rhs-&gt;storage, rhs-&gt;storage-&gt;dtype, NULL);

  NM_CONSERVATIVE(nm_unregister_value(&amp;copy));
  NM_CONSERVATIVE(nm_unregister_value(&amp;original));

  return copy;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-inject" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            inject &rarr; symbol
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>This overrides the inject function to use <a
href="NMatrix.html#method-i-map_stored">#map_stored</a> for yale matrices</p>
          
          
            <div class="method-calls-super">
              Calls superclass method
              
            </div>
          

          
          <div class="method-source-code" id="inject-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 958</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">inject</span>(<span class="ruby-identifier">sym</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">super</span>(<span class="ruby-identifier">sym</span>) <span class="ruby-keyword">unless</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">yale?</span>
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">map_stored</span>.<span class="ruby-identifier">inject</span>(<span class="ruby-identifier">sym</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-inject_along_dim" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">inject_along_dim</span><span
            class="method-args">(dimen=0, initial=nil, dtype=nil)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-inject_rank">inject_rank</a>
        </div>
        
      </div>

    
      <div id="method-i-inject_rank" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            inject_rank() &rarr; Enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            inject_rank(dimen) &rarr; Enumerator
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            inject_rank(dimen, initial) &rarr; Enumerator
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            inject_rank(dimen, initial, dtype) &rarr; Enumerator
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            inject_rank() { |elem| block } &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            inject_rank(dimen) { |elem| block } &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            inject_rank(dimen, initial) { |elem| block } &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            inject_rank(dimen, initial, dtype) { |elem| block } &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Reduces an <a href="NMatrix.html">NMatrix</a> using a supplied block over a
specified dimension. The block should behave the same way as for
Enumerable#reduce.</p>

<p>@param [Integer] dimen the dimension being reduced @param [Numeric] initial
the initial value for the reduction</p>

<pre>(i.e. the usual parameter to Enumerable#reduce).  Supply nil or do not
supply this argument to have it follow the usual Enumerable#reduce
behavior of using the first element as the initial value.</pre>

<p>@param [Symbol] dtype if non-nil/false, forces the accumulated result to
have this dtype @return [NMatrix] an <a href="NMatrix.html">NMatrix</a>
with the same number of dimensions as the</p>

<pre>input, but with the input dimension now having size 1.  Each element
is the result of the reduction at that position along the specified
dimension.</pre>
          
          

          
          <div class="method-source-code" id="inject_rank-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/enumerate.rb, line 217</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">inject_rank</span>(<span class="ruby-identifier">dimen</span>=<span class="ruby-value">0</span>, <span class="ruby-identifier">initial</span>=<span class="ruby-keyword">nil</span>, <span class="ruby-identifier">dtype</span>=<span class="ruby-keyword">nil</span>)

  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">RangeError</span>, <span class="ruby-node">&quot;requested dimension (#{dimen}) does not exist (shape: #{shape})&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">dimen</span> <span class="ruby-operator">&gt;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span>

  <span class="ruby-keyword">return</span> <span class="ruby-identifier">enum_for</span>(<span class="ruby-value">:inject_rank</span>, <span class="ruby-identifier">dimen</span>, <span class="ruby-identifier">initial</span>, <span class="ruby-identifier">dtype</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block_given?</span>

  <span class="ruby-identifier">new_shape</span> = <span class="ruby-identifier">shape</span>
  <span class="ruby-identifier">new_shape</span>[<span class="ruby-identifier">dimen</span>] = <span class="ruby-value">1</span>

  <span class="ruby-identifier">first_as_acc</span> = <span class="ruby-keyword">false</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">initial</span> <span class="ruby-keyword">then</span>
    <span class="ruby-identifier">acc</span> = <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">new_shape</span>, <span class="ruby-identifier">initial</span>, <span class="ruby-value">:dtype</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">dtype</span> <span class="ruby-operator">||</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>, <span class="ruby-identifier">stype</span><span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">each_rank</span>(<span class="ruby-identifier">dimen</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">sub_mat</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">acc</span> = (<span class="ruby-identifier">sub_mat</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">NMatrix</span>) <span class="ruby-keyword">and</span> <span class="ruby-operator">!</span><span class="ruby-identifier">dtype</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">dtype</span> <span class="ruby-operator">!=</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">sub_mat</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span>, <span class="ruby-identifier">dtype</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">sub_mat</span>
      <span class="ruby-keyword">break</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">first_as_acc</span> = <span class="ruby-keyword">true</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">each_rank</span>(<span class="ruby-identifier">dimen</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">sub_mat</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">first_as_acc</span>
      <span class="ruby-identifier">first_as_acc</span> = <span class="ruby-keyword">false</span>
      <span class="ruby-keyword">next</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">acc</span> = <span class="ruby-keyword">yield</span>(<span class="ruby-identifier">acc</span>, <span class="ruby-identifier">sub_mat</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">acc</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-reduce_along_dim">reduce_along_dim</a>, <a href="NMatrix.html#method-i-inject_along_dim">inject_along_dim</a>
        </div>
        

        
      </div>

    
      <div id="method-i-integer_dtype-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            integer_dtype?() &rarr; Boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Checks if dtype is an integer type</p>
          
          

          
          <div class="method-source-code" id="integer_dtype-3F-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 345</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">integer_dtype?</span>
  [<span class="ruby-value">:byte</span>, <span class="ruby-value">:int8</span>, <span class="ruby-value">:int16</span>, <span class="ruby-value">:int32</span>, <span class="ruby-value">:int64</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-internal_dot" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">internal_dot</span><span
            class="method-args">(p1)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-dot">dot</a>
        </div>
        
      </div>

    
      <div id="method-i-inverse" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">inverse</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-invert">invert</a>
        </div>
        
      </div>

    
      <div id="method-i-invert" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            invert &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Make a copy of the matrix, then invert using Gauss-Jordan elimination.
Works without LAPACK.</p>
<ul><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>A dense <a href="NMatrix.html">NMatrix</a>. Will be the same type as the
input <a href="NMatrix.html">NMatrix</a>,</p>
</li></ul>

<p>except if the input is an integral dtype, in which case it will be a
:float64 <a href="NMatrix.html">NMatrix</a>.</p>
</li><li>
<p><strong>Raises</strong> :</p>
<ul><li>
<p><code>StorageTypeError</code> -&gt; only implemented on dense matrices.</p>
</li><li>
<p><code>ShapeError</code> -&gt; matrix must be square.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="invert-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 102</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">invert</span>
  <span class="ruby-comment">#write this in terms of invert! so plugins will only have to overwrite</span>
  <span class="ruby-comment">#invert! and not invert</span>
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">integer_dtype?</span>
    <span class="ruby-identifier">cloned</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-value">:float64</span>)
    <span class="ruby-identifier">cloned</span>.<span class="ruby-identifier">invert!</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">cloned</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">clone</span>
    <span class="ruby-identifier">cloned</span>.<span class="ruby-identifier">invert!</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-inverse">inverse</a>
        </div>
        

        
      </div>

    
      <div id="method-i-invert-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">invert!</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="invert-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/atlas.rb, line 186</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">invert!</span>
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">StorageTypeError</span>, <span class="ruby-string">&quot;invert only works on dense matrices currently&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dense?</span>
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">ShapeError</span>, <span class="ruby-string">&quot;Cannot invert non-square matrix&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>]
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">DataTypeError</span>, <span class="ruby-string">&quot;Cannot invert an integer matrix in-place&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">integer_dtype?</span>

  <span class="ruby-comment"># Even though we are using the ATLAS plugin, we still might be missing</span>
  <span class="ruby-comment"># CLAPACK (and thus clapack_getri) if we are on OS X.</span>
  <span class="ruby-keyword">if</span> <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">has_clapack?</span>
    <span class="ruby-comment"># Get the pivot array; factor the matrix</span>
    <span class="ruby-comment"># We can&#39;t used getrf! here since it doesn&#39;t have the clapack behavior,</span>
    <span class="ruby-comment"># so it doesn&#39;t play nicely with clapack_getri</span>
    <span class="ruby-identifier">n</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]
    <span class="ruby-identifier">pivot</span> = <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">LAPACK</span><span class="ruby-operator">::</span><span class="ruby-identifier">clapack_getrf</span>(<span class="ruby-value">:row</span>, <span class="ruby-identifier">n</span>, <span class="ruby-identifier">n</span>, <span class="ruby-keyword">self</span>, <span class="ruby-identifier">n</span>)
    <span class="ruby-comment"># Now calculate the inverse using the pivot array</span>
    <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">LAPACK</span><span class="ruby-operator">::</span><span class="ruby-identifier">clapack_getri</span>(<span class="ruby-value">:row</span>, <span class="ruby-identifier">n</span>, <span class="ruby-keyword">self</span>, <span class="ruby-identifier">n</span>, <span class="ruby-identifier">pivot</span>)
    <span class="ruby-keyword">self</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">__inverse__</span>(<span class="ruby-keyword">self</span>,<span class="ruby-keyword">true</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-is_ref-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">is_ref?</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Check to determine whether matrix is a reference to another matrix.</p>
          
          

          
          <div class="method-source-code" id="is_ref-3F-source">
            <pre>static VALUE nm_is_ref(VALUE self) {
  if (NM_SRC(self) == NM_STORAGE(self)) return Qfalse;
  return Qtrue;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-kron_prod" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">kron_prod</span><span
            class="method-args">(mat)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Compute the Kronecker product of <code>self</code> and other <a
href="NMatrix.html">NMatrix</a></p>

<h3 id="method-i-kron_prod-label-Arguments">Arguments<span><a href="#method-i-kron_prod-label-Arguments">&para;</a> <a href="#top">&uarr;</a></span></h3>

<pre>* +mat+ - A 2D NMatrix object</pre>

<h3 id="method-i-kron_prod-label-Usage+">Usage <span><a href="#method-i-kron_prod-label-Usage+">&para;</a> <a href="#top">&uarr;</a></span></h3>

<pre>a = NMatrix.new([2,2],[1,2,
                       3,4])
b = NMatrix.new([2,3],[1,1,1,
                       1,1,1], dtype: :float64)
a.kron_prod(b) # =&gt; [ [1.0, 1.0, 1.0, 2.0, 2.0, 2.0]
                      [1.0, 1.0, 1.0, 2.0, 2.0, 2.0]
                      [3.0, 3.0, 3.0, 4.0, 4.0, 4.0]
                      [3.0, 3.0, 3.0, 4.0, 4.0, 4.0] ]</pre>
          
          

          
          <div class="method-source-code" id="kron_prod-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 587</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">kron_prod</span>(<span class="ruby-identifier">mat</span>)
  <span class="ruby-keyword">unless</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dimensions</span><span class="ruby-operator">==</span><span class="ruby-value">2</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">mat</span>.<span class="ruby-identifier">dimensions</span><span class="ruby-operator">==</span><span class="ruby-value">2</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ShapeError</span>, <span class="ruby-string">&quot;Implemented for 2D NMatrix objects only.&quot;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># compute the shape [n,m] of the product matrix</span>
  <span class="ruby-identifier">n</span>, <span class="ruby-identifier">m</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]<span class="ruby-operator">*</span><span class="ruby-identifier">mat</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>], <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>]<span class="ruby-operator">*</span><span class="ruby-identifier">mat</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>]
  <span class="ruby-comment"># compute the entries of the product matrix</span>
  <span class="ruby-identifier">kron_prod_array</span> = []
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">yale?</span>
    <span class="ruby-comment"># +:yale+ requires to get the row by copy in order to apply +#transpose+ to it</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">each_row</span>(<span class="ruby-identifier">getby</span>=<span class="ruby-value">:copy</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">selfr</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">mat</span>.<span class="ruby-identifier">each_row</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">matr</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">kron_prod_array</span> <span class="ruby-operator">+=</span> (<span class="ruby-identifier">selfr</span>.<span class="ruby-identifier">transpose</span>.<span class="ruby-identifier">dot</span> <span class="ruby-identifier">matr</span>).<span class="ruby-identifier">to_flat_a</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">each_row</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">selfr</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">mat</span>.<span class="ruby-identifier">each_row</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">matr</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">kron_prod_array</span> <span class="ruby-operator">+=</span> (<span class="ruby-identifier">selfr</span>.<span class="ruby-identifier">transpose</span>.<span class="ruby-identifier">dot</span> <span class="ruby-identifier">matr</span>).<span class="ruby-identifier">to_flat_a</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>([<span class="ruby-identifier">n</span>,<span class="ruby-identifier">m</span>], <span class="ruby-identifier">kron_prod_array</span>) 
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-laswp" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            laswp(ary) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Permute the columns of a dense matrix using LASWP according to the order
given in an array <code>ary</code>.</p>

<p>If <code>:convention</code> is <code>:lapack</code>, then <code>ary</code>
represents a sequence of pair-wise permutations which are  performed
successively. That is, the i&#39;th entry of <code>ary</code> is the index
of the column to swap  the i&#39;th column with, having already applied all
earlier swaps. This is the default.</p>

<p>If <code>:convention</code> is <code>:intuitive</code>, then
<code>ary</code> represents the order of columns after the permutation. 
That is, the i&#39;th entry of <code>ary</code> is the index of the column
that will be in position i after the  reordering (Matlab-like behaviour).</p>

<p>Not yet implemented for yale or list.</p>

<h2 id="method-i-laswp-label-Arguments">Arguments<span><a href="#method-i-laswp-label-Arguments">&para;</a> <a href="#top">&uarr;</a></span></h2>
<ul><li>
<p><code>ary</code> - An <a href="Array.html">Array</a> specifying the order
of the columns. See above for details.</p>
</li></ul>

<h2 id="method-i-laswp-label-Options">Options<span><a href="#method-i-laswp-label-Options">&para;</a> <a href="#top">&uarr;</a></span></h2>
<ul><li>
<p><code>:covention</code> - Possible values are <code>:lapack</code> and
<code>:intuitive</code>. Default is <code>:lapack</code>. See above for
details.</p>
</li></ul>
          
          

          
          <div class="method-source-code" id="laswp-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 425</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">laswp</span>(<span class="ruby-identifier">ary</span>, <span class="ruby-identifier">opts</span>={})
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">clone</span>.<span class="ruby-identifier">laswp!</span>(<span class="ruby-identifier">ary</span>, <span class="ruby-identifier">opts</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-permute_columns">permute_columns</a>
        </div>
        

        
      </div>

    
      <div id="method-i-laswp-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            laswp!(ary) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>In-place permute the columns of a dense matrix using LASWP according to the
order given as an array <code>ary</code>.</p>

<p>If <code>:convention</code> is <code>:lapack</code>, then <code>ary</code>
represents a sequence of pair-wise permutations which are  performed
successively. That is, the i&#39;th entry of <code>ary</code> is the index
of the column to swap  the i&#39;th column with, having already applied all
earlier swaps.</p>

<p>If <code>:convention</code> is <code>:intuitive</code>, then
<code>ary</code> represents the order of columns after the permutation. 
That is, the i&#39;th entry of <code>ary</code> is the index of the column
that will be in position i after the  reordering (Matlab-like behaviour).
This is the default.</p>

<p>Not yet implemented for yale or list.</p>

<h2 id="method-i-laswp-21-label-Arguments">Arguments<span><a href="#method-i-laswp-21-label-Arguments">&para;</a> <a href="#top">&uarr;</a></span></h2>
<ul><li>
<p><code>ary</code> - An <a href="Array.html">Array</a> specifying the order
of the columns. See above for details.</p>
</li></ul>

<h2 id="method-i-laswp-21-label-Options">Options<span><a href="#method-i-laswp-21-label-Options">&para;</a> <a href="#top">&uarr;</a></span></h2>
<ul><li>
<p><code>:covention</code> - Possible values are <code>:lapack</code> and
<code>:intuitive</code>. Default is <code>:intuitive</code>. See above for
details.</p>
</li></ul>
          
          

          
          <div class="method-source-code" id="laswp-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 378</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">laswp!</span>(<span class="ruby-identifier">ary</span>, <span class="ruby-identifier">opts</span>={})
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">StorageTypeError</span>, <span class="ruby-string">&quot;ATLAS functions only work on dense matrices&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dense?</span>
  <span class="ruby-identifier">opts</span> = { <span class="ruby-identifier">convention</span><span class="ruby-operator">:</span> <span class="ruby-value">:intuitive</span> }.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>)
  
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:convention</span>] <span class="ruby-operator">==</span> <span class="ruby-value">:intuitive</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">ary</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">ary</span>.<span class="ruby-identifier">uniq</span>.<span class="ruby-identifier">length</span>
      <span class="ruby-identifier">raise</span>(<span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&quot;No duplicated entries in the order array are allowed under convention :intuitive&quot;</span>)
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">n</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>]
    <span class="ruby-identifier">p</span> = []
    <span class="ruby-identifier">order</span> = (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-identifier">n</span>).<span class="ruby-identifier">to_a</span>
    <span class="ruby-value">0</span>.<span class="ruby-identifier">upto</span>(<span class="ruby-identifier">n</span><span class="ruby-operator">-</span><span class="ruby-value">2</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">p</span>[<span class="ruby-identifier">i</span>] = <span class="ruby-identifier">order</span>.<span class="ruby-identifier">index</span>(<span class="ruby-identifier">ary</span>[<span class="ruby-identifier">i</span>])
      <span class="ruby-identifier">order</span>[<span class="ruby-identifier">i</span>], <span class="ruby-identifier">order</span>[<span class="ruby-identifier">p</span>[<span class="ruby-identifier">i</span>]] = <span class="ruby-identifier">order</span>[<span class="ruby-identifier">p</span>[<span class="ruby-identifier">i</span>]], <span class="ruby-identifier">order</span>[<span class="ruby-identifier">i</span>]
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">p</span>[<span class="ruby-identifier">n</span><span class="ruby-operator">-</span><span class="ruby-value">1</span>] = <span class="ruby-identifier">n</span><span class="ruby-operator">-</span><span class="ruby-value">1</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">p</span> = <span class="ruby-identifier">ary</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">LAPACK</span><span class="ruby-operator">::</span><span class="ruby-identifier">laswp</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">p</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-permute_columns-21">permute_columns!</a>
        </div>
        

        
      </div>

    
      <div id="method-i-layer" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            layer(layer_number) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            row(layer_number, get_by) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>layer_number</code> -&gt; Integer.</p>
</li><li>
<p><code>get_by</code> -&gt; Type of slicing to use, <code>:copy</code> or
<code>:reference</code>.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>A <a href="NMatrix.html">NMatrix</a> representing the requested layer as a
layer vector.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="layer-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 853</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">layer</span>(<span class="ruby-identifier">layer_number</span>, <span class="ruby-identifier">get_by</span> = <span class="ruby-value">:copy</span>)
  <span class="ruby-identifier">rank</span>(<span class="ruby-value">2</span>, <span class="ruby-identifier">layer_number</span>, <span class="ruby-identifier">get_by</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-list-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            list? &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Determine if <code>m</code> is a list-of-lists matrix.</p>
          
          

          
          <div class="method-source-code" id="list-3F-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 53</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">list?</span>;  <span class="ruby-keyword">return</span> <span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:list</span>; <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-log" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">log</span><span
            class="method-args">(*args)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="log-source">
            <pre>static VALUE nm_unary_log(int argc, VALUE* argv, VALUE self) {
  NM_CONSERVATIVE(nm_register_values(argv, argc));
  const double default_log_base = exp(1.0);
  NMATRIX* left;
  UnwrapNMatrix(self, left);
  std::string sym;

  switch(left-&gt;stype) {
  case nm::DENSE_STORE:
    sym = &quot;__dense_unary_log__&quot;;
    break;
  case nm::YALE_STORE:
    sym = &quot;__yale_unary_log__&quot;;
    break;
  case nm::LIST_STORE:
    sym = &quot;__list_unary_log__&quot;;
    break;
  }
  NM_CONSERVATIVE(nm_unregister_values(argv, argc));
  if (argc &gt; 0) { //supplied a base
    return rb_funcall(self, rb_intern(sym.c_str()), 1, argv[0]);
  }
  return rb_funcall(self, rb_intern(sym.c_str()), 1, nm::RubyObject(default_log_base).rval);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-lower_triangle" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            lower_triangle &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            lower_triangle(k) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            tril &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            tril(k) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the lower triangular portion of a matrix. This is analogous to the
<code>tril</code> method in MATLAB.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>k</code> -&gt; Integer. How many extra diagonals to include in the
lower triangular portion.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="lower_triangle-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 800</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">lower_triangle</span>(<span class="ruby-identifier">k</span> = <span class="ruby-value">0</span>)
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">NotImplementedError</span>, <span class="ruby-string">&quot;only implemented for 2D matrices&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">2</span>

  <span class="ruby-identifier">t</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">clone_structure</span>
  (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">k</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]
      <span class="ruby-identifier">t</span>[<span class="ruby-identifier">i</span>, <span class="ruby-value">:*</span>] = <span class="ruby-keyword">self</span>[<span class="ruby-identifier">i</span>, <span class="ruby-value">:*</span>]
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">t</span>[<span class="ruby-identifier">i</span>, (<span class="ruby-identifier">i</span><span class="ruby-operator">+</span><span class="ruby-identifier">k</span><span class="ruby-operator">+</span><span class="ruby-value">1</span>)<span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>]] = <span class="ruby-value">0</span>
      <span class="ruby-identifier">t</span>[<span class="ruby-identifier">i</span>, <span class="ruby-value">0</span><span class="ruby-operator">..</span>(<span class="ruby-identifier">i</span><span class="ruby-operator">+</span><span class="ruby-identifier">k</span>)] = <span class="ruby-keyword">self</span>[<span class="ruby-identifier">i</span>, <span class="ruby-value">0</span><span class="ruby-operator">..</span>(<span class="ruby-identifier">i</span><span class="ruby-operator">+</span><span class="ruby-identifier">k</span>)]
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">t</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-tril">tril</a>
        </div>
        

        
      </div>

    
      <div id="method-i-lower_triangle-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            lower_triangle! &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            lower_triangle!(k) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            tril! &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            tril!(k) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Deletes the upper triangular portion of the matrix (in-place) so only the
lower portion remains.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>k</code> -&gt; Integer. How many extra diagonals to include in the
deletion.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="lower_triangle-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 829</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">lower_triangle!</span>(<span class="ruby-identifier">k</span> = <span class="ruby-value">0</span>)
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">NotImplementedError</span>, <span class="ruby-string">&quot;only implemented for 2D matrices&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">2</span>

  (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">k</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]
      <span class="ruby-keyword">self</span>[<span class="ruby-identifier">i</span>, (<span class="ruby-identifier">i</span><span class="ruby-operator">+</span><span class="ruby-identifier">k</span><span class="ruby-operator">+</span><span class="ruby-value">1</span>)<span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>]] = <span class="ruby-value">0</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-tril-21">tril!</a>
        </div>
        

        
      </div>

    
      <div id="method-i-map" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            map &rarr; Enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            map { |elem| block } &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an <a href="NMatrix.html">NMatrix</a> if a block is given. For an
<a href="Array.html">Array</a>, use <a
href="NMatrix.html#method-i-flat_map">flat_map</a></p>

<p>Note that <a href="NMatrix.html#method-i-map">map</a> will always return an
:object matrix, because it has no way of knowing how to handle operations
on the different dtypes.</p>
          
          

          
          <div class="method-source-code" id="map-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/enumerate.rb, line 72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">map</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">bl</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">enum_for</span>(<span class="ruby-value">:map</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block_given?</span>
  <span class="ruby-identifier">cp</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-value">:object</span>)
  <span class="ruby-identifier">cp</span>.<span class="ruby-identifier">map!</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">bl</span>)
  <span class="ruby-identifier">cp</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-flat_map">flat_map</a>
        </div>
        

        
      </div>

    
      <div id="method-i-map-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            map! &rarr; Enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            map! { |elem| block } &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Maps in place. @see <a href="NMatrix.html#method-i-map">map</a></p>
          
          

          
          <div class="method-source-code" id="map-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/enumerate.rb, line 87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">map!</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">enum_for</span>(<span class="ruby-value">:map!</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block_given?</span>
  <span class="ruby-identifier">iterated</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">each_stored_with_indices</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">e</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">iterated</span> = <span class="ruby-keyword">true</span>
    <span class="ruby-keyword">self</span>[<span class="ruby-operator">*</span><span class="ruby-identifier">i</span>] = (<span class="ruby-keyword">yield</span> <span class="ruby-identifier">e</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-comment">#HACK: if there&#39;s a single element in a non-dense matrix, it won&#39;t iterate and</span>
  <span class="ruby-comment">#won&#39;t change the default value; this ensures that it does get changed.</span>
  <span class="ruby-keyword">unless</span> <span class="ruby-identifier">iterated</span> <span class="ruby-keyword">then</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">each_with_indices</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">e</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">self</span>[<span class="ruby-operator">*</span><span class="ruby-identifier">i</span>] = (<span class="ruby-keyword">yield</span> <span class="ruby-identifier">e</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-map_stored" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            map_stored &rarr; Enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Iterate over the stored entries of any matrix. For dense and yale, this
iterates over non-zero entries; for list, this iterates over non-default
entries. Yields dim+1 values for each entry: i, j, , and the entry itself.</p>
          
          

          
          <div class="method-source-code" id="map_stored-source">
            <pre>static VALUE nm_map_stored(VALUE nmatrix) {
  NM_CONSERVATIVE(nm_register_value(&amp;nmatrix));
  VALUE to_return = Qnil;

  switch(NM_STYPE(nmatrix)) {
  case nm::YALE_STORE:
    to_return = nm_yale_map_stored(nmatrix);
    break;
  case nm::DENSE_STORE:
    to_return = nm_dense_map(nmatrix);
    break;
  case nm::LIST_STORE:
    to_return = nm_list_map_stored(nmatrix, Qnil);
    break;
  default:
    NM_CONSERVATIVE(nm_unregister_value(&amp;nmatrix));
    rb_raise(nm_eDataTypeError, &quot;Not a proper storage type&quot;);
  }

  NM_CONSERVATIVE(nm_unregister_value(&amp;nmatrix));
  return to_return;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-max" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            max() &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            max(dimen) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calculates the maximum along the specified dimension.</p>

<p>@see <a href="NMatrix.html#method-i-inject_rank">inject_rank</a></p>
          
          

          
          <div class="method-source-code" id="max-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 712</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">max</span>(<span class="ruby-identifier">dimen</span>=<span class="ruby-value">0</span>)
  <span class="ruby-identifier">inject_rank</span>(<span class="ruby-identifier">dimen</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">max</span>, <span class="ruby-identifier">sub_mat</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">max</span>.<span class="ruby-identifier">is_a?</span> <span class="ruby-constant">NMatrix</span> <span class="ruby-keyword">then</span>
      <span class="ruby-identifier">max</span> <span class="ruby-operator">*</span> (<span class="ruby-identifier">max</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-identifier">sub_mat</span>).<span class="ruby-identifier">cast</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>) <span class="ruby-operator">+</span> ((<span class="ruby-identifier">max</span>)<span class="ruby-operator">*</span><span class="ruby-value">0.0</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">max</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">sub_mat</span>).<span class="ruby-identifier">cast</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>)) <span class="ruby-operator">*</span> <span class="ruby-identifier">sub_mat</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">max</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-identifier">sub_mat</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">max</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">sub_mat</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-mean" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            mean() &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            mean(dimen) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calculates the mean along the specified dimension.</p>

<p>This will force integer types to float64 dtype.</p>

<p>@see <a href="NMatrix.html#method-i-inject_rank">inject_rank</a></p>
          
          

          
          <div class="method-source-code" id="mean-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 659</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">mean</span>(<span class="ruby-identifier">dimen</span>=<span class="ruby-value">0</span>)
  <span class="ruby-identifier">reduce_dtype</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">integer_dtype?</span> <span class="ruby-keyword">then</span>
    <span class="ruby-identifier">reduce_dtype</span> = <span class="ruby-value">:float64</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">inject_rank</span>(<span class="ruby-identifier">dimen</span>, <span class="ruby-value">0.0</span>, <span class="ruby-identifier">reduce_dtype</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">mean</span>, <span class="ruby-identifier">sub_mat</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">mean</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">sub_mat</span>
  <span class="ruby-keyword">end</span> <span class="ruby-operator">/</span> <span class="ruby-identifier">shape</span>[<span class="ruby-identifier">dimen</span>]
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-min" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            min() &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            min(dimen) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calculates the minimum along the specified dimension.</p>

<p>@see <a href="NMatrix.html#method-i-inject_rank">inject_rank</a></p>
          
          

          
          <div class="method-source-code" id="min-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 693</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">min</span>(<span class="ruby-identifier">dimen</span>=<span class="ruby-value">0</span>)
  <span class="ruby-identifier">inject_rank</span>(<span class="ruby-identifier">dimen</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">min</span>, <span class="ruby-identifier">sub_mat</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">min</span>.<span class="ruby-identifier">is_a?</span> <span class="ruby-constant">NMatrix</span> <span class="ruby-keyword">then</span>
      <span class="ruby-identifier">min</span> <span class="ruby-operator">*</span> (<span class="ruby-identifier">min</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">sub_mat</span>).<span class="ruby-identifier">cast</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>) <span class="ruby-operator">+</span> ((<span class="ruby-identifier">min</span>)<span class="ruby-operator">*</span><span class="ruby-value">0.0</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">min</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">sub_mat</span>).<span class="ruby-identifier">cast</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>)) <span class="ruby-operator">*</span> <span class="ruby-identifier">sub_mat</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">min</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">sub_mat</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">min</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">sub_mat</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-norm2" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">norm2</span><span
            class="method-args">(incx=1, n=nil)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-nrm2">nrm2</a>
        </div>
        
      </div>

    
      <div id="method-i-nrm2" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            norm2 &rarr; Numeric
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <h2 id="method-i-nrm2-label-Arguments">Arguments<span><a href="#method-i-nrm2-label-Arguments">&para;</a> <a href="#top">&uarr;</a></span></h2>

<pre>- +incx+ -&gt; the skip size (defaults to 1, no skip)
- +n+ -&gt; the number of elements to include</pre>

<p>Return the 2-norm of the vector. This is the BLAS nrm2 routine.</p>
          
          

          
          <div class="method-source-code" id="nrm2-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 824</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">nrm2</span> <span class="ruby-identifier">incx</span>=<span class="ruby-value">1</span>, <span class="ruby-identifier">n</span>=<span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">method_missing</span>(<span class="ruby-value">:nrm2</span>, <span class="ruby-identifier">incx</span>, <span class="ruby-identifier">n</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">vector?</span>
  <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">BLAS</span><span class="ruby-operator">::</span><span class="ruby-identifier">nrm2</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">incx</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">/</span> <span class="ruby-identifier">incx</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-norm2">norm2</a>
        </div>
        

        
      </div>

    
      <div id="method-i-nvector-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            nvector? &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Shortcut function for determining whether the effective dimension is less
than the dimension. Useful when we take slices of n-dimensional matrices
where n &gt; 2.</p>
          
          

          
          <div class="method-source-code" id="nvector-3F-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 429</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">nvector?</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">effective_dim</span> <span class="ruby-operator">&lt;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-object_dtype-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            object_dtype?() &rarr; Boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Checks if dtype is a ruby object</p>
          
          

          
          <div class="method-source-code" id="object_dtype-3F-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 374</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">object_dtype?</span>
  <span class="ruby-identifier">dtype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:object</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-offset" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            offset &rarr; Array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the offset (slice position) of a matrix. Typically all zeros, unless
you have a reference slice.</p>
          
          

          
          <div class="method-source-code" id="offset-source">
            <pre>static VALUE nm_offset(VALUE self) {
  NM_CONSERVATIVE(nm_register_value(&amp;self));
  STORAGE* s   = NM_STORAGE(self);

  // Copy elements into a VALUE array and then use those to create a Ruby array with rb_ary_new4.
  VALUE* offset = NM_ALLOCA_N(VALUE, s-&gt;dim);
  nm_register_values(offset, s-&gt;dim);
  for (size_t index = 0; index &lt; s-&gt;dim; ++index)
    offset[index] = INT2FIX(s-&gt;offset[index]);

  nm_unregister_values(offset, s-&gt;dim);
  NM_CONSERVATIVE(nm_unregister_value(&amp;self));
  return rb_ary_new4(s-&gt;dim, offset);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-permute_columns" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">permute_columns</span><span
            class="method-args">(ary, opts={})</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-laswp">laswp</a>
        </div>
        
      </div>

    
      <div id="method-i-permute_columns-21" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">permute_columns!</span><span
            class="method-args">(ary, opts={})</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-laswp-21">laswp!</a>
        </div>
        
      </div>

    
      <div id="method-i-potrf-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">potrf!</span><span
            class="method-args">(which)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="potrf-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/atlas.rb, line 207</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">potrf!</span>(<span class="ruby-identifier">which</span>)
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">StorageTypeError</span>, <span class="ruby-string">&quot;ATLAS functions only work on dense matrices&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dense?</span>
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">ShapeError</span>, <span class="ruby-string">&quot;Cholesky decomposition only valid for square matrices&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span> <span class="ruby-operator">==</span> <span class="ruby-value">2</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>]

  <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">LAPACK</span><span class="ruby-operator">::</span><span class="ruby-identifier">clapack_potrf</span>(<span class="ruby-value">:row</span>, <span class="ruby-identifier">which</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>], <span class="ruby-keyword">self</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>])
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-potrf_lower-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">potrf_lower!</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="potrf_lower-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 188</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">potrf_lower!</span>
  <span class="ruby-identifier">potrf!</span> <span class="ruby-value">:lower</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-potrf_upper-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">potrf_upper!</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="potrf_upper-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 184</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">potrf_upper!</span>
  <span class="ruby-identifier">potrf!</span> <span class="ruby-value">:upper</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-pow" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">pow</span><span
            class="method-args">(n)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Raise a square matrix to a power. Be careful of numeric overflows! In case
<strong>n</strong> is 0, an identity matrix of the same dimension is
returned. In case of negative <strong>n</strong>, the matrix is inverted
and the absolute value of <strong>n</strong> taken  for computing the
power.</p>

<h2 id="method-i-pow-label-Arguments">Arguments<span><a href="#method-i-pow-label-Arguments">&para;</a> <a href="#top">&uarr;</a></span></h2>
<ul><li>
<p><code>n</code> - Integer to which self is to be raised.</p>
</li></ul>

<h2 id="method-i-pow-label-References">References<span><a href="#method-i-pow-label-References">&para;</a> <a href="#top">&uarr;</a></span></h2>
<ul><li>
<p>R.G Dromey - How to Solve it by Computer. Link -</p>

<pre>http://www.amazon.com/Solve-Computer-Prentice-Hall-International-Science/dp/0134340019/ref=sr_1_1?ie=UTF8&amp;qid=1422605572&amp;sr=8-1&amp;keywords=how+to+solve+it+by+computer</pre>
</li></ul>
          
          

          
          <div class="method-source-code" id="pow-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 542</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">pow</span> <span class="ruby-identifier">n</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">ShapeError</span>, <span class="ruby-string">&quot;Only works with 2D square matrices.&quot;</span> <span class="ruby-keyword">if</span> 
    <span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">!=</span> <span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>] <span class="ruby-keyword">or</span> <span class="ruby-identifier">shape</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">!=</span> <span class="ruby-value">2</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">TypeError</span>, <span class="ruby-string">&quot;Only works with integer powers&quot;</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">n</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Integer</span>)

  <span class="ruby-identifier">sequence</span> = (<span class="ruby-identifier">integer_dtype?</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-value">:int64</span>) <span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>).<span class="ruby-identifier">clone</span>
  <span class="ruby-identifier">product</span>  = <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">eye</span> <span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-identifier">sequence</span>.<span class="ruby-identifier">dtype</span>, <span class="ruby-identifier">stype</span><span class="ruby-operator">:</span> <span class="ruby-identifier">sequence</span>.<span class="ruby-identifier">stype</span> 

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">n</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
    <span class="ruby-keyword">return</span> <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">eye</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-identifier">dtype</span>, <span class="ruby-identifier">stype</span><span class="ruby-operator">:</span> <span class="ruby-identifier">stype</span>)
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">n</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">sequence</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">n</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">0</span>
    <span class="ruby-identifier">n</span> = <span class="ruby-identifier">n</span>.<span class="ruby-identifier">abs</span>
    <span class="ruby-identifier">sequence</span>.<span class="ruby-identifier">invert!</span>
    <span class="ruby-identifier">product</span> = <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">eye</span> <span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-identifier">sequence</span>.<span class="ruby-identifier">dtype</span>, <span class="ruby-identifier">stype</span><span class="ruby-operator">:</span> <span class="ruby-identifier">sequence</span>.<span class="ruby-identifier">stype</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Decompose n to reduce the number of multiplications.</span>
  <span class="ruby-keyword">while</span> <span class="ruby-identifier">n</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
    <span class="ruby-identifier">product</span> = <span class="ruby-identifier">product</span>.<span class="ruby-identifier">dot</span>(<span class="ruby-identifier">sequence</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">n</span> <span class="ruby-operator">%</span> <span class="ruby-value">2</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
    <span class="ruby-identifier">n</span> = <span class="ruby-identifier">n</span> <span class="ruby-operator">/</span> <span class="ruby-value">2</span>
    <span class="ruby-identifier">sequence</span> = <span class="ruby-identifier">sequence</span>.<span class="ruby-identifier">dot</span>(<span class="ruby-identifier">sequence</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">product</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-quaternion" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            quaternion &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Find the quaternion for a 3D rotation matrix.</p>

<p>Code borrowed from: <a
href="http://courses.cms.caltech.edu/cs171/quatut.pdf">courses.cms.caltech.edu/cs171/quatut.pdf</a></p>
<ul><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>A length-4 <a href="NMatrix.html">NMatrix</a> representing the
corresponding quaternion.</p>
</li></ul>
</li></ul>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-identifier">n</span>.<span class="ruby-identifier">quaternion</span> <span class="ruby-comment"># =&gt; [1, 0, 0, 0]</span>
</pre>
          
          

          
          <div class="method-source-code" id="quaternion-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/homogeneous.rb, line 159</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">quaternion</span>
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">ShapeError</span>, <span class="ruby-string">&quot;Expected square matrix&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">!=</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>]
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">ShapeError</span>, <span class="ruby-string">&quot;Expected 3x3 rotation (or 4x4 homogeneous) matrix&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">&gt;</span> <span class="ruby-value">4</span> <span class="ruby-operator">||</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">&lt;</span> <span class="ruby-value">3</span>

  <span class="ruby-identifier">q</span> = <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>([<span class="ruby-value">4</span>], <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:float32</span> <span class="ruby-operator">?</span> <span class="ruby-value">:float32</span><span class="ruby-operator">:</span> <span class="ruby-value">:float64</span>)
  <span class="ruby-identifier">rotation_trace</span> = <span class="ruby-keyword">self</span>[<span class="ruby-value">0</span>,<span class="ruby-value">0</span>] <span class="ruby-operator">+</span> <span class="ruby-keyword">self</span>[<span class="ruby-value">1</span>,<span class="ruby-value">1</span>] <span class="ruby-operator">+</span> <span class="ruby-keyword">self</span>[<span class="ruby-value">2</span>,<span class="ruby-value">2</span>]
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">rotation_trace</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>
    <span class="ruby-identifier">self_w</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-value">4</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">self</span>[<span class="ruby-value">3</span>,<span class="ruby-value">3</span>] <span class="ruby-operator">:</span> <span class="ruby-value">1.0</span>
    <span class="ruby-identifier">root_of_homogeneous_trace</span> = <span class="ruby-constant">Math</span>.<span class="ruby-identifier">sqrt</span>(<span class="ruby-identifier">rotation_trace</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">self_w</span>)
    <span class="ruby-identifier">q</span>[<span class="ruby-value">0</span>] = <span class="ruby-identifier">root_of_homogeneous_trace</span> <span class="ruby-operator">*</span> <span class="ruby-value">0.5</span>
    <span class="ruby-identifier">s</span> = <span class="ruby-value">0.5</span> <span class="ruby-operator">/</span> <span class="ruby-identifier">root_of_homogeneous_trace</span>
    <span class="ruby-identifier">q</span>[<span class="ruby-value">1</span>] = (<span class="ruby-keyword">self</span>[<span class="ruby-value">2</span>,<span class="ruby-value">1</span>] <span class="ruby-operator">-</span> <span class="ruby-keyword">self</span>[<span class="ruby-value">1</span>,<span class="ruby-value">2</span>]) <span class="ruby-operator">*</span> <span class="ruby-identifier">s</span>
    <span class="ruby-identifier">q</span>[<span class="ruby-value">2</span>] = (<span class="ruby-keyword">self</span>[<span class="ruby-value">0</span>,<span class="ruby-value">2</span>] <span class="ruby-operator">-</span> <span class="ruby-keyword">self</span>[<span class="ruby-value">2</span>,<span class="ruby-value">0</span>]) <span class="ruby-operator">*</span> <span class="ruby-identifier">s</span>
    <span class="ruby-identifier">q</span>[<span class="ruby-value">3</span>] = (<span class="ruby-keyword">self</span>[<span class="ruby-value">1</span>,<span class="ruby-value">0</span>] <span class="ruby-operator">-</span> <span class="ruby-keyword">self</span>[<span class="ruby-value">0</span>,<span class="ruby-value">1</span>]) <span class="ruby-operator">*</span> <span class="ruby-identifier">s</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">h</span> = <span class="ruby-value">0</span>
    <span class="ruby-identifier">h</span> = <span class="ruby-value">1</span> <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>[<span class="ruby-value">1</span>,<span class="ruby-value">1</span>] <span class="ruby-operator">&gt;</span> <span class="ruby-keyword">self</span>[<span class="ruby-value">0</span>,<span class="ruby-value">0</span>]
    <span class="ruby-identifier">h</span> = <span class="ruby-value">2</span> <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>[<span class="ruby-value">2</span>,<span class="ruby-value">2</span>] <span class="ruby-operator">&gt;</span> <span class="ruby-keyword">self</span>[<span class="ruby-identifier">h</span>,<span class="ruby-identifier">h</span>]

    <span class="ruby-identifier">case_macro</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">i</span>,<span class="ruby-identifier">j</span>,<span class="ruby-identifier">k</span>,<span class="ruby-identifier">ii</span>,<span class="ruby-identifier">jj</span>,<span class="ruby-identifier">kk</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">qq</span> = <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>([<span class="ruby-value">4</span>], <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-value">:float64</span>)
      <span class="ruby-identifier">self_w</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-value">4</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">self</span>[<span class="ruby-value">3</span>,<span class="ruby-value">3</span>] <span class="ruby-operator">:</span> <span class="ruby-value">1.0</span>
      <span class="ruby-identifier">s</span> = <span class="ruby-constant">Math</span>.<span class="ruby-identifier">sqrt</span>( (<span class="ruby-keyword">self</span>[<span class="ruby-identifier">ii</span>,<span class="ruby-identifier">ii</span>] <span class="ruby-operator">-</span> (<span class="ruby-keyword">self</span>[<span class="ruby-identifier">jj</span>,<span class="ruby-identifier">jj</span>] <span class="ruby-operator">+</span> <span class="ruby-keyword">self</span>[<span class="ruby-identifier">kk</span>,<span class="ruby-identifier">kk</span>])) <span class="ruby-operator">+</span> <span class="ruby-identifier">self_w</span>)
      <span class="ruby-identifier">qq</span>[<span class="ruby-identifier">i</span>] = <span class="ruby-identifier">s</span><span class="ruby-operator">*</span><span class="ruby-value">0.5</span>
      <span class="ruby-identifier">s</span> = <span class="ruby-value">0.5</span> <span class="ruby-operator">/</span> <span class="ruby-identifier">s</span>
      <span class="ruby-identifier">qq</span>[<span class="ruby-identifier">j</span>] = (<span class="ruby-keyword">self</span>[<span class="ruby-identifier">ii</span>,<span class="ruby-identifier">jj</span>] <span class="ruby-operator">+</span> <span class="ruby-keyword">self</span>[<span class="ruby-identifier">jj</span>,<span class="ruby-identifier">ii</span>]) <span class="ruby-operator">*</span> <span class="ruby-identifier">s</span>
      <span class="ruby-identifier">qq</span>[<span class="ruby-identifier">k</span>] = (<span class="ruby-keyword">self</span>[<span class="ruby-identifier">kk</span>,<span class="ruby-identifier">ii</span>] <span class="ruby-operator">+</span> <span class="ruby-keyword">self</span>[<span class="ruby-identifier">ii</span>,<span class="ruby-identifier">kk</span>]) <span class="ruby-operator">*</span> <span class="ruby-identifier">s</span>
      <span class="ruby-identifier">qq</span>[<span class="ruby-value">0</span>] = (<span class="ruby-keyword">self</span>[<span class="ruby-identifier">kk</span>,<span class="ruby-identifier">jj</span>] <span class="ruby-operator">-</span> <span class="ruby-keyword">self</span>[<span class="ruby-identifier">jj</span>,<span class="ruby-identifier">kk</span>]) <span class="ruby-operator">*</span> <span class="ruby-identifier">s</span>
      <span class="ruby-identifier">qq</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">case</span> <span class="ruby-identifier">h</span>
    <span class="ruby-keyword">when</span> <span class="ruby-value">0</span>
      <span class="ruby-identifier">q</span> = <span class="ruby-identifier">case_macro</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">1</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>, <span class="ruby-value">0</span>,<span class="ruby-value">1</span>,<span class="ruby-value">2</span>)
    <span class="ruby-keyword">when</span> <span class="ruby-value">1</span>
      <span class="ruby-identifier">q</span> = <span class="ruby-identifier">case_macro</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">2</span>,<span class="ruby-value">3</span>,<span class="ruby-value">1</span>, <span class="ruby-value">1</span>,<span class="ruby-value">2</span>,<span class="ruby-value">0</span>)
    <span class="ruby-keyword">when</span> <span class="ruby-value">2</span>
      <span class="ruby-identifier">q</span> = <span class="ruby-identifier">case_macro</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">3</span>,<span class="ruby-value">1</span>,<span class="ruby-value">2</span>, <span class="ruby-value">2</span>,<span class="ruby-value">0</span>,<span class="ruby-value">1</span>)
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">self_w</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-value">4</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">self</span>[<span class="ruby-value">3</span>,<span class="ruby-value">3</span>] <span class="ruby-operator">:</span> <span class="ruby-value">1.0</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">self_w</span> <span class="ruby-operator">!=</span> <span class="ruby-value">1</span>
      <span class="ruby-identifier">s</span> = <span class="ruby-value">1.0</span> <span class="ruby-operator">/</span> <span class="ruby-constant">Math</span>.<span class="ruby-identifier">sqrt</span>(<span class="ruby-identifier">self_w</span>)
      <span class="ruby-identifier">q</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">*=</span> <span class="ruby-identifier">s</span>
      <span class="ruby-identifier">q</span>[<span class="ruby-value">1</span>] <span class="ruby-operator">*=</span> <span class="ruby-identifier">s</span>
      <span class="ruby-identifier">q</span>[<span class="ruby-value">2</span>] <span class="ruby-operator">*=</span> <span class="ruby-identifier">s</span>
      <span class="ruby-identifier">q</span>[<span class="ruby-value">3</span>] <span class="ruby-operator">*=</span> <span class="ruby-identifier">s</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">q</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-rank" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            rank(dimension, row_or_column_number) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            rank(dimension, row_or_column_number, :reference) &rarr; NMatrix reference slice
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the rank (e.g., row, column, or layer) specified, using slicing by
copy as default.</p>

<p>See @row (dimension = 0), @column (dimension = 1)</p>
          
          

          
          <div class="method-source-code" id="rank-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 481</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">rank</span>(<span class="ruby-identifier">shape_idx</span>, <span class="ruby-identifier">rank_idx</span>, <span class="ruby-identifier">meth</span> = <span class="ruby-value">:copy</span>)

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">shape_idx</span> <span class="ruby-operator">&gt;</span> (<span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span><span class="ruby-operator">-</span><span class="ruby-value">1</span>)
    <span class="ruby-identifier">raise</span>(<span class="ruby-constant">RangeError</span>, <span class="ruby-node">&quot;#rank call was out of bounds&quot;</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">params</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span>)
  <span class="ruby-identifier">params</span>.<span class="ruby-identifier">each</span>.<span class="ruby-identifier">with_index</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">v</span>,<span class="ruby-identifier">d</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">params</span>[<span class="ruby-identifier">d</span>] = <span class="ruby-identifier">d</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">shape_idx</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">rank_idx</span> <span class="ruby-operator">:</span> <span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-identifier">d</span>]
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">meth</span> <span class="ruby-operator">==</span> <span class="ruby-value">:reference</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">self</span>[<span class="ruby-operator">*</span><span class="ruby-identifier">params</span>] <span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">slice</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">params</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-reduce_along_dim" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">reduce_along_dim</span><span
            class="method-args">(dimen=0, initial=nil, dtype=nil)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-inject_rank">inject_rank</a>
        </div>
        
      </div>

    
      <div id="method-i-repeat" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            repeat(count, axis) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>count</code> -&gt; how many times <a href="NMatrix.html">NMatrix</a>
should be repeated</p>
</li><li>
<p><code>axis</code> -&gt; index of axis along which <a
href="NMatrix.html">NMatrix</a> should be repeated</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p><a href="NMatrix.html">NMatrix</a> created by repeating the existing one
along an axis</p>
</li></ul>
</li><li>
<p><strong>Examples</strong> :</p>

<pre class="ruby"><span class="ruby-identifier">m</span> = <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>([<span class="ruby-value">2</span>, <span class="ruby-value">2</span>], [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>])
<span class="ruby-identifier">m</span>.<span class="ruby-identifier">repeat</span>(<span class="ruby-value">2</span>, <span class="ruby-value">0</span>).<span class="ruby-identifier">to_a</span> <span class="ruby-comment">#&lt;= [[1, 2], [3, 4], [1, 2], [3, 4]]</span>
<span class="ruby-identifier">m</span>.<span class="ruby-identifier">repeat</span>(<span class="ruby-value">2</span>, <span class="ruby-value">1</span>).<span class="ruby-identifier">to_a</span> <span class="ruby-comment">#&lt;= [[1, 2, 1, 2], [3, 4, 3, 4]]</span>
</pre>
</li></ul>
          
          

          
          <div class="method-source-code" id="repeat-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 1008</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">repeat</span>(<span class="ruby-identifier">count</span>, <span class="ruby-identifier">axis</span>)
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&#39;Matrix should be repeated at least 2 times.&#39;</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">count</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">2</span>
  <span class="ruby-identifier">new_shape</span> = <span class="ruby-identifier">shape</span>
  <span class="ruby-identifier">new_shape</span>[<span class="ruby-identifier">axis</span>] <span class="ruby-operator">*=</span> <span class="ruby-identifier">count</span>
  <span class="ruby-identifier">new_matrix</span> = <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">new_shape</span>)
  <span class="ruby-identifier">slice</span> = <span class="ruby-identifier">new_shape</span>.<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">axis_size</span><span class="ruby-operator">|</span> <span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-identifier">axis_size</span> }
  <span class="ruby-identifier">start</span> = <span class="ruby-value">0</span>
  <span class="ruby-identifier">count</span>.<span class="ruby-identifier">times</span> <span class="ruby-keyword">do</span>
    <span class="ruby-identifier">slice</span>[<span class="ruby-identifier">axis</span>] = <span class="ruby-identifier">start</span><span class="ruby-operator">...</span>(<span class="ruby-identifier">start</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">shape</span>[<span class="ruby-identifier">axis</span>])
    <span class="ruby-identifier">new_matrix</span>[<span class="ruby-operator">*</span><span class="ruby-identifier">slice</span>] = <span class="ruby-keyword">self</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">new_matrix</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-reshape" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            reshape(new_shape) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Clone a matrix, changing the shape in the process. Note that this function
does not do a resize; the product of the new and old shapes&#39; components
must be equal.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>new_shape</code> -&gt; <a href="Array.html">Array</a> of positive
Fixnums.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>A copy with a different shape.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="reshape-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 550</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">reshape</span> <span class="ruby-identifier">new_shape</span>,<span class="ruby-operator">*</span><span class="ruby-identifier">shapes</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">new_shape</span>.<span class="ruby-identifier">is_a?</span><span class="ruby-constant">Fixnum</span>
    <span class="ruby-identifier">newer_shape</span> =  [<span class="ruby-identifier">new_shape</span>]<span class="ruby-operator">+</span><span class="ruby-identifier">shapes</span>
  <span class="ruby-keyword">else</span>  <span class="ruby-comment"># new_shape is an Array</span>
    <span class="ruby-identifier">newer_shape</span> = <span class="ruby-identifier">new_shape</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">t</span> = <span class="ruby-identifier">reshape_clone_structure</span>(<span class="ruby-identifier">newer_shape</span>)
  <span class="ruby-identifier">left_params</span>  = [<span class="ruby-value">:*</span>]<span class="ruby-operator">*</span><span class="ruby-identifier">newer_shape</span>.<span class="ruby-identifier">size</span>
  <span class="ruby-identifier">right_params</span> = [<span class="ruby-value">:*</span>]<span class="ruby-operator">*</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>.<span class="ruby-identifier">size</span>
  <span class="ruby-identifier">t</span>[<span class="ruby-operator">*</span><span class="ruby-identifier">left_params</span>] = <span class="ruby-keyword">self</span>[<span class="ruby-operator">*</span><span class="ruby-identifier">right_params</span>]
  <span class="ruby-identifier">t</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-reshape-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            reshape!(new_shape) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            reshape! new_shape  &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Reshapes the matrix (in-place) to the desired shape. Note that this
function does not do a resize; the product of the new and old shapes&#39;
components must be equal.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>new_shape</code> -&gt; <a href="Array.html">Array</a> of positive
Fixnums.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="reshape-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 575</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">reshape!</span> <span class="ruby-identifier">new_shape</span>,<span class="ruby-operator">*</span><span class="ruby-identifier">shapes</span>
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">is_ref?</span>
    <span class="ruby-identifier">raise</span>(<span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&quot;This operation cannot be performed on reference slices&quot;</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">new_shape</span>.<span class="ruby-identifier">is_a?</span><span class="ruby-constant">Fixnum</span>
      <span class="ruby-identifier">shape</span> =  [<span class="ruby-identifier">new_shape</span>]<span class="ruby-operator">+</span><span class="ruby-identifier">shapes</span>
    <span class="ruby-keyword">else</span>  <span class="ruby-comment"># new_shape is an Array</span>
      <span class="ruby-identifier">shape</span> = <span class="ruby-identifier">new_shape</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">reshape_bang</span>(<span class="ruby-identifier">shape</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-round" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">round</span><span
            class="method-args">(*args)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="round-source">
            <pre>static VALUE nm_unary_round(int argc, VALUE* argv, VALUE self) {
  NM_CONSERVATIVE(nm_register_values(argv, argc));
  const int default_precision = 0;
  NMATRIX* left;
  UnwrapNMatrix(self, left);
  std::string sym;

  switch(left-&gt;stype) {
  case nm::DENSE_STORE:
    sym = &quot;__dense_unary_round__&quot;;
    break;
  case nm::YALE_STORE:
    sym = &quot;__yale_unary_round__&quot;;
    break;
  case nm::LIST_STORE:
    sym = &quot;__list_unary_round__&quot;;
    break;
  }
  NM_CONSERVATIVE(nm_unregister_values(argv, argc));
  if (argc &gt; 0) { //supplied precision
    return rb_funcall(self, rb_intern(sym.c_str()), 1, argv[0]);
  }
  return rb_funcall(self, rb_intern(sym.c_str()), 1, nm::RubyObject(default_precision).rval);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-row" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            row(row_number) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            row(row_number, get_by) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>row_number</code> -&gt; Integer.</p>
</li><li>
<p><code>get_by</code> -&gt; Type of slicing to use, <code>:copy</code> or
<code>:reference</code>.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>An <a href="NMatrix.html">NMatrix</a> representing the requested row as a
row vector.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="row-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 533</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">row</span>(<span class="ruby-identifier">row_number</span>, <span class="ruby-identifier">get_by</span> = <span class="ruby-value">:copy</span>)
  <span class="ruby-identifier">rank</span>(<span class="ruby-value">0</span>, <span class="ruby-identifier">row_number</span>, <span class="ruby-identifier">get_by</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-rows" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            rows &rarr; Integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>This shortcut use <a href="NMatrix.html#method-i-shape">shape</a> to return
the number of rows (the first dimension) of the matrix.</p>
          
          

          
          <div class="method-source-code" id="rows-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 256</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">rows</span>
  <span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-shape" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            shape &rarr; Array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the shape (dimensions) of a matrix.</p>
          
          

          
          <div class="method-source-code" id="shape-source">
            <pre>static VALUE nm_shape(VALUE self) {
  NM_CONSERVATIVE(nm_register_value(&amp;self));
  STORAGE* s   = NM_STORAGE(self);

  // Copy elements into a VALUE array and then use those to create a Ruby array with rb_ary_new4.
  VALUE* shape = NM_ALLOCA_N(VALUE, s-&gt;dim);
  nm_register_values(shape, s-&gt;dim);
  for (size_t index = 0; index &lt; s-&gt;dim; ++index)
    shape[index] = INT2FIX(s-&gt;shape[index]);

  nm_unregister_values(shape, s-&gt;dim);
  NM_CONSERVATIVE(nm_unregister_value(&amp;self));
  return rb_ary_new4(s-&gt;dim, shape);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-shuffle" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            shuffle &rarr; ...
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            shuffle(rng) &rarr; ...
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Re-arranges the contents of an NVector.</p>

<p>TODO: Write more efficient version for Yale, list. TODO: Generalize for
more dimensions.</p>
          
          

          
          <div class="method-source-code" id="shuffle-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 886</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">shuffle</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
  <span class="ruby-identifier">method_missing</span>(<span class="ruby-value">:shuffle!</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>) <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">effective_dim</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>
  <span class="ruby-identifier">t</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">clone</span>
  <span class="ruby-identifier">t</span>.<span class="ruby-identifier">shuffle!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-shuffle-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            shuffle! &rarr; ...
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            shuffle!(random: rng) &rarr; ...
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Re-arranges the contents of an NVector.</p>

<p>TODO: Write more efficient version for Yale, list. TODO: Generalize for
more dimensions.</p>
          
          

          
          <div class="method-source-code" id="shuffle-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 868</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">shuffle!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
  <span class="ruby-identifier">method_missing</span>(<span class="ruby-value">:shuffle!</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>) <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">effective_dim</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>
  <span class="ruby-identifier">ary</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">to_flat_a</span>
  <span class="ruby-identifier">ary</span>.<span class="ruby-identifier">shuffle!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
  <span class="ruby-identifier">ary</span>.<span class="ruby-identifier">each</span>.<span class="ruby-identifier">with_index</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">v</span>,<span class="ruby-identifier">idx</span><span class="ruby-operator">|</span> <span class="ruby-keyword">self</span>[<span class="ruby-identifier">idx</span>] = <span class="ruby-identifier">v</span> }
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-size" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            size &rarr; Fixnum
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the total size of the <a href="NMatrix.html">NMatrix</a> based on
its shape.</p>
          
          

          
          <div class="method-source-code" id="size-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 413</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">size</span>
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">size</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-slice" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            slice &rarr; ...
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Access the contents of an <a href="NMatrix.html">NMatrix</a> at given
coordinates, using copying.</p>

<pre class="ruby"><span class="ruby-identifier">n</span>.<span class="ruby-identifier">slice</span>(<span class="ruby-value">3</span>,<span class="ruby-value">3</span>)  <span class="ruby-comment"># =&gt; 5.0</span>
<span class="ruby-identifier">n</span>.<span class="ruby-identifier">slice</span>(<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>,<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>) <span class="ruby-comment">#=&gt; matrix [2,2]</span>
</pre>
          
          

          
          <div class="method-source-code" id="slice-source">
            <pre>static VALUE nm_mget(int argc, VALUE* argv, VALUE self) {
  static void* (*ttable[nm::NUM_STYPES])(const STORAGE*, SLICE*) = {
    nm_dense_storage_get,
    nm_list_storage_get,
    nm_yale_storage_get
  };
  nm::stype_t stype = NM_STYPE(self);
  return nm_xslice(argc, argv, ttable[stype], nm_delete, self);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-solve" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">solve</span><span
            class="method-args">(b)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="solve-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/lapacke.rb, line 198</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">solve</span> <span class="ruby-identifier">b</span>
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">ShapeError</span>, <span class="ruby-string">&quot;Must be called on square matrix&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span> <span class="ruby-operator">==</span> <span class="ruby-value">2</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>]
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">ShapeError</span>, <span class="ruby-string">&quot;number of rows of b must equal number of cols of self&quot;</span>) <span class="ruby-keyword">if</span> 
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>] <span class="ruby-operator">!=</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&quot;only works with dense matrices&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span> <span class="ruby-operator">!=</span> <span class="ruby-value">:dense</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&quot;only works for non-integer, non-object dtypes&quot;</span> <span class="ruby-keyword">if</span> 
    <span class="ruby-identifier">integer_dtype?</span> <span class="ruby-keyword">or</span> <span class="ruby-identifier">object_dtype?</span> <span class="ruby-keyword">or</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">integer_dtype?</span> <span class="ruby-keyword">or</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">object_dtype?</span>

  <span class="ruby-identifier">x</span>     = <span class="ruby-identifier">b</span>.<span class="ruby-identifier">clone</span>
  <span class="ruby-identifier">clone</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">clone</span>
  <span class="ruby-identifier">n</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]
  <span class="ruby-identifier">ipiv</span> = <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">LAPACK</span>.<span class="ruby-identifier">lapacke_getrf</span>(<span class="ruby-value">:row</span>, <span class="ruby-identifier">n</span>, <span class="ruby-identifier">n</span>, <span class="ruby-identifier">clone</span>, <span class="ruby-identifier">n</span>)
  <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">LAPACK</span>.<span class="ruby-identifier">lapacke_getrs</span>(<span class="ruby-value">:row</span>, <span class="ruby-value">:no_transpose</span>, <span class="ruby-identifier">n</span>, <span class="ruby-identifier">b</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">clone</span>, <span class="ruby-identifier">n</span>, <span class="ruby-identifier">ipiv</span>, <span class="ruby-identifier">x</span>, <span class="ruby-identifier">b</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>])
  <span class="ruby-identifier">x</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-sorted_indices" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            sorted_indices &rarr; Array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an array of the indices ordered by value sorted.</p>
          
          

          
          <div class="method-source-code" id="sorted_indices-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 899</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">sorted_indices</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">method_missing</span>(<span class="ruby-value">:sorted_indices</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">vector?</span>
  <span class="ruby-identifier">ary</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">to_flat_array</span>
  <span class="ruby-identifier">ary</span>.<span class="ruby-identifier">each_index</span>.<span class="ruby-identifier">sort_by</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ary</span>[<span class="ruby-identifier">i</span>] }  <span class="ruby-comment"># from: http://stackoverflow.com/a/17841159/170300</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-std" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            std() &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            std(dimen) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calculates the sample standard deviation along the specified dimension.</p>

<p>This will force integer types to float64 dtype.</p>

<p>@see <a href="NMatrix.html#method-i-inject_rank">inject_rank</a></p>
          
          

          
          <div class="method-source-code" id="std-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 757</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">std</span>(<span class="ruby-identifier">dimen</span>=<span class="ruby-value">0</span>)
  <span class="ruby-identifier">variance</span>(<span class="ruby-identifier">dimen</span>).<span class="ruby-identifier">sqrt</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-stype" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            stype &rarr; Symbol
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the storage type (stype) of a matrix, e.g., :yale, :dense, or :list.</p>
          
          

          
          <div class="method-source-code" id="stype-source">
            <pre>static VALUE nm_stype(VALUE self) {
  NM_CONSERVATIVE(nm_register_value(&amp;self));
  VALUE stype = ID2SYM(rb_intern(STYPE_NAMES[NM_STYPE(self)]));
  NM_CONSERVATIVE(nm_unregister_value(&amp;self));
  return stype;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-sum" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            sum() &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            sum(dimen) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calculates the sum along the specified dimension.</p>

<p>@see <a href="NMatrix.html#method-i-inject_rank">inject_rank</a></p>
          
          

          
          <div class="method-source-code" id="sum-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 677</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">sum</span>(<span class="ruby-identifier">dimen</span>=<span class="ruby-value">0</span>)
  <span class="ruby-identifier">inject_rank</span>(<span class="ruby-identifier">dimen</span>, <span class="ruby-value">0.0</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">sum</span>, <span class="ruby-identifier">sub_mat</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">sum</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">sub_mat</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-supershape" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            supershape &rarr; Array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the shape of a slice&#39;s parent.</p>
          
          

          
          <div class="method-source-code" id="supershape-source">
            <pre>static VALUE nm_supershape(VALUE self) {

  STORAGE* s   = NM_STORAGE(self);
  if (s-&gt;src == s) {
    return nm_shape(self); // easy case (not a slice)
  }
  else s = s-&gt;src;

  NM_CONSERVATIVE(nm_register_value(&amp;self));

  VALUE* shape = NM_ALLOCA_N(VALUE, s-&gt;dim);
  nm_register_values(shape, s-&gt;dim);
  for (size_t index = 0; index &lt; s-&gt;dim; ++index)
    shape[index] = INT2FIX(s-&gt;shape[index]);

  nm_unregister_values(shape, s-&gt;dim);
  NM_CONSERVATIVE(nm_unregister_value(&amp;self));
  return rb_ary_new4(s-&gt;dim, shape);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-symmetric-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            symmetric? &rarr; Boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Is this matrix symmetric?</p>
          
          

          
          <div class="method-source-code" id="symmetric-3F-source">
            <pre>static VALUE nm_symmetric(VALUE self) {
  return is_symmetric(self, false);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-to_a" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            to_a &rarr; Array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Converts an <a href="NMatrix.html">NMatrix</a> to an array of arrays, or an
<a href="NMatrix.html">NMatrix</a> of effective dimension 1 to an array.</p>

<p>Does not yet work for dimensions &gt; 2</p>
          
          

          
          <div class="method-source-code" id="to_a-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 451</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">to_a</span>(<span class="ruby-identifier">dimen</span>=<span class="ruby-keyword">nil</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span> <span class="ruby-operator">==</span> <span class="ruby-value">2</span>

    <span class="ruby-keyword">return</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">to_flat_a</span> <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-value">1</span>

    <span class="ruby-identifier">ary</span> = []
    <span class="ruby-keyword">begin</span>
      <span class="ruby-keyword">self</span>.<span class="ruby-identifier">each_row</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">row</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">ary</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">row</span>.<span class="ruby-identifier">to_flat_a</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-comment">#rescue NotImplementedError # Oops. Try copying instead</span>
    <span class="ruby-comment">#  self.each_row(:copy) do |row|</span>
    <span class="ruby-comment">#    ary &lt;&lt; row.to_a.flatten</span>
    <span class="ruby-comment">#  end</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">ary</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">to_a_rec</span>(<span class="ruby-value">0</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-to_f" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            to_f &rarr; Float
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Converts an nmatrix with a single element (but any number of dimensions)</p>

<pre>to a float.</pre>

<p>Raises an IndexError if the matrix does not have just a single element.</p>
          
          

          
          <div class="method-source-code" id="to_f-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 388</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">to_f</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">IndexError</span>, <span class="ruby-string">&#39;to_f only valid for matrices with a single element&#39;</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">shape</span>.<span class="ruby-identifier">all?</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span> }
  <span class="ruby-keyword">self</span>[<span class="ruby-operator">*</span><span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">shape</span>.<span class="ruby-identifier">size</span>, <span class="ruby-value">0</span>)]
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-to_flat_a" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">to_flat_a</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-to_flat_array">to_flat_array</a>
        </div>
        
      </div>

    
      <div id="method-i-to_flat_array" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            to_flat_array &rarr; Array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            to_flat_a &rarr; Array
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Converts an <a href="NMatrix.html">NMatrix</a> to a one-dimensional Ruby <a
href="Array.html">Array</a>.</p>
          
          

          
          <div class="method-source-code" id="to_flat_array-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 400</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">to_flat_array</span>
  <span class="ruby-identifier">ary</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">size</span>)
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">each</span>.<span class="ruby-identifier">with_index</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">v</span>,<span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ary</span>[<span class="ruby-identifier">i</span>] = <span class="ruby-identifier">v</span> }
  <span class="ruby-identifier">ary</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-to_flat_a">to_flat_a</a>
        </div>
        

        
      </div>

    
      <div id="method-i-to_h" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">to_h</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-to_hash">to_hash</a>
        </div>
        
      </div>

    
      <div id="method-i-to_hash" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            to_hash &rarr; Hash
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Create a Ruby Hash from an <a href="NMatrix.html">NMatrix</a>.</p>
          
          

          
          <div class="method-source-code" id="to_hash-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 306</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">to_hash</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:yale</span>
    <span class="ruby-identifier">h</span> = {}
    <span class="ruby-identifier">each_stored_with_indices</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">val</span>,<span class="ruby-identifier">i</span>,<span class="ruby-identifier">j</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">next</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">val</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-comment"># Don&#39;t bother storing the diagonal zero values -- only non-zeros.</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">h</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">i</span>)
        <span class="ruby-identifier">h</span>[<span class="ruby-identifier">i</span>][<span class="ruby-identifier">j</span>] = <span class="ruby-identifier">val</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">h</span>[<span class="ruby-identifier">i</span>] = {<span class="ruby-identifier">j</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">val</span>}
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">h</span>
  <span class="ruby-keyword">else</span> <span class="ruby-comment"># dense and list should use a C internal function.</span>
    <span class="ruby-comment"># FIXME: Write a C internal to_h function.</span>
    <span class="ruby-identifier">m</span> = <span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dense</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-value">:list</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>) <span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>
    <span class="ruby-identifier">m</span>.<span class="ruby-identifier">__list_to_hash__</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-to_h">to_h</a>
        </div>
        

        
      </div>

    
      <div id="method-i-trace" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            trace &rarr; Numeric
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calculates the trace of an nxn matrix.</p>
<ul><li>
<p><strong>Raises</strong> :</p>
<ul><li>
<p><code>ShapeError</code> -&gt; Expected square matrix</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>The trace of the matrix (a numeric value)</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="trace-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 640</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">trace</span>
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">ShapeError</span>, <span class="ruby-string">&quot;Expected square matrix&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span> <span class="ruby-operator">==</span> <span class="ruby-value">2</span>

  (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]).<span class="ruby-identifier">inject</span>(<span class="ruby-value">0</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">total</span>,<span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">total</span> <span class="ruby-operator">+</span> <span class="ruby-keyword">self</span>[<span class="ruby-identifier">i</span>,<span class="ruby-identifier">i</span>]
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-transpose" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            transpose &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            transpose(permutation) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Clone a matrix, transposing it in the process. If the matrix is
two-dimensional, the permutation is taken to be [1,0] automatically (switch
dimension 0 with dimension 1). If the matrix is n-dimensional, you must
provide a permutation of <code>0...n</code>.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>permutation</code> -&gt; Optional <a href="Array.html">Array</a>
giving a permutation.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>A copy of the matrix, but transposed.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="transpose-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 602</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">transpose</span>(<span class="ruby-identifier">permute</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
    <span class="ruby-keyword">return</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">clone</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span> <span class="ruby-operator">==</span> <span class="ruby-value">2</span>
    <span class="ruby-identifier">new_shape</span> = [<span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>], <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]]
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">permute</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-identifier">raise</span>(<span class="ruby-constant">ArgumentError</span>, <span class="ruby-node">&quot;need permutation array of size #{self.dim}&quot;</span>)
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">permute</span>.<span class="ruby-identifier">sort</span>.<span class="ruby-identifier">uniq</span> <span class="ruby-operator">!=</span> (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span>).<span class="ruby-identifier">to_a</span>
    <span class="ruby-identifier">raise</span>(<span class="ruby-constant">ArgumentError</span>, <span class="ruby-string">&quot;invalid permutation array&quot;</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-comment"># Figure out the new shape based on the permutation given as an argument.</span>
    <span class="ruby-identifier">new_shape</span> = <span class="ruby-identifier">permute</span>.<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">p</span><span class="ruby-operator">|</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-identifier">p</span>] }
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">2</span> <span class="ruby-comment"># FIXME: For dense, several of these are basically equivalent to reshape.</span>

    <span class="ruby-comment"># Make the new data structure.</span>
    <span class="ruby-identifier">t</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">reshape_clone_structure</span>(<span class="ruby-identifier">new_shape</span>)

    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">each_stored_with_indices</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">v</span>,<span class="ruby-operator">*</span><span class="ruby-identifier">indices</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">p_indices</span> = <span class="ruby-identifier">permute</span>.<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">p</span><span class="ruby-operator">|</span> <span class="ruby-identifier">indices</span>[<span class="ruby-identifier">p</span>] }
      <span class="ruby-identifier">t</span>[<span class="ruby-operator">*</span><span class="ruby-identifier">p_indices</span>] = <span class="ruby-identifier">v</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">t</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">list?</span> <span class="ruby-comment"># TODO: Need a C list transposition algorithm.</span>
    <span class="ruby-comment"># Make the new data structure.</span>
    <span class="ruby-identifier">t</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">reshape_clone_structure</span>(<span class="ruby-identifier">new_shape</span>)

    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">each_column</span>.<span class="ruby-identifier">with_index</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">col</span>,<span class="ruby-identifier">j</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">t</span>[<span class="ruby-identifier">j</span>,<span class="ruby-value">:*</span>] = <span class="ruby-identifier">col</span>.<span class="ruby-identifier">to_flat_array</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">t</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-comment"># Call C versions of Yale and List transpose, which do their own copies</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">clone_transpose</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-tril" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">tril</span><span
            class="method-args">(k = 0)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-lower_triangle">lower_triangle</a>
        </div>
        
      </div>

    
      <div id="method-i-tril-21" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">tril!</span><span
            class="method-args">(k = 0)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-lower_triangle-21">lower_triangle!</a>
        </div>
        
      </div>

    
      <div id="method-i-triu" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">triu</span><span
            class="method-args">(k = 0)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-upper_triangle">upper_triangle</a>
        </div>
        
      </div>

    
      <div id="method-i-triu-21" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">triu!</span><span
            class="method-args">(k = 0)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-upper_triangle-21">upper_triangle!</a>
        </div>
        
      </div>

    
      <div id="method-i-upper_triangle" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            upper_triangle &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            upper_triangle(k) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            triu &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            triu(k) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the upper triangular portion of a matrix. This is analogous to the
<code>triu</code> method in MATLAB.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>k</code> -&gt; Positive integer. How many extra diagonals to include
in the upper triangular portion.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="upper_triangle-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 745</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">upper_triangle</span>(<span class="ruby-identifier">k</span> = <span class="ruby-value">0</span>)
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">NotImplementedError</span>, <span class="ruby-string">&quot;only implemented for 2D matrices&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">2</span>

  <span class="ruby-identifier">t</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">clone_structure</span>
  (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">k</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">0</span>
      <span class="ruby-identifier">t</span>[<span class="ruby-identifier">i</span>, <span class="ruby-value">:*</span>] = <span class="ruby-keyword">self</span>[<span class="ruby-identifier">i</span>, <span class="ruby-value">:*</span>]
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">t</span>[<span class="ruby-identifier">i</span>, <span class="ruby-value">0</span><span class="ruby-operator">...</span>(<span class="ruby-identifier">i</span><span class="ruby-operator">-</span><span class="ruby-identifier">k</span>)]             = <span class="ruby-value">0</span>
      <span class="ruby-identifier">t</span>[<span class="ruby-identifier">i</span>, (<span class="ruby-identifier">i</span><span class="ruby-operator">-</span><span class="ruby-identifier">k</span>)<span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>]] = <span class="ruby-keyword">self</span>[<span class="ruby-identifier">i</span>, (<span class="ruby-identifier">i</span><span class="ruby-operator">-</span><span class="ruby-identifier">k</span>)<span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>]]
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">t</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-triu">triu</a>
        </div>
        

        
      </div>

    
      <div id="method-i-upper_triangle-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            upper_triangle! &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            upper_triangle!(k) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            triu! &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            triu!(k) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Deletes the lower triangular portion of the matrix (in-place) so only the
upper portion remains.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>k</code> -&gt; Integer. How many extra diagonals to include in the
deletion.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="upper_triangle-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 774</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">upper_triangle!</span>(<span class="ruby-identifier">k</span> = <span class="ruby-value">0</span>)
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">NotImplementedError</span>, <span class="ruby-string">&quot;only implemented for 2D matrices&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">2</span>

  (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">k</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>
      <span class="ruby-keyword">self</span>[<span class="ruby-identifier">i</span>, <span class="ruby-value">0</span><span class="ruby-operator">...</span>(<span class="ruby-identifier">i</span><span class="ruby-operator">-</span><span class="ruby-identifier">k</span>)] = <span class="ruby-value">0</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-triu-21">triu!</a>
        </div>
        

        
      </div>

    
      <div id="method-i-variance" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            variance() &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            variance(dimen) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calculates the sample variance along the specified dimension.</p>

<p>This will force integer types to float64 dtype.</p>

<p>@see <a href="NMatrix.html#method-i-inject_rank">inject_rank</a></p>
          
          

          
          <div class="method-source-code" id="variance-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 734</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">variance</span>(<span class="ruby-identifier">dimen</span>=<span class="ruby-value">0</span>)
  <span class="ruby-identifier">reduce_dtype</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">integer_dtype?</span> <span class="ruby-keyword">then</span>
    <span class="ruby-identifier">reduce_dtype</span> = <span class="ruby-value">:float64</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">m</span> = <span class="ruby-identifier">mean</span>(<span class="ruby-identifier">dimen</span>)
  <span class="ruby-identifier">inject_rank</span>(<span class="ruby-identifier">dimen</span>, <span class="ruby-value">0.0</span>, <span class="ruby-identifier">reduce_dtype</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">var</span>, <span class="ruby-identifier">sub_mat</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">var</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">m</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">sub_mat</span>)<span class="ruby-operator">*</span>(<span class="ruby-identifier">m</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">sub_mat</span>)<span class="ruby-operator">/</span>(<span class="ruby-identifier">shape</span>[<span class="ruby-identifier">dimen</span>]<span class="ruby-operator">-</span><span class="ruby-value">1</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-vconcat" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">vconcat</span><span
            class="method-args">(*matrices)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Vertical concatenation with <code>matrices</code>.</p>
          
          

          
          <div class="method-source-code" id="vconcat-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 722</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">vconcat</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">matrices</span>)
  <span class="ruby-identifier">concat</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">matrices</span>, <span class="ruby-value">:row</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-vector-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            vector? &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Shortcut function for determining whether the effective dimension is 1. See
also <a href="NMatrix.html#method-i-nvector-3F">nvector?</a></p>
          
          

          
          <div class="method-source-code" id="vector-3F-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 439</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">vector?</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">effective_dim</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-write" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">write</span><span
            class="method-args">(*args)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Binary file writer for <a href="NMatrix.html">NMatrix</a> standard format.
file should be a path, which we aren&#39;t going to check very carefully
(in other words, this function should generally be called from a Ruby
helper method). Function also takes a symmetry argument, which allows us to
specify that we only want to save the upper triangular portion of the
matrix (or if the matrix is a lower triangular matrix, only the lower
triangular portion). nil means regular storage.</p>
          
          

          
          <div class="method-source-code" id="write-source">
            <pre>static VALUE nm_write(int argc, VALUE* argv, VALUE self) {
  using std::ofstream;

  if (argc &lt; 1 || argc &gt; 2) {
    rb_raise(rb_eArgError, &quot;Expected one or two arguments&quot;);
  }

  NM_CONSERVATIVE(nm_register_values(argv, argc));
  NM_CONSERVATIVE(nm_register_value(&amp;self));

  VALUE file = argv[0],
        symm = argc == 1 ? Qnil : argv[1];

  NMATRIX* nmatrix;
  UnwrapNMatrix( self, nmatrix );

  nm::symm_t symm_ = interpret_symm(symm);

  if (nmatrix-&gt;storage-&gt;dtype == nm::RUBYOBJ) {
    NM_CONSERVATIVE(nm_unregister_values(argv, argc));
    NM_CONSERVATIVE(nm_unregister_value(&amp;self));
    rb_raise(rb_eNotImpError, &quot;Ruby Object writing is not implemented yet&quot;);
  }

  // Get the dtype, stype, itype, and symm and ensure they&#39;re the correct number of bytes.
  uint8_t st = static_cast&lt;uint8_t&gt;(nmatrix-&gt;stype),
          dt = static_cast&lt;uint8_t&gt;(nmatrix-&gt;storage-&gt;dtype),
          sm = static_cast&lt;uint8_t&gt;(symm_);
  uint16_t dim = nmatrix-&gt;storage-&gt;dim;

  //FIXME: Cast the matrix to the smallest possible index type. Write that in the place of IType.

  // Check arguments before starting to write.
  if (nmatrix-&gt;stype == nm::LIST_STORE) {
    NM_CONSERVATIVE(nm_unregister_values(argv, argc));
    NM_CONSERVATIVE(nm_unregister_value(&amp;self));
    rb_raise(nm_eStorageTypeError, &quot;cannot save list matrix; cast to yale or dense first&quot;);
  }
  if (symm_ != nm::NONSYMM) {
    NM_CONSERVATIVE(nm_unregister_values(argv, argc));
    NM_CONSERVATIVE(nm_unregister_value(&amp;self));

    if (dim != 2) rb_raise(rb_eArgError, &quot;symmetry/triangularity not defined for a non-2D matrix&quot;);
    if (nmatrix-&gt;storage-&gt;shape[0] != nmatrix-&gt;storage-&gt;shape[1])
      rb_raise(rb_eArgError, &quot;symmetry/triangularity not defined for a non-square matrix&quot;);
    if (symm_ == nm::HERM &amp;&amp;
          dt != static_cast&lt;uint8_t&gt;(nm::COMPLEX64) &amp;&amp; dt != static_cast&lt;uint8_t&gt;(nm::COMPLEX128) &amp;&amp; dt != static_cast&lt;uint8_t&gt;(nm::RUBYOBJ))
      rb_raise(rb_eArgError, &quot;cannot save a non-complex matrix as hermitian&quot;);
  }

  ofstream f(RSTRING_PTR(file), std::ios::out | std::ios::binary);

  // Get the NMatrix version information.
  uint16_t major, minor, release, null16 = 0;
  get_version_info(major, minor, release);

  // WRITE FIRST 64-BIT BLOCK
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;major),   sizeof(uint16_t));
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;minor),   sizeof(uint16_t));
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;release), sizeof(uint16_t));
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;null16),  sizeof(uint16_t));

  uint8_t ZERO = 0;
  // WRITE SECOND 64-BIT BLOCK
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;dt), sizeof(uint8_t));
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;st), sizeof(uint8_t));
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;ZERO),sizeof(uint8_t));
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;sm), sizeof(uint8_t));
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;null16), sizeof(uint16_t));
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;dim), sizeof(uint16_t));

  // Write shape (in 64-bit blocks)
  write_padded_shape(f, nmatrix-&gt;storage-&gt;dim, nmatrix-&gt;storage-&gt;shape);

  if (nmatrix-&gt;stype == nm::DENSE_STORE) {
    write_padded_dense_elements(f, reinterpret_cast&lt;DENSE_STORAGE*&gt;(nmatrix-&gt;storage), symm_, nmatrix-&gt;storage-&gt;dtype);
  } else if (nmatrix-&gt;stype == nm::YALE_STORE) {
    YALE_STORAGE* s = reinterpret_cast&lt;YALE_STORAGE*&gt;(nmatrix-&gt;storage);
    uint32_t ndnz   = s-&gt;ndnz,
             length = nm_yale_storage_get_size(s);
    f.write(reinterpret_cast&lt;const char*&gt;(&amp;ndnz),   sizeof(uint32_t));
    f.write(reinterpret_cast&lt;const char*&gt;(&amp;length), sizeof(uint32_t));

    write_padded_yale_elements(f, s, length, symm_, s-&gt;dtype);
  }

  f.close();

  NM_CONSERVATIVE(nm_unregister_values(argv, argc));
  NM_CONSERVATIVE(nm_unregister_value(&amp;self));

  return Qtrue;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-yale-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            yale? &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Determine if <code>m</code> is a Yale matrix.</p>
          
          

          
          <div class="method-source-code" id="yale-3F-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">yale?</span>;  <span class="ruby-keyword">return</span> <span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:yale</span>; <span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
     <section id="protected-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Protected Instance Methods</h3>
       </header>

    
      <div id="method-i-__dense_unary_round__" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">__dense_unary_round__</span><span
            class="method-args">(precision)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="__dense_unary_round__-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 921</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">__dense_unary_round__</span>(<span class="ruby-identifier">precision</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">complex_dtype?</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">__dense_map__</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">l</span><span class="ruby-operator">|</span> <span class="ruby-constant">Complex</span>(<span class="ruby-identifier">l</span>.<span class="ruby-identifier">real</span>.<span class="ruby-identifier">round</span>(<span class="ruby-identifier">precision</span>), <span class="ruby-identifier">l</span>.<span class="ruby-identifier">imag</span>.<span class="ruby-identifier">round</span>(<span class="ruby-identifier">precision</span>)) }
                                  .<span class="ruby-identifier">cast</span>(<span class="ruby-identifier">stype</span>, <span class="ruby-identifier">dtype</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">__dense_map__</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">l</span><span class="ruby-operator">|</span> <span class="ruby-identifier">l</span>.<span class="ruby-identifier">round</span>(<span class="ruby-identifier">precision</span>) }.<span class="ruby-identifier">cast</span>(<span class="ruby-identifier">stype</span>, <span class="ruby-identifier">dtype</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-__list_unary_round__" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">__list_unary_round__</span><span
            class="method-args">(precision)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>These are for rounding each value of a matrix. Takes an optional argument</p>
          
          

          
          <div class="method-source-code" id="__list_unary_round__-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 903</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">__list_unary_round__</span>(<span class="ruby-identifier">precision</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">complex_dtype?</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">__list_map_stored__</span>(<span class="ruby-keyword">nil</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">l</span><span class="ruby-operator">|</span> <span class="ruby-constant">Complex</span>(<span class="ruby-identifier">l</span>.<span class="ruby-identifier">real</span>.<span class="ruby-identifier">round</span>(<span class="ruby-identifier">precision</span>), <span class="ruby-identifier">l</span>.<span class="ruby-identifier">imag</span>.<span class="ruby-identifier">round</span>(<span class="ruby-identifier">precision</span>)) }
                                  .<span class="ruby-identifier">cast</span>(<span class="ruby-identifier">stype</span>, <span class="ruby-identifier">dtype</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">__list_map_stored__</span>(<span class="ruby-keyword">nil</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">l</span><span class="ruby-operator">|</span> <span class="ruby-identifier">l</span>.<span class="ruby-identifier">round</span>(<span class="ruby-identifier">precision</span>) }.<span class="ruby-identifier">cast</span>(<span class="ruby-identifier">stype</span>, <span class="ruby-identifier">dtype</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-__yale_unary_round__" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">__yale_unary_round__</span><span
            class="method-args">(precision)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="__yale_unary_round__-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 912</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">__yale_unary_round__</span>(<span class="ruby-identifier">precision</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">complex_dtype?</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">__yale_map_stored__</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">l</span><span class="ruby-operator">|</span> <span class="ruby-constant">Complex</span>(<span class="ruby-identifier">l</span>.<span class="ruby-identifier">real</span>.<span class="ruby-identifier">round</span>(<span class="ruby-identifier">precision</span>), <span class="ruby-identifier">l</span>.<span class="ruby-identifier">imag</span>.<span class="ruby-identifier">round</span>(<span class="ruby-identifier">precision</span>)) }
                                  .<span class="ruby-identifier">cast</span>(<span class="ruby-identifier">stype</span>, <span class="ruby-identifier">dtype</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">__yale_map_stored__</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">l</span><span class="ruby-operator">|</span> <span class="ruby-identifier">l</span>.<span class="ruby-identifier">round</span>(<span class="ruby-identifier">precision</span>) }.<span class="ruby-identifier">cast</span>(<span class="ruby-identifier">stype</span>, <span class="ruby-identifier">dtype</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-dtype_for_floor_or_ceil" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">dtype_for_floor_or_ceil</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>These are for calculating the floor or ceil of matrix</p>
          
          

          
          <div class="method-source-code" id="dtype_for_floor_or_ceil-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 931</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">dtype_for_floor_or_ceil</span>
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">integer_dtype?</span> <span class="ruby-keyword">or</span> [<span class="ruby-value">:complex64</span>, <span class="ruby-value">:complex128</span>, <span class="ruby-value">:object</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>)
    <span class="ruby-identifier">return_dtype</span> = <span class="ruby-identifier">dtype</span>
  <span class="ruby-keyword">elsif</span> [<span class="ruby-value">:float32</span>, <span class="ruby-value">:float64</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>)
    <span class="ruby-identifier">return_dtype</span> = <span class="ruby-value">:int64</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">return_dtype</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://docs.seattlerb.org/rdoc/">RDoc</a> 4.2.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

